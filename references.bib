%% This BibTeX bibliography file was created using BibDesk.
%% https://bibdesk.sourceforge.io/

%% Created for Opale Sjöstedt at 2024-08-26 13:16:46 +0100 


%% Saved with string encoding Unicode (UTF-8) 



@inproceedings{iris3,
	author = {Krebbers, Robbert and Jung, Ralf and Bizjak, Ale{\v s} and Jourdan, Jacques-Henri and Dreyer, Derek and Birkedal, Lars},
	date-added = {2024-08-26 13:16:38 +0100},
	date-modified = {2024-08-26 13:16:42 +0100},
	doi = {10.1007/978-3-662-54434-1_26},
	isbn = {978-3-662-54433-4},
	month = {03},
	pages = {696-723},
	title = {The Essence of Higher-Order Concurrent Separation Logic},
	year = {2017},
	bdsk-url-1 = {https://doi.org/10.1007/978-3-662-54434-1_26}}

@article{iris2,
	abstract = {The development of concurrent separation logic (CSL) has sparked a long line of work on modular verification of sophisticated concurrent programs. Two of the most important features supported by several existing extensions to CSL are higher-order quantification and custom ghost state. However, none of the logics that support both of these features reap the full potential of their combination. In particular, none of them provide general support for a feature we dub "higher-order ghost state": the ability to store arbitrary higher-order separation-logic predicates in ghost variables. In this paper, we propose higher-order ghost state as a interesting and useful extension to CSL, which we formalize in the framework of Jung et al.'s recently developed Iris logic. To justify its soundness, we develop a novel algebraic structure called CMRAs ("cameras"), which can be thought of as "step-indexed partial commutative monoids". Finally, we show that Iris proofs utilizing higher-order ghost state can be effectively formalized in Coq, and discuss the challenges we faced in formalizing them.},
	address = {New York, NY, USA},
	author = {Jung, Ralf and Krebbers, Robbert and Birkedal, Lars and Dreyer, Derek},
	date-added = {2024-08-26 13:16:01 +0100},
	date-modified = {2024-08-26 13:16:04 +0100},
	doi = {10.1145/3022670.2951943},
	issn = {0362-1340},
	issue_date = {September 2016},
	journal = {SIGPLAN Not.},
	keywords = {interactive theorem proving, higher- order logic, fine-grained concurrency, compositional verification, Separation logic},
	month = {sep},
	number = {9},
	numpages = {14},
	pages = {256--269},
	publisher = {Association for Computing Machinery},
	title = {Higher-order ghost state},
	url = {https://doi.org/10.1145/3022670.2951943},
	volume = {51},
	year = {2016},
	bdsk-url-1 = {https://doi.org/10.1145/3022670.2951943}}

@misc{lowlevelbiab,
	archiveprefix = {arXiv},
	author = {Luk{\'a}{\v s} Hol{\'\i}k and Petr Peringer and Adam Rogalewicz and Veronika {\v S}okov{\'a} and Tom{\'a}{\v s} Vojnar and Florian Zuleger},
	date-added = {2024-08-26 10:04:21 +0100},
	date-modified = {2024-08-26 10:04:26 +0100},
	eprint = {2205.02590},
	primaryclass = {cs.LO},
	title = {Low-Level Bi-Abduction},
	url = {https://arxiv.org/abs/2205.02590},
	year = {2022},
	bdsk-url-1 = {https://arxiv.org/abs/2205.02590}}

@article{iris1,
	abstract = {We present Iris, a concurrent separation logic with a simple premise: monoids and invariants are all you need. Partial commutative monoids enable us to express---and invariants enable us to enforce---user-defined *protocols* on shared state, which are at the conceptual core of most recent program logics for concurrency. Furthermore, through a novel extension of the concept of a *view shift*, Iris supports the encoding of *logically atomic specifications*, i.e., Hoare-style specs that permit the client of an operation to treat the operation essentially as if it were atomic, even if it is not.},
	address = {New York, NY, USA},
	author = {Jung, Ralf and Swasey, David and Sieczkowski, Filip and Svendsen, Kasper and Turon, Aaron and Birkedal, Lars and Dreyer, Derek},
	date-added = {2024-08-25 14:52:57 +0100},
	date-modified = {2024-08-25 14:53:34 +0100},
	doi = {10.1145/2775051.2676980},
	issn = {0362-1340},
	issue_date = {January 2015},
	journal = {SIGPLAN Not.},
	keywords = {separation logic, partial commutative monoids, invariants, higher-order logic, fine-grained concurrency, compositional verification, atomicity},
	month = {jan},
	number = {1},
	numpages = {14},
	pages = {637--650},
	publisher = {Association for Computing Machinery},
	title = {Iris: Monoids and Invariants as an Orthogonal Basis for Concurrent Reasoning},
	url = {https://doi.org/10.1145/2775051.2676980},
	volume = {50},
	year = {2015},
	bdsk-url-1 = {https://doi.org/10.1145/2775051.2676980}}

@unpublished{cse2,
	author = {L{\"o}{\"o}w, Andreas  and Park, Seung Hoon and Nantes-Sobrinho, Daniele and Ayoun, Sacha-{\'E}lie and Sj{\"o}stedt, Opale and Maksimovi{\'c}, Petar and Gardner, Philippa},
	date-added = {2024-08-25 14:46:35 +0100},
	date-modified = {2024-08-25 14:48:06 +0100},
	title = {Parametric Compositional Symbolic Execution (working title)}}

@article{abstractpcm,
	abstract = {Concurrent separation logic is distinguished by transfer of state ownership upon parallel composition and framing. The algebraic structure that underpins ownership transfer is that of partial commutative monoids (PCMs). Extant research considers ownership transfer primarily from the logical perspective while comparatively less attention is drawn to the algebraic considerations. This paper provides an algebraic formalization of ownership transfer in concurrent separation logic by means of structure-preserving partial functions (i.e., morphisms) between PCMs, and an associated notion of separating relations. Morphisms of structures are a standard concept in algebra and category theory, but haven't seen ubiquitous use in separation logic before. Separating relations. are binary relations that generalize disjointness and characterize the inputs on which morphisms preserve structure. The two abstractions facilitate verification by enabling concise ways of writing specs, by providing abstract views of threads' states that are preserved under ownership transfer, and by enabling user-level construction of new PCMs out of existing ones.},
	address = {New York, NY, USA},
	articleno = {5},
	author = {Farka, Franti\v{s}ek and Nanevski, Aleksandar and Banerjee, Anindya and Delbianco, Germ\'{a}n Andr\'{e}s and F\'{a}bregas, Ignacio},
	date-added = {2024-08-25 14:38:24 +0100},
	date-modified = {2024-08-25 14:38:31 +0100},
	doi = {10.1145/3434286},
	issue_date = {January 2021},
	journal = {Proc. ACM Program. Lang.},
	keywords = {Program Logics for Concurrency, Hoare/Separation Logics, Coq},
	month = {jan},
	number = {POPL},
	numpages = {32},
	publisher = {Association for Computing Machinery},
	title = {On algebraic abstractions for concurrent separation logics},
	url = {https://doi.org/10.1145/3434286},
	volume = {5},
	year = {2021},
	bdsk-url-1 = {https://doi.org/10.1145/3434286}}

@article{nominallogic,
	abstract = {This paper formalises within first-order logic some common practices in computer science to do with representing and reasoning about syntactical structures involving lexically scoped binding constructs. It introduces Nominal Logic, a version of first-order many-sorted logic with equality containing primitives for renaming via name-swapping, for freshness of names, and for name-binding. Its axioms express properties of these constructs satisfied by the FM-sets model of syntax involving binding, which was recently introduced by the author and M.J. Gabbay and makes use of the Fraenkel--Mostowski permutation model of set theory. Nominal Logic serves as a vehicle for making two general points. First, name-swapping has much nicer logical properties than more general, non-bijective forms of renaming while at the same time providing a sufficient foundation for a theory of structural induction/recursion for syntax modulo α-equivalence. Secondly, it is useful for the practice of operational semantics to make explicit the equivariance property of assertions about syntax -- namely that their validity is invariant under name-swapping.},
	author = {Andrew M. Pitts},
	date-added = {2024-08-24 13:56:21 +0100},
	date-modified = {2024-08-24 13:56:25 +0100},
	doi = {https://doi.org/10.1016/S0890-5401(03)00138-X},
	issn = {0890-5401},
	journal = {Information and Computation},
	keywords = {Abstract syntax, Variable binding, Permutation, Fresh names},
	note = {Theoretical Aspects of Computer Software (TACS 2001)},
	number = {2},
	pages = {165-193},
	title = {Nominal logic, a first order theory of names and binding},
	url = {https://www.sciencedirect.com/science/article/pii/S089054010300138X},
	volume = {186},
	year = {2003},
	bdsk-url-1 = {https://www.sciencedirect.com/science/article/pii/S089054010300138X},
	bdsk-url-2 = {https://doi.org/10.1016/S0890-5401(03)00138-X}}

@misc{sufficientil,
	archiveprefix = {arXiv},
	author = {Flavio Ascari and Roberto Bruni and Roberta Gori and Francesco Logozzo},
	date-added = {2024-08-21 16:59:36 +0100},
	date-modified = {2024-08-21 16:59:42 +0100},
	eprint = {2310.18156},
	primaryclass = {cs.LO},
	title = {Sufficient Incorrectness Logic: SIL and Separation SIL},
	url = {https://arxiv.org/abs/2310.18156},
	year = {2024},
	bdsk-url-1 = {https://arxiv.org/abs/2310.18156}}

@article{biabinox,
	abstract = {Gradual verification, which supports explicitly partial specifications  
and verifies them with a combination of static and dynamic checks, makes  
verification more incremental and provides earlier feedback to developers.  
While an abstract, weakest precondition-based approach to gradual verification  
was previously proven sound, the approach did not provide sufficient guidance  
for implementation and optimization of the required run-time checks. More  
recently, gradual verification was implemented using symbolic execution  
techniques, but the soundness of the approach (as with related static  
checkers based on implicit dynamic frames) was an open question. This paper  
puts practical gradual verification on a sound footing with a formalization  
of symbolic execution, optimized run-time check generation, and run time  
execution. We prove our approach is sound; our proof also covers a core  
subset of the Viper tool, for which we are aware of no previous soundness result.  
Our formalization enabled us to find a soundness bug in an implemented gradual  
verification tool and describe the fix necessary to make it sound.},
	address = {New York, NY, USA},
	articleno = {85},
	author = {Zimmerman, Conrad and DiVincenzo, Jenna and Aldrich, Jonathan},
	date-added = {2024-08-21 14:35:33 +0100},
	date-modified = {2024-08-21 14:35:39 +0100},
	doi = {10.1145/3632927},
	issue_date = {January 2024},
	journal = {Proc. ACM Program. Lang.},
	keywords = {gradual verification, implicit dynamic frames, soundness proof, static verification, symbolic execution},
	month = {jan},
	number = {POPL},
	numpages = {30},
	publisher = {Association for Computing Machinery},
	title = {Sound Gradual Verification with Symbolic Execution},
	url = {https://doi.org/10.1145/3632927},
	volume = {8},
	year = {2024},
	bdsk-url-1 = {https://doi.org/10.1145/3632927}}

@inproceedings{towardsjs,
	abstract = {JavaScript has become the most widely used language for client-side web programming. The dynamic nature of JavaScript makes understanding its code notoriously difficult, leading to buggy programs and a lack of adequate static-analysis tools. We believe that logical reasoning has much to offer JavaScript: a simple description of program behaviour, a clear understanding of module boundaries, and the ability to verify security contracts.
  
  We introduce a program logic for reasoning about a broad subset of JavaScript, including challenging features such as prototype inheritance and with. We adapt ideas from separation logic to provide tractable reasoning about JavaScript code: reasoning about easy programs is easy; reasoning about hard programs is possible. We prove a strong soundness result. All libraries written in our subset and proved correct with respect to their specifications will be well-behaved, even when called by arbitrary JavaScript code.},
	author = {Gardner, Philippa and Maffeis, Sergio and Smith, Gareth},
	booktitle = {Proceedings of the 39\textsuperscript{th} {ACM} {SIGPLAN-SIGACT} Symposium on Principles of Programming Languages ({POPL'12})},
	date-added = {2024-08-15 19:17:21 +0100},
	date-modified = {2024-08-15 19:17:27 +0100},
	doi = {10.1145/2103656.2103663},
	editor = {Field, John and Hicks, Michael},
	month = jan,
	pages = {31--44},
	publisher = {{ACM}},
	title = {{Towards a Program Logic for JavaScript}},
	year = {2012},
	bdsk-url-1 = {https://doi.org/10.1145/2103656.2103663}}

@inproceedings{sljungle,
	abstract = {Research results from so-called ``classical'' separation logics are not easily ported to so-called ``intuitionistic'' separation logics, and vice versa. Basic questions like, ``Can the frame rule be proved independently of whether the programming language is garbage-collected?'' ``Can amortized resource analysis be ported from one separation logic to another?'' should be straightforward. But they are not. Proofs done in a particular separation logic are difficult to generalize. We argue that this limitation is caused by incompatible semantics. For example, emp sometimes holds everywhere and sometimes only on units.},
	address = {Cham},
	author = {Cao, Qinxiang and Cuellar, Santiago and Appel, Andrew W.},
	booktitle = {Programming Languages and Systems},
	date-added = {2024-08-09 20:35:30 +0200},
	date-modified = {2024-08-09 20:35:34 +0200},
	editor = {Chang, Bor-Yuh Evan},
	isbn = {978-3-319-71237-6},
	pages = {190--211},
	publisher = {Springer International Publishing},
	title = {Bringing Order to the Separation Logic Jungle},
	year = {2017},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEFAuLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvQnJpbmdpbmcgT3JkZXIgdG8gdGhlIFNlcGFyYXRpb24gTG9naWMgSnVuZ2xlLnBkZk8RBDBib29rMAQAAAAABBAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAwAABQAAAAEBAABVc2VycwAAAAUAAAABAQAAb3NjYXIAAAAHAAAAAQEAAERlc2t0b3AABAAAAAEBAABtc2NpCAAAAAEBAABleHRlcm5hbDEAAAABAQAAQnJpbmdpbmcgT3JkZXIgdG8gdGhlIFNlcGFyYXRpb24gTG9naWMgSnVuZ2xlLnBkZgAAABgAAAABBgAABAAAABQAAAAkAAAANAAAAEAAAABQAAAACAAAAAQDAACeWAAAAAAAAAgAAAAEAwAA85oDAAAAAAAIAAAABAMAAPiaAwAAAAAACAAAAAQDAAAXrQQIAAAAAAgAAAAEAwAAQgQaCQAAAAAIAAAABAMAABXkrwoAAAAAGAAAAAEGAACsAAAAvAAAAMwAAADcAAAA7AAAAPwAAAAIAAAAAAQAAEHGNzBwrB2SGAAAAAECAAABAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAIAAAABAMAAAQAAAAAAAAABAAAAAMDAAD1AQAACAAAAAEJAABmaWxlOi8vLwwAAAABAQAATWFjaW50b3NoIEhECAAAAAQDAAAAUKEbcwAAAAgAAAAABAAAQcX1BKwAAAAkAAAAAQEAAEQ1MzU3NEMxLUE3REItNEY2Qy1CMzVGLTNFMjNCMjJDMTBFOBgAAAABAgAAgQAAAAEAAADvEwAAAQAAAAAAAAAAAAAAAQAAAAEBAAAvAAAAAAAAAAEFAAAGAQAAAQIAAGZiNmJkN2EyOTkxZWYwZTY4ODgwZjc1MzY2ZDE0NjRiMTY4NjgzZTNiYjA4ZDFiZGZiMTRiNTFjNTk0Njk0Y2U7MDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDAwMDAwMDAyMDtjb20uYXBwbGUuYXBwLXNhbmRib3gucmVhZC13cml0ZTswMTswMTAwMDAxMDswMDAwMDAwMDBhYWZlNDE1OzU1Oy91c2Vycy9vc2Nhci9kZXNrdG9wL21zY2kvZXh0ZXJuYWwvYnJpbmdpbmcgb3JkZXIgdG8gdGhlIHNlcGFyYXRpb24gbG9naWMganVuZ2xlLnBkZgAAAMwAAAD+////AQAAAAAAAAAQAAAABBAAAIwAAAAAAAAABRAAAAwBAAAAAAAAEBAAADwBAAAAAAAAQBAAACwBAAAAAAAAAiAAAAgCAAAAAAAABSAAAHgBAAAAAAAAECAAAIgBAAAAAAAAESAAALwBAAAAAAAAEiAAAJwBAAAAAAAAEyAAAKwBAAAAAAAAICAAAOgBAAAAAAAAMCAAABQCAAAAAAAAAcAAAFwBAAAAAAAAEcAAABQAAAAAAAAAEsAAAGwBAAAAAAAAgPAAABwCAAAAAAAAAAgADQAaACMAdgAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAASq}}

@inbook{hosltofol,
	author = {Mansky, William and Honor{\'e}, Wolf and Appel, Andrew},
	date-added = {2024-08-09 19:53:44 +0200},
	date-modified = {2024-08-09 19:53:59 +0200},
	doi = {10.1007/978-3-030-44914-8_16},
	isbn = {978-3-030-44913-1},
	month = {04},
	pages = {428-455},
	title = {Connecting Higher-Order Separation Logic to a First-Order Outside World},
	year = {2020},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEGouLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvQ29ubmVjdGluZyBIaWdoZXItT3JkZXIgU2VwYXJhdGlvbiBMb2dpYyB0byBhIEZpcnN0LU9yZGVyIE91dHNpZGUgV29ybGQucGRmTxEEnGJvb2ucBAAAAAAEEDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIwDAAAFAAAAAQEAAFVzZXJzAAAABQAAAAEBAABvc2NhcgAAAAcAAAABAQAARGVza3RvcAAEAAAAAQEAAG1zY2kIAAAAAQEAAGV4dGVybmFsSwAAAAEBAABDb25uZWN0aW5nIEhpZ2hlci1PcmRlciBTZXBhcmF0aW9uIExvZ2ljIHRvIGEgRmlyc3QtT3JkZXIgT3V0c2lkZSBXb3JsZC5wZGYAGAAAAAEGAAAEAAAAFAAAACQAAAA0AAAAQAAAAFAAAAAIAAAABAMAAJ5YAAAAAAAACAAAAAQDAADzmgMAAAAAAAgAAAAEAwAA+JoDAAAAAAAIAAAABAMAABetBAgAAAAACAAAAAQDAABCBBoJAAAAAAgAAAAEAwAA2jilCgAAAAAYAAAAAQYAAMQAAADUAAAA5AAAAPQAAAAEAQAAFAEAAAgAAAAABAAAQcYzR4e3iMMYAAAAAQIAAAEAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAgAAAAEAwAABAAAAAAAAAAEAAAAAwMAAPUBAAAIAAAAAQkAAGZpbGU6Ly8vDAAAAAEBAABNYWNpbnRvc2ggSEQIAAAABAMAAABQoRtzAAAACAAAAAAEAABBxfUErAAAACQAAAABAQAARDUzNTc0QzEtQTdEQi00RjZDLUIzNUYtM0UyM0IyMkMxMEU4GAAAAAECAACBAAAAAQAAAO8TAAABAAAAAAAAAAAAAAABAAAAAQEAAC8AAAAAAAAAAQUAABoAAAABAQAATlNVUkxEb2N1bWVudElkZW50aWZpZXJLZXkAAAQAAAADAwAAngMAACABAAABAgAAYzg4ZDlmZWM1MTA3NGQ0ZTBkMTNlY2IzZDhlOWI4ZTNjZTM4ZTNjYTAzNGE1MzIzNDcxNWU1ZWYwMDNkZmRlYTswMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDAwMDAwMDIwO2NvbS5hcHBsZS5hcHAtc2FuZGJveC5yZWFkLXdyaXRlOzAxOzAxMDAwMDEwOzAwMDAwMDAwMGFhNTM4ZGE7NTU7L3VzZXJzL29zY2FyL2Rlc2t0b3AvbXNjaS9leHRlcm5hbC9jb25uZWN0aW5nIGhpZ2hlci1vcmRlciBzZXBhcmF0aW9uIGxvZ2ljIHRvIGEgZmlyc3Qtb3JkZXIgb3V0c2lkZSB3b3JsZC5wZGYA2AAAAP7///8BAAAAAAAAABEAAAAEEAAApAAAAAAAAAAFEAAAJAEAAAAAAAAQEAAAVAEAAAAAAABAEAAARAEAAAAAAAACIAAAIAIAAAAAAAAFIAAAkAEAAAAAAAAQIAAAoAEAAAAAAAARIAAA1AEAAAAAAAASIAAAtAEAAAAAAAATIAAAxAEAAAAAAAAgIAAAAAIAAAAAAAAwIAAALAIAAAAAAAABwAAAdAEAAAAAAAARwAAAFAAAAAAAAAASwAAAhAEAAAAAAACA8AAAZAIAAAAAAAA0AgCAWAIAAAAAAAAACAANABoAIwCQAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAABTA=},
	bdsk-url-1 = {https://doi.org/10.1007/978-3-030-44914-8_16}}

@inproceedings{backforwardsl,
	abstract = {The use of Hoare logic in combination with weakest preconditions and strongest postconditions is a standard tool for program verification, known as backward and forward reasoning. In this paper we extend these techniques to allow backward and forward reasoning for separation logic. While the former is derived directly from the standard operators of separation logic, the latter uses a new one. We implement our framework in the interactive proof assistant Isabelle/HOL, and enable automation with several interactive proof tactics.},
	address = {Cham},
	author = {Bannister, Callum and H{\"o}fner, Peter and Klein, Gerwin},
	booktitle = {Interactive Theorem Proving},
	date-added = {2024-08-09 19:50:53 +0200},
	date-modified = {2024-08-09 19:51:03 +0200},
	editor = {Avigad, Jeremy and Mahboubi, Assia},
	isbn = {978-3-319-94821-8},
	pages = {68--87},
	publisher = {Springer International Publishing},
	title = {Backwards and Forwards with Separation Logic},
	year = {2018}}

@misc{viperfoundations,
	archiveprefix = {arXiv},
	author = {Thibault Dardinier and Michael Sammler and Gaurav Parthasarathy and Alexander J. Summers and Peter M{\"u}ller},
	date-added = {2024-08-09 16:12:06 +0200},
	date-modified = {2024-08-09 16:12:14 +0200},
	eprint = {2407.20002},
	primaryclass = {cs.PL},
	title = {Formal Foundations for Translational Separation Logic Verifiers (extended version)},
	url = {https://arxiv.org/abs/2407.20002},
	year = {2024},
	bdsk-url-1 = {https://arxiv.org/abs/2407.20002}}

@inproceedings{verifast2,
	abstract = {VeriFast is a prototype verification tool for single-threaded and multithreaded C and Java programs. In this paper, we first describe the basic symbolic execution approach in some formal detail. Then we zoom in on two technical aspects: the approach to permission accounting, including fractional permissions, precise predicates, and counting permissions; and the approach to lemma function termination in the presence of dynamically-bound lemma function calls. Finally, we describe three ongoing efforts: application to JavaCard programs, integration of shape analysis, and application to Linux device drivers.},
	address = {Berlin, Heidelberg},
	author = {Jacobs, Bart and Smans, Jan and Philippaerts, Pieter and Vogels, Fr{\'e}d{\'e}ric and Penninckx, Willem and Piessens, Frank},
	booktitle = {NASA Formal Methods},
	date-added = {2024-07-20 12:39:38 +0100},
	date-modified = {2024-07-20 12:39:42 +0100},
	editor = {Bobaru, Mihaela and Havelund, Klaus and Holzmann, Gerard J. and Joshi, Rajeev},
	isbn = {978-3-642-20398-5},
	pages = {41--55},
	publisher = {Springer Berlin Heidelberg},
	title = {VeriFast: A Powerful, Sound, Predictable, Fast Verifier for C and Java},
	year = {2011}}

@webpage{iris-option,
	author = {Birkedal, Lars},
	date-added = {2024-07-09 22:14:10 +0100},
	date-modified = {2024-07-09 22:15:23 +0100},
	month = {September},
	title = {Iris: Higher-Order Concurrent Separation Logic - Lecture 10: Ghost State},
	url = {https://iris-project.org/tutorial-pdfs/lecture10-ghost-state.pdf},
	year = {2020},
	bdsk-url-1 = {https://iris-project.org/tutorial-pdfs/lecture10-ghost-state.pdf}}

@article{rustbelt,
	abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
	address = {New York, NY, USA},
	articleno = {66},
	author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
	date-added = {2024-07-09 10:39:57 +0100},
	date-modified = {2024-07-09 10:40:01 +0100},
	doi = {10.1145/3158154},
	issue_date = {January 2018},
	journal = {Proc. ACM Program. Lang.},
	keywords = {type systems, separation logic, logical relations, concurrency, Rust},
	month = {dec},
	number = {POPL},
	numpages = {34},
	publisher = {Association for Computing Machinery},
	title = {RustBelt: securing the foundations of the Rust programming language},
	url = {https://doi.org/10.1145/3158154},
	volume = {2},
	year = {2017},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEDQuLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvcnVzdGJlbHQtYXBwZW5kaXgucGRmTxED+GJvb2v4AwAAAAAEEDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPQCAAAFAAAAAQEAAFVzZXJzAAAABQAAAAEBAABvc2NhcgAAAAcAAAABAQAARGVza3RvcAAEAAAAAQEAAG1zY2kIAAAAAQEAAGV4dGVybmFsFQAAAAEBAABydXN0YmVsdC1hcHBlbmRpeC5wZGYAAAAYAAAAAQYAAAQAAAAUAAAAJAAAADQAAABAAAAAUAAAAAgAAAAEAwAAnlgAAAAAAAAIAAAABAMAAPOaAwAAAAAACAAAAAQDAAD4mgMAAAAAAAgAAAAEAwAAF60ECAAAAAAIAAAABAMAAEIEGgkAAAAACAAAAAQDAABLRv8JAAAAABgAAAABBgAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAACAAAAAAEAABBxh6eh3GjbRgAAAABAgAAAQAAAAAAAAAPAAAAAAAAAAAAAAAAAAAACAAAAAQDAAAEAAAAAAAAAAQAAAADAwAA9QEAAAgAAAABCQAAZmlsZTovLy8MAAAAAQEAAE1hY2ludG9zaCBIRAgAAAAEAwAAAFChG3MAAAAIAAAAAAQAAEHF9QSsAAAAJAAAAAEBAABENTM1NzRDMS1BN0RCLTRGNkMtQjM1Ri0zRTIzQjIyQzEwRTgYAAAAAQIAAIEAAAABAAAA7xMAAAEAAAAAAAAAAAAAAAEAAAABAQAALwAAAAAAAAABBQAA6gAAAAECAABiZWY5ZDZlYzQ0NTdjNTNiOWI3ODNmNWU5OWU2ODI5OTFiNDdlMjRhNDllYmNjYjgwMjc4MThlYzIzNDQ1MDQzOzAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwMDAwMDAwMjA7Y29tLmFwcGxlLmFwcC1zYW5kYm94LnJlYWQtd3JpdGU7MDE7MDEwMDAwMTA7MDAwMDAwMDAwOWZmNDY0Yjs1NTsvdXNlcnMvb3NjYXIvZGVza3RvcC9tc2NpL2V4dGVybmFsL3J1c3RiZWx0LWFwcGVuZGl4LnBkZgAAAMwAAAD+////AQAAAAAAAAAQAAAABBAAAHAAAAAAAAAABRAAAPAAAAAAAAAAEBAAACABAAAAAAAAQBAAABABAAAAAAAAAiAAAOwBAAAAAAAABSAAAFwBAAAAAAAAECAAAGwBAAAAAAAAESAAAKABAAAAAAAAEiAAAIABAAAAAAAAEyAAAJABAAAAAAAAICAAAMwBAAAAAAAAMCAAAPgBAAAAAAAAAcAAAEABAAAAAAAAEcAAABQAAAAAAAAAEsAAAFABAAAAAAAAgPAAAAACAAAAAAAAAAgADQAaACMAWgAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAARW},
	bdsk-url-1 = {https://doi.org/10.1145/3158154}}

@doctoralthesis{iris-thesis,
	author = {Jung, Ralf},
	date-added = {2024-06-15 09:42:35 +0200},
	date-modified = {2024-06-15 09:42:40 +0200},
	doi = {http://dx.doi.org/10.22028/D291-31946},
	title = {Understanding and evolving the Rust programming language},
	year = {2020},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEFsuLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvVW5kZXJzdGFuZGluZyBhbmQgRXZvbHZpbmcgdGhlIFJ1c3QgUHJvZ3JhbW1pbmcgTGFuZ3VhZ2UucGRmTxEEgGJvb2uABAAAAAAEEDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHADAAAFAAAAAQEAAFVzZXJzAAAABQAAAAEBAABvc2NhcgAAAAcAAAABAQAARGVza3RvcAAEAAAAAQEAAG1zY2kIAAAAAQEAAGV4dGVybmFsPAAAAAEBAABVbmRlcnN0YW5kaW5nIGFuZCBFdm9sdmluZyB0aGUgUnVzdCBQcm9ncmFtbWluZyBMYW5ndWFnZS5wZGYYAAAAAQYAAAQAAAAUAAAAJAAAADQAAABAAAAAUAAAAAgAAAAEAwAAnlgAAAAAAAAIAAAABAMAAPOaAwAAAAAACAAAAAQDAAD4mgMAAAAAAAgAAAAEAwAAF60ECAAAAAAIAAAABAMAAEIEGgkAAAAACAAAAAQDAADtbGUKAAAAABgAAAABBgAAtAAAAMQAAADUAAAA5AAAAPQAAAAEAQAACAAAAAAEAABBxg6+mn79PBgAAAABAgAAAQAAAAAAAAAPAAAAAAAAAAAAAAAAAAAACAAAAAQDAAAEAAAAAAAAAAQAAAADAwAA9QEAAAgAAAABCQAAZmlsZTovLy8MAAAAAQEAAE1hY2ludG9zaCBIRAgAAAAEAwAAAFChG3MAAAAIAAAAAAQAAEHF9QSsAAAAJAAAAAEBAABENTM1NzRDMS1BN0RCLTRGNkMtQjM1Ri0zRTIzQjIyQzEwRTgYAAAAAQIAAIEAAAABAAAA7xMAAAEAAAAAAAAAAAAAAAEAAAABAQAALwAAAAAAAAABBQAAGgAAAAEBAABOU1VSTERvY3VtZW50SWRlbnRpZmllcktleQAABAAAAAMDAABuAwAAEQEAAAECAABlNmJjYzFiYmZlMDcyMzhhYWExMDgwMDdhYzNkZTUzNzRkOTI0ZWEyOTljOTMwMjc1MDZkM2Q2ZjVhMmRhNGJkOzAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwMDAwMDAwMjA7Y29tLmFwcGxlLmFwcC1zYW5kYm94LnJlYWQtd3JpdGU7MDE7MDEwMDAwMTA7MDAwMDAwMDAwYTY1NmNlZDs1NTsvdXNlcnMvb3NjYXIvZGVza3RvcC9tc2NpL2V4dGVybmFsL3VuZGVyc3RhbmRpbmcgYW5kIGV2b2x2aW5nIHRoZSBydXN0IHByb2dyYW1taW5nIGxhbmd1YWdlLnBkZgAAAADYAAAA/v///wEAAAAAAAAAEQAAAAQQAACUAAAAAAAAAAUQAAAUAQAAAAAAABAQAABEAQAAAAAAAEAQAAA0AQAAAAAAAAIgAAAQAgAAAAAAAAUgAACAAQAAAAAAABAgAACQAQAAAAAAABEgAADEAQAAAAAAABIgAACkAQAAAAAAABMgAAC0AQAAAAAAACAgAADwAQAAAAAAADAgAAAcAgAAAAAAAAHAAABkAQAAAAAAABHAAAAUAAAAAAAAABLAAAB0AQAAAAAAAIDwAABUAgAAAAAAACQCAIBIAgAAAAAAAAAIAA0AGgAjAIEAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAFBQ==},
	bdsk-url-1 = {http://dx.doi.org/10.22028/D291-31946}}

@article{semantics123,
	author = {Hutton, Graham},
	date-added = {2024-06-07 20:25:28 +0100},
	date-modified = {2024-06-07 23:45:39 +0100},
	doi = {10.1017/S0956796823000072},
	journal = {Journal of Functional Programming},
	pages = {e9},
	title = {{Programming Language Semantics: It's Easy As 1,2,3}},
	volume = {33},
	year = {2023},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtvEFUALgAuAC8ALgAuAC8ALgAuAC8ARABlAHMAawB0AG8AcAAvAG0AcwBjAGkALwBlAHgAdABlAHIAbgBhAGwALwBQAHIAbwBnAHIAYQBtAG0AaQBuAGcAIABsAGEAbgBnAHUAYQBnAGUAIABzAGUAbQBhAG4AdABpAGMAcwAtACAASQB0IBkAcwAgAGUAYQBzAHkAIABhAHMAIAAxACwAMgAsADMALgBwAGQAZk8RBHhib29reAQAAAAABBAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABoAwAABQAAAAEBAABVc2VycwAAAAUAAAABAQAAb3NjYXIAAAAHAAAAAQEAAERlc2t0b3AABAAAAAEBAABtc2NpCAAAAAEBAABleHRlcm5hbDgAAAABAQAAUHJvZ3JhbW1pbmcgbGFuZ3VhZ2Ugc2VtYW50aWNzLSBJdOKAmXMgZWFzeSBhcyAxLDIsMy5wZGYYAAAAAQYAAAQAAAAUAAAAJAAAADQAAABAAAAAUAAAAAgAAAAEAwAAnlgAAAAAAAAIAAAABAMAAPOaAwAAAAAACAAAAAQDAAD4mgMAAAAAAAgAAAAEAwAAF60ECAAAAAAIAAAABAMAAEIEGgkAAAAACAAAAAQDAAAU4z8JAAAAABgAAAABBgAAsAAAAMAAAADQAAAA4AAAAPAAAAAAAQAACAAAAAAEAABBxgnhP5WVgRgAAAABAgAAAQAAAAAAAAAPAAAAAAAAAAAAAAAAAAAACAAAAAQDAAAEAAAAAAAAAAQAAAADAwAA9QEAAAgAAAABCQAAZmlsZTovLy8MAAAAAQEAAE1hY2ludG9zaCBIRAgAAAAEAwAAAFChG3MAAAAIAAAAAAQAAEHF9QSsAAAAJAAAAAEBAABENTM1NzRDMS1BN0RCLTRGNkMtQjM1Ri0zRTIzQjIyQzEwRTgYAAAAAQIAAIEAAAABAAAA7xMAAAEAAAAAAAAAAAAAAAEAAAABAQAALwAAAAAAAAABBQAAGgAAAAEBAABOU1VSTERvY3VtZW50SWRlbnRpZmllcktleQAABAAAAAMDAABbAwAADQEAAAECAAA4ZjE4MmYxNjQ2MWJhMjY4MmMxOWQ5MWE3ZjFiY2RkOTEzNzEzY2ZkNmEzZWRkODAyNTYyYjcxNTI5ZDNjNjk4OzAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwMDAwMDAwMjA7Y29tLmFwcGxlLmFwcC1zYW5kYm94LnJlYWQtd3JpdGU7MDE7MDEwMDAwMTA7MDAwMDAwMDAwOTNmZTMxNDs1NTsvdXNlcnMvb3NjYXIvZGVza3RvcC9tc2NpL2V4dGVybmFsL3Byb2dyYW1taW5nIGxhbmd1YWdlIHNlbWFudGljcy0gaXTigJlzIGVhc3kgYXMgMSwyLDMucGRmAAAAANgAAAD+////AQAAAAAAAAARAAAABBAAAJAAAAAAAAAABRAAABABAAAAAAAAEBAAAEABAAAAAAAAQBAAADABAAAAAAAAAiAAAAwCAAAAAAAABSAAAHwBAAAAAAAAECAAAIwBAAAAAAAAESAAAMABAAAAAAAAEiAAAKABAAAAAAAAEyAAALABAAAAAAAAICAAAOwBAAAAAAAAMCAAABgCAAAAAAAAAcAAAGABAAAAAAAAEcAAABQAAAAAAAAAEsAAAHABAAAAAAAAgPAAAFACAAAAAAAAIAIAgEQCAAAAAAAAAAgADQAaACMA0AAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAVM},
	bdsk-url-1 = {https://doi.org/10.1017/S0956796823000072}}

@article{corestar,
	author = {Botincan, Matko and Distefano, Dino and Dodds, Mike and Grigore, Radu and E, Daiva and Parkinson, Matthew},
	date-added = {2024-06-06 16:30:57 +0100},
	date-modified = {2024-06-06 16:31:01 +0100},
	month = {05},
	title = {coreStar: The Core of jStar},
	year = {2012}}

@inproceedings{smallfoot,
	author = {Berdine, Josh and Calcagno, Cristiano and O'Hearn, Peter},
	date-added = {2024-06-06 13:15:28 +0100},
	date-modified = {2024-06-06 13:15:31 +0100},
	doi = {10.1007/11804192_6},
	isbn = {978-3-540-36749-9},
	journal = {FMCO},
	month = {11},
	pages = {115-137},
	title = {Modular Automatic Assertion Checking with Separation Logic},
	volume = {4111},
	year = {2005},
	bdsk-url-1 = {https://doi.org/10.1007/11804192_6}}

@inproceedings{select-system,
	abstract = {SELECT is an experimental system for assisting in the formal systematic debugging of programs. It is intended to be a compromise between an automated program proving system and the current ad hoc debugging practice, and is similar to a system being developed by King et al. of IBM. SELECT systematically handles the paths of programs written in a LISP subset that includes arrays. For each execution path SELECT returns simplified conditions on input variables that cause the path to be executed, and simplified symbolic values for program variables at the path output. For conditions which form a system of linear equalities and inequalities SELECT will return input variable values that can serve as sample test data. The user can insert constraint conditions, at any point in the program including the output, in the form of symbolically executable assertions. These conditions can induce the system to select test data in user-specified regions. SELECT can also determine if the path is correct with respect to an output assertion. We present four examples demonstrating the various modes of system operation and their effectiveness in finding bugs. In some examples, SELECT was successful in automatically finding useful test data. In others, user interaction was required in the form of output assertions. SELECT appears to be a useful tool for rapidly revealing program errors, but for the future there is a need to expand its expressive and deductive power.},
	address = {New York, NY, USA},
	author = {Boyer, Robert S. and Elspas, Bernard and Levitt, Karl N.},
	booktitle = {Proceedings of the International Conference on Reliable Software},
	date-added = {2024-06-06 12:27:57 +0100},
	date-modified = {2024-06-06 12:28:36 +0100},
	doi = {10.1145/800027.808445},
	isbn = {9781450373852},
	keywords = {Test data generation, Symbolic execution, Solution of systems of inequalities, Program verification, Program testing, Program debugging},
	location = {Los Angeles, California},
	numpages = {12},
	pages = {234--245},
	publisher = {Association for Computing Machinery},
	title = {SELECT---a formal system for testing and debugging programs by symbolic execution},
	url = {https://doi.org/10.1145/800027.808445},
	year = {1975},
	bdsk-url-1 = {https://doi.org/10.1145/800027.808445}}

@article{effigy-system,
	abstract = {This paper describes the symbolic execution of programs. Instead of supplying the normal inputs to a program (e.g. numbers) one supplies symbols representing arbitrary values. The execution proceeds as in a normal execution except that values may be symbolic formulas over the input symbols. The difficult, yet interesting issues arise during the symbolic execution of conditional branch type statements. A particular system called EFFIGY which provides symbolic execution for program testing and debugging is also described. It interpretively executes programs written in a simple PL/I style programming language. It includes many standard debugging features, the ability to manage and to prove things about symbolic expressions, a simple program testing manager, and a program verifier. A brief discussion of the relationship between symbolic execution and program proving is also included.},
	address = {New York, NY, USA},
	author = {King, James C.},
	date-added = {2024-06-06 12:22:36 +0100},
	date-modified = {2024-06-06 12:27:04 +0100},
	doi = {10.1145/360248.360252},
	issn = {0001-0782},
	issue_date = {July 1976},
	journal = {Commun. ACM},
	keywords = {symbolic interpretation, symbolic execution, program verification, program testing, program proving, program debugging},
	month = {jul},
	number = {7},
	numpages = {10},
	pages = {385--394},
	publisher = {Association for Computing Machinery},
	title = {Symbolic execution and program testing},
	url = {https://doi.org/10.1145/360248.360252},
	volume = {19},
	year = {1976},
	bdsk-url-1 = {https://doi.org/10.1145/360248.360252}}

@unpublished{sacha-phd,
	author = {Ayoun, Sacha-\'{E}lie},
	date-added = {2024-06-06 01:21:25 +0100},
	date-modified = {2024-06-06 01:22:23 +0100},
	title = {{Gillian: Foundations, Implementation and Applications of Compositional Symbolic Execution}}}

@unpublished{cse1,
	author = {L{\"o}{\"o}w, Andreas and Sobrinho, Daniele and Ayoun, Sacha-{\'E}lie and Cronj{\"a}ger, Caroline and Maksimovi{\'c}, Petar and Gardner, Philippa},
	date-added = {2024-06-02 17:38:49 +0100},
	date-modified = {2024-08-25 14:50:06 +0100},
	month = {07},
	read = {1},
	title = {{Compositional Symbolic Execution for Correctness and Incorrectness Reasoning}},
	year = {2024},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEB0uLi8uLi8uLi9EZXNrdG9wL21zY2kvY3NlLnBkZk8RA+Rib29r5AMAAAAABBAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADUAgAABQAAAAEBAABVc2VycwAAAAUAAAABAQAAb3NjYXIAAAAHAAAAAQEAAERlc2t0b3AABAAAAAEBAABtc2NpBwAAAAEBAABjc2UucGRmABQAAAABBgAABAAAABQAAAAkAAAANAAAAEAAAAAIAAAABAMAAJ5YAAAAAAAACAAAAAQDAADzmgMAAAAAAAgAAAAEAwAA+JoDAAAAAAAIAAAABAMAABetBAgAAAAACAAAAAQDAACs4DkJAAAAABQAAAABBgAAbAAAAHwAAACMAAAAnAAAAKwAAAAIAAAAAAQAAEHF/mT1gAAAGAAAAAECAAABAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAIAAAABAMAAAMAAAAAAAAABAAAAAMDAAD1AQAACAAAAAEJAABmaWxlOi8vLwwAAAABAQAATWFjaW50b3NoIEhECAAAAAQDAAAAUKEbcwAAAAgAAAAABAAAQcX1BKwAAAAkAAAAAQEAAEQ1MzU3NEMxLUE3REItNEY2Qy1CMzVGLTNFMjNCMjJDMTBFOBgAAAABAgAAgQAAAAEAAADvEwAAAQAAAAAAAAAAAAAAAQAAAAEBAAAvAAAAAAAAAAEFAAAaAAAAAQEAAE5TVVJMRG9jdW1lbnRJZGVudGlmaWVyS2V5AAAEAAAAAwMAADgDAADTAAAAAQIAAGY5MGExNzFmOTY5YWMxNGMyNDU3ZDIyOWIyMDNkZTViNWRkZGEwNGViYTI4Mzk5ZjcwMjcwNWY0MTNlYmQyYTA7MDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDAwMDAwMDAyMDtjb20uYXBwbGUuYXBwLXNhbmRib3gucmVhZC13cml0ZTswMTswMTAwMDAxMDswMDAwMDAwMDA5MzllMGFjOzU1Oy91c2Vycy9vc2Nhci9kZXNrdG9wL21zY2kvY3NlLnBkZgAA2AAAAP7///8BAAAAAAAAABEAAAAEEAAAUAAAAAAAAAAFEAAAvAAAAAAAAAAQEAAA6AAAAAAAAABAEAAA2AAAAAAAAAACIAAAtAEAAAAAAAAFIAAAJAEAAAAAAAAQIAAANAEAAAAAAAARIAAAaAEAAAAAAAASIAAASAEAAAAAAAATIAAAWAEAAAAAAAAgIAAAlAEAAAAAAAAwIAAAwAEAAAAAAAABwAAACAEAAAAAAAARwAAAFAAAAAAAAAASwAAAGAEAAAAAAACA8AAA+AEAAAAAAADIAQCA7AEAAAAAAAAACAANABoAIwBDAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAABCs=}}

@inproceedings{next700seplogics,
	abstract = {In recent years, separation logic has brought great advances in the world of verification. However, there is a disturbing trend for each new library or concurrency primitive to require a new separation logic. I will argue that we shouldn't be inventing new separation logics, but should find the right logic to reason about interference, and have a powerful abstraction mechanism to enable the library's implementation details to be correctly abstracted. Adding new concurrency libraries should simply be a matter of verification, not of new logics or metatheory.},
	author = {Parkinson, Matthew J.},
	booktitle = {2010 Verified Software: Theories, Tools, Experiments},
	date-added = {2024-06-01 01:11:04 +0100},
	date-modified = {2024-06-01 01:11:09 +0100},
	edition = {Verified Software: Theories, Tools, Experiments},
	month = {August},
	pages = {169-182},
	publisher = {Springer Berlin / Heidelberg},
	series = {Lecture Notes in Computer Science},
	title = {The Next 700 Separation Logics},
	url = {https://www.microsoft.com/en-us/research/publication/the-next-700-separation-logics/},
	volume = {6217},
	year = {2010},
	bdsk-url-1 = {https://www.microsoft.com/en-us/research/publication/the-next-700-separation-logics/}}

@inproceedings{spaceinvader,
	author = {Yang, Hongseok and Lee, Oukseh and Berdine, Josh and Calcagno, Cristiano and Cook, Byron and Distefano, Dino and O'Hearn, Peter},
	date-added = {2024-05-31 19:35:12 +0100},
	date-modified = {2024-05-31 19:35:15 +0100},
	doi = {10.1007/978-3-540-70545-1_36},
	isbn = {978-3-540-70543-7},
	month = {07},
	pages = {385-398},
	title = {Scalable Shape Analysis for Systems Code},
	year = {2008},
	bdsk-url-1 = {https://doi.org/10.1007/978-3-540-70545-1_36}}

@inproceedings{macke,
	abstract = {Concolic (concrete+symbolic) execution has recently gained popularity as an effective means to uncover non-trivial vulnerabilities in software, such as subtle buffer overflows. However, symbolic execution tools that are designed to optimize statement coverage often fail to cover potentially vulnerable code because of complex system interactions and scalability issues of constraint solvers. In this paper, we present a tool (MACKE) that is based on the modular interactions inferred by static code analysis, which is combined with symbolic execution and directed inter-procedural path exploration. This provides an advantage in terms of statement coverage and ability to uncover more vulnerabilities. Our tool includes a novel feature in the form of interactive vulnerability report generation that helps developers prioritize bug fixing based on severity scores. A demo of our tool is available at https://youtu.be/icC3jc3mHEU.},
	address = {New York, NY, USA},
	author = {Ognawala, Saahil and Ochoa, Mart\'{\i}n and Pretschner, Alexander and Limmer, Tobias},
	booktitle = {Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering},
	date-added = {2024-05-30 19:22:08 +0100},
	date-modified = {2024-05-30 19:22:10 +0100},
	doi = {10.1145/2970276.2970281},
	isbn = {9781450338455},
	keywords = {Compositional analysis, Symbolic execution},
	location = {Singapore, Singapore},
	numpages = {6},
	pages = {780--785},
	publisher = {Association for Computing Machinery},
	series = {ASE '16},
	title = {MACKE: compositional analysis of low-level vulnerabilities with symbolic execution},
	url = {https://doi.org/10.1145/2970276.2970281},
	year = {2016},
	bdsk-url-1 = {https://doi.org/10.1145/2970276.2970281}}

@misc{cbmc,
	archiveprefix = {arXiv},
	author = {Daniel Kroening and Peter Schrammel and Michael Tautschnig},
	date-added = {2024-05-30 19:03:56 +0100},
	date-modified = {2024-06-06 16:58:51 +0100},
	eprint = {2302.02384},
	primaryclass = {cs.SE},
	title = {{CBMC: The C Bounded Model Checker}},
	year = {2014}}

@inproceedings{cosette,
	author = {Fragoso Santos, Jose and Maksimovi{\'c}, Petar and Grohens, Th{\'e}otime and Dolby, Julian and Gardner, Philippa},
	date-added = {2024-05-30 18:52:54 +0100},
	date-modified = {2024-05-30 18:52:57 +0100},
	doi = {10.1145/3236950.3236956},
	month = {09},
	pages = {1-14},
	title = {{Symbolic Execution for JavaScript}},
	year = {2018},
	bdsk-url-1 = {https://doi.org/10.1145/3236950.3236956}}

@article{pulse,
	abstract = {Incorrectness Logic (IL) has recently been advanced as a logical theory for compositionally proving the presence of bugs---dual to Hoare Logic, which is used to compositionally prove their absence. Though IL was motivated in large part by the aim of providing a logical foundation for bug-catching program analyses, it has remained an open question: is IL useful only retrospectively (to explain existing analyses), or can it actually be useful in developing new analyses which can catch real bugs in big programs?  In this work, we develop Pulse-X, a new, automatic program analysis for catching memory errors, based on ISL, a recent synthesis of IL and separation logic. Using Pulse-X, we have found 15 new real bugs in OpenSSL, which we have reported to OpenSSL maintainers and have since been fixed. In order not to be overwhelmed with potential but false error reports, we develop a compositional bug-reporting criterion based on a distinction between latent and manifest errors, which references the under-approximate ISL abstractions computed by Pulse-X, and we investigate the fix rate resulting from application of this criterion. Finally, to probe the potential practicality of our bug-finding method, we conduct a comparison to Infer, a widely used analyzer which has proven useful in industrial engineering practice.},
	address = {New York, NY, USA},
	articleno = {81},
	author = {Le, Quang Loc and Raad, Azalea and Villard, Jules and Berdine, Josh and Dreyer, Derek and O'Hearn, Peter W.},
	date-added = {2024-05-30 18:28:50 +0100},
	date-modified = {2024-05-30 18:28:54 +0100},
	doi = {10.1145/3527325},
	issue_date = {April 2022},
	journal = {Proc. ACM Program. Lang.},
	keywords = {bug catching, compositionality, incorrectness logic, incorrectness proving},
	month = {apr},
	number = {OOPSLA1},
	numpages = {27},
	publisher = {Association for Computing Machinery},
	title = {{Finding real bugs in big programs with incorrectness logic}},
	url = {https://doi.org/10.1145/3527325},
	volume = {6},
	year = {2022},
	bdsk-url-1 = {https://doi.org/10.1145/3527325}}

@inproceedings{reversehoare,
	abstract = {We present a novel Hoare-style logic, called Reverse Hoare Logic, which can be used to reason about state reachability of imperative programs. This enables us to give natural specifications to randomized (deterministic or nondeterministic) algorithms. We give a proof system for the logic and use this to give simple formal proofs for a number of illustrative examples. We define a weakest postcondition calculus and use this to show that the proof system is sound and complete.},
	address = {Berlin, Heidelberg},
	author = {de Vries, Edsko and Koutavas, Vasileios},
	booktitle = {{Software Engineering and Formal Methods}},
	date-added = {2024-05-30 18:08:24 +0100},
	date-modified = {2024-05-30 18:08:29 +0100},
	editor = {Barthe, Gilles and Pardo, Alberto and Schneider, Gerardo},
	isbn = {978-3-642-24690-6},
	pages = {155--171},
	publisher = {Springer Berlin Heidelberg},
	title = {{Reverse Hoare Logic}},
	year = {2011}}

@inproceedings{jstar,
	abstract = {In this paper we introduce a novel methodology for verifying a large set of Java programs which builds on recent theoretical developments in program verification: it combines the idea of abstract predicate families and the idea of symbolic execution and abstraction using separation logic. The proposed technology has been implemented in a new automatic verification system, called jStar, which combines theorem proving and abstract interpretation techniques. We demonstrate the effectiveness of our methodology by using jStar to verify example programs implementing four popular design patterns (subject/observer, visitor, factory, and pooling). Although these patterns are extensively used by object-oriented developers in real-world applications, so far they have been highly challenging for existing object-oriented verification techniques.},
	address = {New York, NY, USA},
	author = {Distefano, Dino and Parkinson J, Matthew J.},
	booktitle = {{Proceedings of the 23rd ACM SIGPLAN Conference on Object-Oriented Programming Systems Languages and Applications}},
	date-added = {2024-05-30 15:58:00 +0100},
	date-modified = {2024-05-30 15:58:08 +0100},
	doi = {10.1145/1449764.1449782},
	isbn = {9781605582153},
	keywords = {classes, design patterns, moduarity, separation logic},
	location = {Nashville, TN, USA},
	numpages = {14},
	pages = {213--226},
	publisher = {Association for Computing Machinery},
	series = {OOPSLA '08},
	title = {{jStar: towards practical verification for java}},
	url = {https://doi.org/10.1145/1449764.1449782},
	year = {2008},
	bdsk-url-1 = {https://doi.org/10.1145/1449764.1449782}}

@inproceedings{verifast,
	author = {Jacobs, Bart and Smans, Jan and Piessens, Frank},
	date-added = {2024-05-30 15:55:51 +0100},
	date-modified = {2024-05-30 15:55:57 +0100},
	doi = {10.1007/978-3-642-17164-2_21},
	isbn = {978-3-642-17163-5},
	month = {11},
	pages = {304-311},
	title = {{A Quick Tour of the VeriFast Program Verifier}},
	volume = {6461},
	year = {2010},
	bdsk-url-1 = {https://doi.org/10.1007/978-3-642-17164-2_21}}

@inproceedings{viper,
	abstract = {The automation of verification techniques based on first-order logic specifications has benefitted greatly from verification infrastructures such as Boogie and Why. These offer an intermediate language that can express diverse language features and verification techniques, as well as back-end tools: in particular, verification condition generators.},
	address = {Berlin, Heidelberg},
	author = {M{\"u}ller, Peter and Schwerhoff, Malte and Summers, Alexander J.},
	booktitle = {{Verification, Model Checking, and Abstract Interpretation}},
	date-added = {2024-05-30 15:25:12 +0100},
	date-modified = {2024-05-30 15:25:18 +0100},
	editor = {Jobstmann, Barbara and Leino, K. Rustan M.},
	isbn = {978-3-662-49122-5},
	pages = {41--62},
	publisher = {Springer Berlin Heidelberg},
	title = {{Viper: A Verification Infrastructure for Permission-Based Reasoning}},
	year = {2016}}

@article{biabduction,
	abstract = {The accurate and efficient treatment of mutable data structures is one of the outstanding problem areas in automatic program verification and analysis. Shape analysis is a form of program analysis that attempts to infer descriptions of the data structures in a program, and to prove that these structures are not misused or corrupted. It is one of the more challenging and expensive forms of program analysis, due to the complexity of aliasing and the need to look arbitrarily deeply into the program heap. This article describes a method of boosting shape analyses by defining a compositional method, where each procedure is analyzed independently of its callers. The analysis algorithm uses a restricted fragment of separation logic, and assigns a collection of Hoare triples to each procedure; the triples provide an over-approximation of data structure usage. Our method brings the usual benefits of compositionality---increased potential to scale, ability to deal with incomplete programs, graceful way to deal with imprecision---to shape analysis, for the first time.The analysis rests on a generalized form of abduction (inference of explanatory hypotheses), which we call bi-abduction. Bi-abduction displays abduction as a kind of inverse to the frame problem: it jointly infers anti-frames (missing portions of state) and frames (portions of state not touched by an operation), and is the basis of a new analysis algorithm. We have implemented our analysis and we report case studies on smaller programs to evaluate the quality of discovered specifications, and larger code bases (e.g., sendmail, an imap server, a Linux distribution) to illustrate the level of automation and scalability that we obtain from our compositional method.This article makes number of specific technical contributions on proof procedures and analysis algorithms, but in a sense its more important contribution is holistic: the explanation and demonstration of how a massive increase in automation is possible using abductive inference.},
	address = {New York, NY, USA},
	articleno = {26},
	author = {Calcagno, Cristiano and Distefano, Dino and O'Hearn, Peter W. and Yang, Hongseok},
	date-added = {2024-05-29 12:13:53 +0100},
	date-modified = {2024-05-29 12:14:00 +0100},
	doi = {10.1145/2049697.2049700},
	issn = {0004-5411},
	issue_date = {December 2011},
	journal = {J. ACM},
	keywords = {Abstract interpretation, compositionality, program proving, separation logic, static analysis},
	month = {dec},
	number = {6},
	numpages = {66},
	publisher = {Association for Computing Machinery},
	title = {{Compositional Shape Analysis by Means of Bi-Abduction}},
	url = {https://doi.org/10.1145/2049697.2049700},
	volume = {58},
	year = {2011},
	bdsk-url-1 = {https://doi.org/10.1145/2049697.2049700}}

@inproceedings{infer,
	abstract = {Infer is a new automatic program verification tool aimed at proving memory safety of C programs. It attempts to build a compositional proof of the program at hand by composing proofs of its constituent modules (functions/procedures). Bugs are extracted from failures of proof attempts. We describe the main features of Infer and some of the main ideas behind it.},
	address = {Berlin, Heidelberg},
	author = {Calcagno, Cristiano and Distefano, Dino},
	booktitle = {{Proceedings of the Third International Conference on NASA Formal Methods}},
	date-added = {2024-05-29 11:57:30 +0100},
	date-modified = {2024-05-29 11:57:33 +0100},
	isbn = {9783642203978},
	location = {Pasadena, CA},
	numpages = {7},
	pages = {459--465},
	publisher = {Springer-Verlag},
	series = {NFM'11},
	title = {{Infer: an automatic program verifier for memory safety of C programs}},
	year = {2011}}

@misc{gillianrust,
	archiveprefix = {arXiv},
	author = {Sacha-{\'E}lie Ayoun and Xavier Denis and Petar Maksimovi{\'c} and Philippa Gardner},
	date-added = {2024-05-29 11:53:02 +0100},
	date-modified = {2024-05-29 11:53:05 +0100},
	eprint = {2403.15122},
	primaryclass = {cs.PL},
	title = {{A hybrid approach to semi-automated Rust verification}},
	year = {2024}}

@article{javert1,
	abstract = {The dynamic nature of JavaScript and its complex semantics make it a difficult target for logic-based verification. We introduce JaVerT, a semi-automatic JavaScript Verification Toolchain, based on separation logic and aimed at the specialist developer wanting rich, mechanically verified specifications of critical JavaScript code. To specify JavaScript programs, we design abstractions that capture its key heap structures (for example, prototype chains and function closures), allowing the developer to write clear and succinct specifications with minimal knowledge of the JavaScript internals. To verify JavaScript programs, we develop JaVerT, a verification pipeline consisting of: JS-2-JSIL, a well-tested compiler from JavaScript to JSIL, an intermediate goto language capturing the fundamental dynamic features of JavaScript; JSIL Verify, a semi-automatic verification tool based on a sound JSIL separation logic; and verified axiomatic specifications of the JavaScript internal functions. Using JaVerT, we verify functional correctness properties of: data-structure libraries (key-value map, priority queue) written in an object-oriented style; operations on data structures such as binary search trees (BSTs) and lists; examples illustrating function closures; and test cases from the official ECMAScript test suite. The verification times suggest that reasoning about larger, more complex code using JaVerT is feasible.},
	address = {New York, NY, USA},
	articleno = {50},
	author = {{Fragoso Santos}, Jos{\'{e}} and Maksimovic, Petar and Naudziuniene, Daiva and Wood, Thomas and Gardner, Philippa},
	date-added = {2024-05-29 11:48:08 +0100},
	date-modified = {2024-08-14 15:35:20 +0100},
	doi = {10.1145/3158138},
	issue_date = {January 2018},
	journal = {Proc. ACM Program. Lang.},
	keywords = {Programming language design and implementation, JavaScript verification, Intermediate representations, Frame inference, Dynamic language verification},
	month = {dec},
	number = {POPL},
	numpages = {33},
	publisher = {Association for Computing Machinery},
	title = {{JaVerT: JavaScript verification toolchain}},
	url = {https://doi.org/10.1145/3158138},
	volume = {2},
	year = {2017},
	bdsk-url-1 = {https://doi.org/10.1145/3158138}}

@inproceedings{klee,
	abstract = {We present a new symbolic execution tool, KLEE, capable of automatically generating tests that achieve high coverage on a diverse set of complex and environmentally-intensive programs. We used KLEE to thoroughly check all 89 stand-alone programs in the GNU COREUTILS utility suite, which form the core user-level environment installed on millions of Unix systems, and arguably are the single most heavily tested set of open-source programs in existence. KLEE-generated tests achieve high line coverage -- on average over 90\% per tool (median: over 94\%) -- and significantly beat the coverage of the developers' own hand-written test suite. When we did the same for 75 equivalent tools in the BUSYBOX embedded system suite, results were even better, including 100\% coverage on 31 of them.We also used KLEE as a bug finding tool, applying it to 452 applications (over 430K total lines of code), where it found 56 serious bugs, including three in COREUTILS that had been missed for over 15 years. Finally, we used KLEE to crosscheck purportedly identical BUSYBOX and COREUTILS utilities, finding functional correctness errors and a myriad of inconsistencies.},
	address = {USA},
	author = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson},
	booktitle = {{Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation}},
	date-added = {2024-05-29 11:36:36 +0100},
	date-modified = {2024-05-29 11:36:39 +0100},
	location = {San Diego, California},
	numpages = {16},
	pages = {209--224},
	publisher = {USENIX Association},
	series = {OSDI'08},
	title = {{KLEE: unassisted and automatic generation of high-coverage tests for complex systems programs}},
	year = {2008}}

@misc{gillian0,
	archiveprefix = {arXiv},
	author = {Jos{\'e} Fragoso Santos and Petar Maksimovi{\'c} and Sacha-{\'E}lie Ayoun and Philippa Gardner},
	date-added = {2024-05-29 01:13:24 +0100},
	date-modified = {2024-05-29 01:13:35 +0100},
	eprint = {2001.05059},
	primaryclass = {cs.PL},
	title = {{Gillian: Compositional Symbolic Execution for All}},
	year = {2020}}

@article{fracpermissions2,
	abstract = {A lightweight logical approach to race-free sharing of heap storage between concurrent threads is described, based on the notion of permission to access. Transfer of permission between threads, subdivision and combination of permission is discussed. The roots of the approach are in Boyland's [3] demonstration of the utility of fractional permissions in specifying non-interference between concurrent threads. We add the notion of counting permission, which mirrors the programming technique called permission counting. Both fractional and counting permissions permit passivity, the specification that a program can be permitted to access a heap cell yet prevented from altering it. Models of both mechanisms are described. The use of two different mechanisms is defended. Some interesting problems are acknowledged and some intriguing possibilities for future development, including the notion of resourcing as a step beyond typing, are paraded.},
	address = {New York, NY, USA},
	author = {Bornat, Richard and Calcagno, Cristiano and O'Hearn, Peter and Parkinson, Matthew},
	date-added = {2024-05-28 20:38:12 +0100},
	date-modified = {2024-05-28 20:38:53 +0100},
	doi = {10.1145/1047659.1040327},
	issn = {0362-1340},
	issue_date = {January 2005},
	journal = {SIGPLAN Not.},
	keywords = {separation, permissions, logic, concurrency},
	month = {jan},
	number = {1},
	numpages = {12},
	pages = {259--270},
	publisher = {Association for Computing Machinery},
	title = {{Permission accounting in separation logic}},
	url = {https://doi.org/10.1145/1047659.1040327},
	volume = {40},
	year = {2005},
	bdsk-url-1 = {https://doi.org/10.1145/1047659.1040327}}

@inproceedings{exactsl,
	author = {Maksimovi{\'c}, Petar and Cronj{\"a}ger, Caroline and L{\"o}{\"o}w, Andreas and Sutherland, Julian and Gardner, Philippa},
	copyright = {Creative Commons Attribution 4.0 International license},
	date-added = {2024-05-28 20:30:28 +0100},
	date-modified = {2024-05-29 01:02:45 +0100},
	doi = {10.4230/LIPICS.ECOOP.2023.19},
	keywords = {Separation logic, program correctness, program incorrectness, abstraction, Theory of computation → Logic and verification, Theory of computation → Program reasoning, Theory of computation → Separation logic, Theory of computation → Hoare logic, Theory of computation → Abstraction},
	language = {en},
	publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
	read = {1},
	title = {{Exact Separation Logic: Towards Bridging the Gap Between Verification and Bug-Finding}},
	url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2023.19},
	year = {2023},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEEwuLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvRXhhY3QgU2VwYXJhdGlvbiBMb2dpYyAoRXh0ZW5kZWQgVmVyc2lvbikucGRmTxEEZGJvb2tkBAAAAAAEEDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQDAAAFAAAAAQEAAFVzZXJzAAAABQAAAAEBAABvc2NhcgAAAAcAAAABAQAARGVza3RvcAAEAAAAAQEAAG1zY2kIAAAAAQEAAGV4dGVybmFsLQAAAAEBAABFeGFjdCBTZXBhcmF0aW9uIExvZ2ljIChFeHRlbmRlZCBWZXJzaW9uKS5wZGYAAAAYAAAAAQYAAAQAAAAUAAAAJAAAADQAAABAAAAAUAAAAAgAAAAEAwAAnlgAAAAAAAAIAAAABAMAAPOaAwAAAAAACAAAAAQDAAD4mgMAAAAAAAgAAAAEAwAAF60ECAAAAAAIAAAABAMAAEIEGgkAAAAACAAAAAQDAAA5AycJAAAAABgAAAABBgAAqAAAALgAAADIAAAA2AAAAOgAAAD4AAAACAAAAAAEAABBxgM0vgAA+hgAAAABAgAAAQAAAAAAAAAPAAAAAAAAAAAAAAAAAAAACAAAAAQDAAAEAAAAAAAAAAQAAAADAwAA9QEAAAgAAAABCQAAZmlsZTovLy8MAAAAAQEAAE1hY2ludG9zaCBIRAgAAAAEAwAAAFChG3MAAAAIAAAAAAQAAEHF9QSsAAAAJAAAAAEBAABENTM1NzRDMS1BN0RCLTRGNkMtQjM1Ri0zRTIzQjIyQzEwRTgYAAAAAQIAAIEAAAABAAAA7xMAAAEAAAAAAAAAAAAAAAEAAAABAQAALwAAAAAAAAABBQAAGgAAAAEBAABOU1VSTERvY3VtZW50SWRlbnRpZmllcktleQAABAAAAAMDAABRAwAAAgEAAAECAAA3YTU4NzZkMTJlNmI3ZjRlMGY1ZTFiYzAwMjRjYTIzZDJmYmU3NzM0OTA3ZTFhNWVkNDA3MjJiMTIwZGE5OTBjOzAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwMDAwMDAwMjA7Y29tLmFwcGxlLmFwcC1zYW5kYm94LnJlYWQtd3JpdGU7MDE7MDEwMDAwMTA7MDAwMDAwMDAwOTI3MDMzOTs1NTsvdXNlcnMvb3NjYXIvZGVza3RvcC9tc2NpL2V4dGVybmFsL2V4YWN0IHNlcGFyYXRpb24gbG9naWMgKGV4dGVuZGVkIHZlcnNpb24pLnBkZgAAANgAAAD+////AQAAAAAAAAARAAAABBAAAIgAAAAAAAAABRAAAAgBAAAAAAAAEBAAADgBAAAAAAAAQBAAACgBAAAAAAAAAiAAAAQCAAAAAAAABSAAAHQBAAAAAAAAECAAAIQBAAAAAAAAESAAALgBAAAAAAAAEiAAAJgBAAAAAAAAEyAAAKgBAAAAAAAAICAAAOQBAAAAAAAAMCAAABACAAAAAAAAAcAAAFgBAAAAAAAAEcAAABQAAAAAAAAAEsAAAGgBAAAAAAAAgPAAAEgCAAAAAAAAGAIAgDwCAAAAAAAAAAgADQAaACMAcgAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAATa},
	bdsk-url-1 = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2023.19},
	bdsk-url-2 = {https://doi.org/10.4230/LIPICS.ECOOP.2023.19}}

@inproceedings{gillian2,
	abstract = {We introduce verification based on separation logic to Gillian, a multi-language platform for the development of symbolic analysis tools which is parametric on the memory model of the target language. Our work develops a methodology for constructing compositional memory models for Gillian, leading to a unified presentation of the JavaScript and C memory models. We verify the JavaScript and C implementations of the AWS Encryption SDK message header deserialisation module, specifically designing common abstractions used for both verification tasks, and find two bugs in the JavaScript and three bugs in the C implementation.},
	address = {Berlin, Heidelberg},
	author = {Maksimovi\'{c}, Petar and Ayoun, Sacha-\'{E}lie and Santos, Jos\'{e} Fragoso and Gardner, Philippa},
	booktitle = {{Computer Aided Verification: 33rd International Conference, CAV 2021, Virtual Event, July 20--23, 2021, Proceedings, Part II}},
	date-added = {2024-05-28 19:32:12 +0100},
	date-modified = {2024-05-28 19:32:33 +0100},
	doi = {10.1007/978-3-030-81688-9_38},
	isbn = {978-3-030-81687-2},
	numpages = {24},
	pages = {827--850},
	publisher = {Springer-Verlag},
	title = {{Gillian, Part II: Real-World Verification for JavaScript and C}},
	url = {https://doi.org/10.1007/978-3-030-81688-9_38},
	year = {2021},
	bdsk-url-1 = {https://doi.org/10.1007/978-3-030-81688-9_38}}

@inproceedings{gillian1,
	abstract = {We introduce Gillian, a platform for developing symbolic analysis tools for programming languages. Here, we focus on the symbolic execution engine at the heart of Gillian, which is parametric on the memory model of the target language. We give a formal description of the symbolic analysis and a modular implementation that closely follows this description. We prove a parametric soundness result, introducing restriction on abstract states, which generalises path conditions used in classical symbolic execution. We instantiate to obtain trusted symbolic testing tools for JavaScript and C, and use these tools to find bugs in real-world code, thus demonstrating the viability of our parametric approach.},
	address = {New York, NY, USA},
	author = {Fragoso Santos, Jos\'{e} and Maksimovi\'{c}, Petar and Ayoun, Sacha-\'{E}lie and Gardner, Philippa},
	booktitle = {{Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation}},
	date-added = {2024-05-28 19:31:03 +0100},
	date-modified = {2024-05-28 19:32:29 +0100},
	doi = {10.1145/3385412.3386014},
	isbn = {9781450376136},
	keywords = {C, JavaScript, Symbolic execution, bounded verification, bug-finding, parametric semantics},
	location = {London, UK},
	numpages = {16},
	pages = {927--942},
	publisher = {Association for Computing Machinery},
	series = {PLDI 2020},
	title = {{Gillian, Part I: A Multi-Language Platform for Symbolic Execution}},
	url = {https://doi.org/10.1145/3385412.3386014},
	year = {2020},
	bdsk-url-1 = {https://doi.org/10.1145/3385412.3386014}}

@inproceedings{pathexplo,
	abstract = {We discuss how to perform symbolic execution of large programs in a manner that is both compositional (hence more scalable) and demand-driven. Compositional symbolic execution means finding feasible interprocedural program paths by composing symbolic executions of feasible intraprocedural paths. By demand-driven, we mean that as few intraprocedural paths as possible are symbolically executed in order to form an interprocedural path leading to a specific target branch or statement of interest (like an assertion). A key originality of this work is that our demand-driven compositional interprocedural symbolic execution is performed entirely using first-order logic formulas solved with an off-the-shelf SMT (Satisfiability-Modulo-Theories) solver -- no procedure in-lining or custom algorithm is required for the interprocedural part. This allows a uniform and elegant way of summarizing procedures at various levels of detail and of composing those using logic formulas.},
	address = {Berlin, Heidelberg},
	author = {Anand, Saswat and Godefroid, Patrice and Tillmann, Nikolai},
	booktitle = {{Tools and Algorithms for the Construction and Analysis of Systems}},
	date-added = {2024-05-28 18:58:46 +0100},
	date-modified = {2024-05-28 18:59:22 +0100},
	editor = {Ramakrishnan, C. R. and Rehof, Jakob},
	isbn = {978-3-540-78800-3},
	pages = {367--381},
	publisher = {Springer Berlin Heidelberg},
	title = {{Demand-Driven Compositional Symbolic Execution}},
	year = {2008}}

@inproceedings{monotonicstate,
	abstract = {We extend a static type-and-capability system with new mechanisms for expressing the promise that a certain abstract value evolves monotonically with time; for enforcing this promise; and for taking advantage of this promise to establish non-trivial properties of programs. These mechanisms are independent of the treatment of mutable state, but combine with it to offer a flexible account of "monotonic state".We apply these mechanisms to solve two reasoning challenges that involve mutable state. First, we show how an implementation of thunks in terms of references can be assigned types that reflect time complexity properties, in the style of Danielsson (2008). Second, we show how an implementation of hash-consing can be assigned a specification that conceals the existence of an internal state yet guarantees that two pieces of input data receive the same hash code if and only if they are equal.},
	address = {New York, NY, USA},
	author = {Pilkiewicz, Alexandre and Pottier, Fran\c{c}ois},
	booktitle = {{Proceedings of the 7th ACM SIGPLAN Workshop on Types in Language Design and Implementation}},
	date-added = {2024-05-28 18:47:28 +0100},
	date-modified = {2024-05-28 18:47:33 +0100},
	doi = {10.1145/1929553.1929565},
	isbn = {9781450304849},
	keywords = {amortized complexity, capabilities, hash-consing, hidden state, monotonic state, specification, thunks, type-based complexity-checking, types},
	location = {Austin, Texas, USA},
	numpages = {14},
	pages = {73--86},
	publisher = {Association for Computing Machinery},
	series = {TLDI '11},
	title = {{The essence of monotonic state}},
	url = {https://doi.org/10.1145/1929553.1929565},
	year = {2011},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEEEuLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvVGhlIEVzc2VuY2Ugb2YgTW9ub3RvbmljIFN0YXRlLnBkZk8RBBBib29rEAQAAAAABBAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAwAABQAAAAEBAABVc2VycwAAAAUAAAABAQAAb3NjYXIAAAAHAAAAAQEAAERlc2t0b3AABAAAAAEBAABtc2NpCAAAAAEBAABleHRlcm5hbCIAAAABAQAAVGhlIEVzc2VuY2Ugb2YgTW9ub3RvbmljIFN0YXRlLnBkZgAAGAAAAAEGAAAEAAAAFAAAACQAAAA0AAAAQAAAAFAAAAAIAAAABAMAAJ5YAAAAAAAACAAAAAQDAADzmgMAAAAAAAgAAAAEAwAA+JoDAAAAAAAIAAAABAMAABetBAgAAAAACAAAAAQDAABCBBoJAAAAAAgAAAAEAwAADtMZCQAAAAAYAAAAAQYAAJwAAACsAAAAvAAAAMwAAADcAAAA7AAAAAgAAAAABAAAQcYAj5OE0D8YAAAAAQIAAAEAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAgAAAAEAwAABAAAAAAAAAAEAAAAAwMAAPUBAAAIAAAAAQkAAGZpbGU6Ly8vDAAAAAEBAABNYWNpbnRvc2ggSEQIAAAABAMAAABQoRtzAAAACAAAAAAEAABBxfUErAAAACQAAAABAQAARDUzNTc0QzEtQTdEQi00RjZDLUIzNUYtM0UyM0IyMkMxMEU4GAAAAAECAACBAAAAAQAAAO8TAAABAAAAAAAAAAAAAAABAAAAAQEAAC8AAAAAAAAAAQUAAPcAAAABAgAAYTBlOTZlOGIzNzQzNzk1MjhiNjc1ZmViZWRiNTdiMThiZjMzODYwMTc2Y2UwN2I4ZmVmYmM0MGRiNmNmM2U0MzswMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDAwMDAwMDIwO2NvbS5hcHBsZS5hcHAtc2FuZGJveC5yZWFkLXdyaXRlOzAxOzAxMDAwMDEwOzAwMDAwMDAwMDkxOWQzMGU7NTU7L3VzZXJzL29zY2FyL2Rlc2t0b3AvbXNjaS9leHRlcm5hbC90aGUgZXNzZW5jZSBvZiBtb25vdG9uaWMgc3RhdGUucGRmAADMAAAA/v///wEAAAAAAAAAEAAAAAQQAAB8AAAAAAAAAAUQAAD8AAAAAAAAABAQAAAsAQAAAAAAAEAQAAAcAQAAAAAAAAIgAAD4AQAAAAAAAAUgAABoAQAAAAAAABAgAAB4AQAAAAAAABEgAACsAQAAAAAAABIgAACMAQAAAAAAABMgAACcAQAAAAAAACAgAADYAQAAAAAAADAgAAAEAgAAAAAAAAHAAABMAQAAAAAAABHAAAAUAAAAAAAAABLAAABcAQAAAAAAAIDwAAAMAgAAAAAAAAAIAA0AGgAjAGcAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAEew==},
	bdsk-url-1 = {https://doi.org/10.1145/1929553.1929565}}

@article{compcert,
	author = {Leroy, Xavier and Appel, Andrew and Blazy, Sandrine and Stewart, Gordon},
	date-added = {2024-05-28 18:46:42 +0100},
	date-modified = {2024-05-28 18:46:47 +0100},
	month = {06},
	title = {{The CompCert Memory Model, Version 2}},
	year = {2012},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEEcuLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvVGhlIENvbXBDZXJ0IE1lbW9yeSBNb2RlbCwgVmVyc2lvbiAyLnBkZk8RBBxib29rHAQAAAAABBAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAwAABQAAAAEBAABVc2VycwAAAAUAAAABAQAAb3NjYXIAAAAHAAAAAQEAAERlc2t0b3AABAAAAAEBAABtc2NpCAAAAAEBAABleHRlcm5hbCgAAAABAQAAVGhlIENvbXBDZXJ0IE1lbW9yeSBNb2RlbCwgVmVyc2lvbiAyLnBkZhgAAAABBgAABAAAABQAAAAkAAAANAAAAEAAAABQAAAACAAAAAQDAACeWAAAAAAAAAgAAAAEAwAA85oDAAAAAAAIAAAABAMAAPiaAwAAAAAACAAAAAQDAAAXrQQIAAAAAAgAAAAEAwAAQgQaCQAAAAAIAAAABAMAAIBKdAgAAAAAGAAAAAEGAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAAIAAAAAAQAAEHF8VhUmgFVGAAAAAECAAABAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAIAAAABAMAAAQAAAAAAAAABAAAAAMDAAD1AQAACAAAAAEJAABmaWxlOi8vLwwAAAABAQAATWFjaW50b3NoIEhECAAAAAQDAAAAUKEbcwAAAAgAAAAABAAAQcX1BKwAAAAkAAAAAQEAAEQ1MzU3NEMxLUE3REItNEY2Qy1CMzVGLTNFMjNCMjJDMTBFOBgAAAABAgAAgQAAAAEAAADvEwAAAQAAAAAAAAAAAAAAAQAAAAEBAAAvAAAAAAAAAAEFAAD9AAAAAQIAADU0NTY2OTY4ZDU3ZDg4NjExMjIzMTMyZmMyMDFkYjdiZTEwZGE5ZTVmZGIyMTEzN2QwMTgxNjQzODc2NzZhODQ7MDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDAwMDAwMDAyMDtjb20uYXBwbGUuYXBwLXNhbmRib3gucmVhZC13cml0ZTswMTswMTAwMDAxMDswMDAwMDAwMDA4NzQ0YTgwOzU1Oy91c2Vycy9vc2Nhci9kZXNrdG9wL21zY2kvZXh0ZXJuYWwvdGhlIGNvbXBjZXJ0IG1lbW9yeSBtb2RlbCwgdmVyc2lvbiAyLnBkZgAAAADMAAAA/v///wEAAAAAAAAAEAAAAAQQAACAAAAAAAAAAAUQAAAAAQAAAAAAABAQAAAwAQAAAAAAAEAQAAAgAQAAAAAAAAIgAAD8AQAAAAAAAAUgAABsAQAAAAAAABAgAAB8AQAAAAAAABEgAACwAQAAAAAAABIgAACQAQAAAAAAABMgAACgAQAAAAAAACAgAADcAQAAAAAAADAgAAAIAgAAAAAAAAHAAABQAQAAAAAAABHAAAAUAAAAAAAAABLAAABgAQAAAAAAAIDwAAAQAgAAAAAAAAAIAA0AGgAjAG0AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAEjQ==}}

@inproceedings{structuringverifheap,
	author = {Nanevski, Aleksandar and Vafeiadis, Viktor and Berdine, Josh},
	date-added = {2024-05-28 18:45:36 +0100},
	date-modified = {2024-05-30 15:56:10 +0100},
	doi = {10.1145/1706299.1706331},
	journal = {Conference Record of the Annual ACM Symposium on Principles of Programming Languages},
	month = {01},
	pages = {261-274},
	title = {{Structuring the Verification of Heap-Manipulating Programs}},
	volume = {45},
	year = {2010},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEF0uLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvU3RydWN0dXJpbmcgdGhlIFZlcmlmaWNhdGlvbiBvZiBIZWFwLU1hbmlwdWxhdGluZyBQcm9ncmFtcy5wZGZPEQSEYm9va4QEAAAAAAQQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdAMAAAUAAAABAQAAVXNlcnMAAAAFAAAAAQEAAG9zY2FyAAAABwAAAAEBAABEZXNrdG9wAAQAAAABAQAAbXNjaQgAAAABAQAAZXh0ZXJuYWw+AAAAAQEAAFN0cnVjdHVyaW5nIHRoZSBWZXJpZmljYXRpb24gb2YgSGVhcC1NYW5pcHVsYXRpbmcgUHJvZ3JhbXMucGRmAAAYAAAAAQYAAAQAAAAUAAAAJAAAADQAAABAAAAAUAAAAAgAAAAEAwAAnlgAAAAAAAAIAAAABAMAAPOaAwAAAAAACAAAAAQDAAD4mgMAAAAAAAgAAAAEAwAAF60ECAAAAAAIAAAABAMAAEIEGgkAAAAACAAAAAQDAADR9RwJAAAAABgAAAABBgAAuAAAAMgAAADYAAAA6AAAAPgAAAAIAQAACAAAAAAEAABBxgCY7xat+xgAAAABAgAAAQAAAAAAAAAPAAAAAAAAAAAAAAAAAAAACAAAAAQDAAAEAAAAAAAAAAQAAAADAwAA9QEAAAgAAAABCQAAZmlsZTovLy8MAAAAAQEAAE1hY2ludG9zaCBIRAgAAAAEAwAAAFChG3MAAAAIAAAAAAQAAEHF9QSsAAAAJAAAAAEBAABENTM1NzRDMS1BN0RCLTRGNkMtQjM1Ri0zRTIzQjIyQzEwRTgYAAAAAQIAAIEAAAABAAAA7xMAAAEAAAAAAAAAAAAAAAEAAAABAQAALwAAAAAAAAABBQAAGgAAAAEBAABOU1VSTERvY3VtZW50SWRlbnRpZmllcktleQAABAAAAAMDAAA+AwAAEwEAAAECAAAzMDhlYjVmYjNhZmIyZmQyZmQyNGM5MDNjZjQ5MGNjYWZlMDhkZDQxZmZlYTBkZWNlMTBhZDkzMTI2NzI5NGQzOzAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwMDAwMDAwMjA7Y29tLmFwcGxlLmFwcC1zYW5kYm94LnJlYWQtd3JpdGU7MDE7MDEwMDAwMTA7MDAwMDAwMDAwOTFjZjVkMTs1NTsvdXNlcnMvb3NjYXIvZGVza3RvcC9tc2NpL2V4dGVybmFsL3N0cnVjdHVyaW5nIHRoZSB2ZXJpZmljYXRpb24gb2YgaGVhcC1tYW5pcHVsYXRpbmcgcHJvZ3JhbXMucGRmAADYAAAA/v///wEAAAAAAAAAEQAAAAQQAACYAAAAAAAAAAUQAAAYAQAAAAAAABAQAABIAQAAAAAAAEAQAAA4AQAAAAAAAAIgAAAUAgAAAAAAAAUgAACEAQAAAAAAABAgAACUAQAAAAAAABEgAADIAQAAAAAAABIgAACoAQAAAAAAABMgAAC4AQAAAAAAACAgAAD0AQAAAAAAADAgAAAgAgAAAAAAAAHAAABoAQAAAAAAABHAAAAUAAAAAAAAABLAAAB4AQAAAAAAAIDwAABYAgAAAAAAACgCAIBMAgAAAAAAAAAIAA0AGgAjAIMAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAFCw==},
	bdsk-url-1 = {https://doi.org/10.1145/1706299.1706331}}

@article{bunchedimplications,
	abstract = {The logic of bunched implications, BI, is a substructural system which freely combines an additive (intuitionistic) and a multiplicative (linear) implication via bunches (contexts with two combining operations, one which admits Weakening and Contraction and one which does not). BI may be seen to arise from two main perspectives. On the one hand, from proof-theoretic or categorical concerns and, on the other, from a possible-worlds semantics based on preordered (commutative) monoids. This semantics may be motivated from a basic model of the notion of resource. We explain BI's proof-theoretic, categorical and semantic origins. We discuss in detail the question of completeness, explaining the essential distinction between BI with and without ⊥ (the unit of ∨). We give an extensive discussion of BI as a semantically based logic of resources, giving concrete models based on Petri nets, ambients, computer memory, logic programming, and money.},
	author = {David J. Pym and Peter W. O'Hearn and Hongseok Yang},
	date-added = {2024-05-28 18:44:49 +0100},
	date-modified = {2024-05-28 18:44:55 +0100},
	doi = {https://doi.org/10.1016/j.tcs.2003.11.020},
	issn = {0304-3975},
	journal = {Theoretical Computer Science},
	note = {Mathematical Foundations of Programming Semantics},
	number = {1},
	pages = {257-305},
	title = {{Possible worlds and resources: the semantics of BI}},
	url = {https://www.sciencedirect.com/science/article/pii/S0304397503006248},
	volume = {315},
	year = {2004},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEFUuLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvUG9zc2libGUgV29ybGRzIGFuZCBSZXNvdXJjZXMtIFRoZSBTZW1hbnRpY3Mgb2YgQkkucGRmTxEEOGJvb2s4BAAAAAAEEDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQDAAAFAAAAAQEAAFVzZXJzAAAABQAAAAEBAABvc2NhcgAAAAcAAAABAQAARGVza3RvcAAEAAAAAQEAAG1zY2kIAAAAAQEAAGV4dGVybmFsNgAAAAEBAABQb3NzaWJsZSBXb3JsZHMgYW5kIFJlc291cmNlcy0gVGhlIFNlbWFudGljcyBvZiBCSS5wZGYAABgAAAABBgAABAAAABQAAAAkAAAANAAAAEAAAABQAAAACAAAAAQDAACeWAAAAAAAAAgAAAAEAwAA85oDAAAAAAAIAAAABAMAAPiaAwAAAAAACAAAAAQDAAAXrQQIAAAAAAgAAAAEAwAAQgQaCQAAAAAIAAAABAMAAEjOGwkAAAAAGAAAAAEGAACwAAAAwAAAANAAAADgAAAA8AAAAAABAAAIAAAAAAQAAEHGASI0U3I3GAAAAAECAAABAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAIAAAABAMAAAQAAAAAAAAABAAAAAMDAAD1AQAACAAAAAEJAABmaWxlOi8vLwwAAAABAQAATWFjaW50b3NoIEhECAAAAAQDAAAAUKEbcwAAAAgAAAAABAAAQcX1BKwAAAAkAAAAAQEAAEQ1MzU3NEMxLUE3REItNEY2Qy1CMzVGLTNFMjNCMjJDMTBFOBgAAAABAgAAgQAAAAEAAADvEwAAAQAAAAAAAAAAAAAAAQAAAAEBAAAvAAAAAAAAAAEFAAALAQAAAQIAAGQxNmI2NzkxNzdhMTk2ZTk4MDZmMjgxNWY0NmQyNDkxMDk0Mjc5N2E1NzFmZmIyMDEwYTU3YjBiYjEwMTAxNTc7MDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDAwMDAwMDAyMDtjb20uYXBwbGUuYXBwLXNhbmRib3gucmVhZC13cml0ZTswMTswMTAwMDAxMDswMDAwMDAwMDA5MWJjZTQ4OzU1Oy91c2Vycy9vc2Nhci9kZXNrdG9wL21zY2kvZXh0ZXJuYWwvcG9zc2libGUgd29ybGRzIGFuZCByZXNvdXJjZXMtIHRoZSBzZW1hbnRpY3Mgb2YgYmkucGRmAADMAAAA/v///wEAAAAAAAAAEAAAAAQQAACQAAAAAAAAAAUQAAAQAQAAAAAAABAQAABAAQAAAAAAAEAQAAAwAQAAAAAAAAIgAAAMAgAAAAAAAAUgAAB8AQAAAAAAABAgAACMAQAAAAAAABEgAADAAQAAAAAAABIgAACgAQAAAAAAABMgAACwAQAAAAAAACAgAADsAQAAAAAAADAgAAAYAgAAAAAAAAHAAABgAQAAAAAAABHAAAAUAAAAAAAAABLAAABwAQAAAAAAAIDwAAAgAgAAAAAAAAAIAA0AGgAjAHsAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAEtw==},
	bdsk-url-1 = {https://www.sciencedirect.com/science/article/pii/S0304397503006248},
	bdsk-url-2 = {https://doi.org/10.1016/j.tcs.2003.11.020}}

@article{higherorderseplogic,
	abstract = {We show how tools from categorical logic can be used to give a general account of models of higher-order separation logic with a sublogic of so-called persistent predicates satisfying the usual rules of higher-order logic. The models of separation logic are based on a notion of resource, a partial commutative monoid, and the persistent predicates can be defined using a modality. We classify well-behaved sublogics of persistent predicates in terms of interior operators on the partial commutative monoid of resources. We further show how the general constructions can be used to recover the model of Iris, a state-of-the-art higher-order separation logic with guarded recursive predicates.},
	author = {Ale{\v s} Bizjak and Lars Birkedal},
	date-added = {2024-05-28 18:44:24 +0100},
	date-modified = {2024-05-28 18:44:31 +0100},
	doi = {https://doi.org/10.1016/j.entcs.2018.03.016},
	issn = {1571-0661},
	journal = {Electronic Notes in Theoretical Computer Science},
	keywords = {separation logic, model, modalities},
	note = {The Thirty-third Conference on the Mathematical Foundations of Programming Semantics (MFPS XXXIII)},
	pages = {57-78},
	title = {{On Models of Higher-Order Separation Logic}},
	url = {https://www.sciencedirect.com/science/article/pii/S1571066118300197},
	volume = {336},
	year = {2018},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEE0uLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvT24gbW9kZWxzIG9mIGhpZ2hlci1vcmRlciBzZXBhcmF0aW9uIGxvZ2ljLnBkZk8RBGRib29rZAQAAAAABBAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABUAwAABQAAAAEBAABVc2VycwAAAAUAAAABAQAAb3NjYXIAAAAHAAAAAQEAAERlc2t0b3AABAAAAAEBAABtc2NpCAAAAAEBAABleHRlcm5hbC4AAAABAQAAT24gbW9kZWxzIG9mIGhpZ2hlci1vcmRlciBzZXBhcmF0aW9uIGxvZ2ljLnBkZgAAGAAAAAEGAAAEAAAAFAAAACQAAAA0AAAAQAAAAFAAAAAIAAAABAMAAJ5YAAAAAAAACAAAAAQDAADzmgMAAAAAAAgAAAAEAwAA+JoDAAAAAAAIAAAABAMAABetBAgAAAAACAAAAAQDAABCBBoJAAAAAAgAAAAEAwAAuwkdCQAAAAAYAAAAAQYAAKgAAAC4AAAAyAAAANgAAADoAAAA+AAAAAgAAAAABAAAQcYBVa2n9k4YAAAAAQIAAAEAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAgAAAAEAwAABAAAAAAAAAAEAAAAAwMAAPUBAAAIAAAAAQkAAGZpbGU6Ly8vDAAAAAEBAABNYWNpbnRvc2ggSEQIAAAABAMAAABQoRtzAAAACAAAAAAEAABBxfUErAAAACQAAAABAQAARDUzNTc0QzEtQTdEQi00RjZDLUIzNUYtM0UyM0IyMkMxMEU4GAAAAAECAACBAAAAAQAAAO8TAAABAAAAAAAAAAAAAAABAAAAAQEAAC8AAAAAAAAAAQUAABoAAAABAQAATlNVUkxEb2N1bWVudElkZW50aWZpZXJLZXkAAAQAAAADAwAAPwMAAAMBAAABAgAANjJkNTllZTNjNTUxOTFlNDhlOTI3MzY2ZGM4ZWJlOTNlMzhjZmYwOWJhZDk5N2M3NTAzNzJkOWM5NzYxNzBjZDswMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDAwMDAwMDIwO2NvbS5hcHBsZS5hcHAtc2FuZGJveC5yZWFkLXdyaXRlOzAxOzAxMDAwMDEwOzAwMDAwMDAwMDkxZDA5YmI7NTU7L3VzZXJzL29zY2FyL2Rlc2t0b3AvbXNjaS9leHRlcm5hbC9vbiBtb2RlbHMgb2YgaGlnaGVyLW9yZGVyIHNlcGFyYXRpb24gbG9naWMucGRmAADYAAAA/v///wEAAAAAAAAAEQAAAAQQAACIAAAAAAAAAAUQAAAIAQAAAAAAABAQAAA4AQAAAAAAAEAQAAAoAQAAAAAAAAIgAAAEAgAAAAAAAAUgAAB0AQAAAAAAABAgAACEAQAAAAAAABEgAAC4AQAAAAAAABIgAACYAQAAAAAAABMgAACoAQAAAAAAACAgAADkAQAAAAAAADAgAAAQAgAAAAAAAAHAAABYAQAAAAAAABHAAAAUAAAAAAAAABLAAABoAQAAAAAAAIDwAABIAgAAAAAAABgCAIA8AgAAAAAAAAAIAA0AGgAjAHMAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAE2w==},
	bdsk-url-1 = {https://www.sciencedirect.com/science/article/pii/S1571066118300197},
	bdsk-url-2 = {https://doi.org/10.1016/j.entcs.2018.03.016}}

@phdthesis{localreasoningstateful,
	abstract = {Programs are called stateful when they manipulate the state of a computer explicitly, for example, by assignment. The main theme of the thesis is reasoning about stateful programs. In fact, for the past 30 years, significant efforts have been made for obtaining good reasoning principles to ensure that such programs work correctly. However, reasoning techniques developed so far often result in significantly more complex verification than an informal argument; consequently, they don't attract attention from real programmers. In the thesis, we develop O'Hearn's idea of local reasoning, which was recently proposed to overcome such complexity problem in reasoning. The key observation of local reasoning is that most programs show conceptual locality in their use of the store: even though a program is able to access all global variables and all heap data structures in principle, it usually uses only a few of them. Local reasoning uses such an observation to simplify verification: one starts reasoning about a program considering only the accessed portion of the store so as to obtain a ``local'' fact; then, a ``global'' fact is inferred simply by conjoining as an invariant a property that only involves the portion of the store not accessed by the program. In the thesis, we formulate a rule which allows one to derive a global property from a local one. The rule is an extension of O'Hearn's Frame Rule for programs with procedures. It uses a symmetric noninterference predicate and a spatial conjunction to ensure that a program phrase doesn't alter the portion of the store that a conjoined property depends on. We show completeness of the rule, which provides a sense that all properties can be inferred with the rule. We also study reasoning principles for the symmetric noninterference predicate and the spatial conjunction connective; reasoning about certain uses of the spatial conjunction connective is shown to be automated. The benefit of the formalism is illustrated with the verification of the Schorr-Waite graph marking algorithm.},
	address = {USA},
	advisor = {Reddy, Uday S.},
	author = {Yang, Hongseok},
	date-added = {2024-05-28 18:42:56 +0100},
	date-modified = {2024-05-28 18:43:14 +0100},
	isbn = {049335008X},
	note = {AAI3023240},
	publisher = {University of Illinois at Urbana-Champaign},
	title = {{Local reasoning for stateful programs}},
	year = {2001},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEEguLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvTG9jYWwgUmVhc29uaW5nIGZvciBTdGF0ZWZ1bCBQcm9ncmFtcy5wZGZPEQQgYm9vayAEAAAAAAQQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAMAAAUAAAABAQAAVXNlcnMAAAAFAAAAAQEAAG9zY2FyAAAABwAAAAEBAABEZXNrdG9wAAQAAAABAQAAbXNjaQgAAAABAQAAZXh0ZXJuYWwpAAAAAQEAAExvY2FsIFJlYXNvbmluZyBmb3IgU3RhdGVmdWwgUHJvZ3JhbXMucGRmAAAAGAAAAAEGAAAEAAAAFAAAACQAAAA0AAAAQAAAAFAAAAAIAAAABAMAAJ5YAAAAAAAACAAAAAQDAADzmgMAAAAAAAgAAAAEAwAA+JoDAAAAAAAIAAAABAMAABetBAgAAAAACAAAAAQDAABCBBoJAAAAAAgAAAAEAwAAdZsWCQAAAAAYAAAAAQYAAKQAAAC0AAAAxAAAANQAAADkAAAA9AAAAAgAAAAABAAAQcX/tJ+/AiIYAAAAAQIAAAEAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAgAAAAEAwAABAAAAAAAAAAEAAAAAwMAAPUBAAAIAAAAAQkAAGZpbGU6Ly8vDAAAAAEBAABNYWNpbnRvc2ggSEQIAAAABAMAAABQoRtzAAAACAAAAAAEAABBxfUErAAAACQAAAABAQAARDUzNTc0QzEtQTdEQi00RjZDLUIzNUYtM0UyM0IyMkMxMEU4GAAAAAECAACBAAAAAQAAAO8TAAABAAAAAAAAAAAAAAABAAAAAQEAAC8AAAAAAAAAAQUAAP4AAAABAgAAZGE0NTYwNDk2NzgzZTA5MWM5MmQxOTQ1OGJkYjI0YzA4NWViZjU1ZDIwNGQ0MTE5Yzk3NzEzZjdiZmJkZjE4NTswMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDAwMDAwMDIwO2NvbS5hcHBsZS5hcHAtc2FuZGJveC5yZWFkLXdyaXRlOzAxOzAxMDAwMDEwOzAwMDAwMDAwMDkxNjliNzU7NTU7L3VzZXJzL29zY2FyL2Rlc2t0b3AvbXNjaS9leHRlcm5hbC9sb2NhbCByZWFzb25pbmcgZm9yIHN0YXRlZnVsIHByb2dyYW1zLnBkZgAAAMwAAAD+////AQAAAAAAAAAQAAAABBAAAIQAAAAAAAAABRAAAAQBAAAAAAAAEBAAADQBAAAAAAAAQBAAACQBAAAAAAAAAiAAAAACAAAAAAAABSAAAHABAAAAAAAAECAAAIABAAAAAAAAESAAALQBAAAAAAAAEiAAAJQBAAAAAAAAEyAAAKQBAAAAAAAAICAAAOABAAAAAAAAMCAAAAwCAAAAAAAAAcAAAFQBAAAAAAAAEcAAABQAAAAAAAAAEsAAAGQBAAAAAAAAgPAAABQCAAAAAAAAAAgADQAaACMAbgAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAASS}}

@article{javert2,
	abstract = {We propose a novel, unified approach to the development of compositional symbolic execution tools, bridging the gap between classical symbolic execution and compositional program reasoning based on separation logic. Using this approach, we build JaVerT 2.0, a symbolic analysis tool for JavaScript that follows the language semantics without simplifications. JaVerT 2.0 supports whole-program symbolic testing, verification, and, for the first time, automatic compositional testing based on bi-abduction. The meta-theory underpinning JaVerT 2.0 is developed modularly, streamlining the proofs and informing the implementation. Our explicit treatment of symbolic execution errors allows us to give meaningful feedback to the developer during whole-program symbolic testing and guides the inference of resource of the bi-abductive execution. We evaluate the performance of JaVerT 2.0 on a number of JavaScript data-structure libraries, demonstrating: the scalability of our whole-program symbolic testing; an improvement over the state-of-the-art in JavaScript verification; and the feasibility of automatic compositional testing for JavaScript.},
	address = {New York, NY, USA},
	articleno = {66},
	author = {Fragoso Santos, Jos\'{e} and Maksimovi\'{c}, Petar and Sampaio, Gabriela and Gardner, Philippa},
	date-added = {2024-05-28 18:41:07 +0100},
	date-modified = {2024-05-28 18:41:12 +0100},
	doi = {10.1145/3290379},
	issue_date = {January 2019},
	journal = {Proc. ACM Program. Lang.},
	keywords = {bi-abduction, compositionality, dynamic languages, symbolic execution},
	month = {jan},
	number = {POPL},
	numpages = {31},
	publisher = {Association for Computing Machinery},
	title = {{JaVerT 2.0: compositional symbolic execution for JavaScript}},
	url = {https://doi.org/10.1145/3290379},
	volume = {3},
	year = {2019},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEF4uLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvSmFWZXJUIDIuMC0gQ29tcG9zaXRpb25hbCBTeW1ib2xpYyBFeGVjdXRpb24gZm9yIEphdmFTY3JpcHQucGRmTxEEhGJvb2uEBAAAAAAEEDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQDAAAFAAAAAQEAAFVzZXJzAAAABQAAAAEBAABvc2NhcgAAAAcAAAABAQAARGVza3RvcAAEAAAAAQEAAG1zY2kIAAAAAQEAAGV4dGVybmFsPwAAAAEBAABKYVZlclQgMi4wLSBDb21wb3NpdGlvbmFsIFN5bWJvbGljIEV4ZWN1dGlvbiBmb3IgSmF2YVNjcmlwdC5wZGYAGAAAAAEGAAAEAAAAFAAAACQAAAA0AAAAQAAAAFAAAAAIAAAABAMAAJ5YAAAAAAAACAAAAAQDAADzmgMAAAAAAAgAAAAEAwAA+JoDAAAAAAAIAAAABAMAABetBAgAAAAACAAAAAQDAABCBBoJAAAAAAgAAAAEAwAAlHQrCQAAAAAYAAAAAQYAALgAAADIAAAA2AAAAOgAAAD4AAAACAEAAAgAAAAABAAAQcYCW2b7zdYYAAAAAQIAAAEAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAgAAAAEAwAABAAAAAAAAAAEAAAAAwMAAPUBAAAIAAAAAQkAAGZpbGU6Ly8vDAAAAAEBAABNYWNpbnRvc2ggSEQIAAAABAMAAABQoRtzAAAACAAAAAAEAABBxfUErAAAACQAAAABAQAARDUzNTc0QzEtQTdEQi00RjZDLUIzNUYtM0UyM0IyMkMxMEU4GAAAAAECAACBAAAAAQAAAO8TAAABAAAAAAAAAAAAAAABAAAAAQEAAC8AAAAAAAAAAQUAABoAAAABAQAATlNVUkxEb2N1bWVudElkZW50aWZpZXJLZXkAAAQAAAADAwAAUwMAABQBAAABAgAANWNhOTZhMzVjYjBiMzhiZmNjNDdlNjFhMzQ5NTJmYWI2YzcwZGQ2M2EzMGU0MTdmYWQwMWNmMGY2ZDdkMzE0ZTswMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDAwMDAwMDIwO2NvbS5hcHBsZS5hcHAtc2FuZGJveC5yZWFkLXdyaXRlOzAxOzAxMDAwMDEwOzAwMDAwMDAwMDkyYjc0OTQ7NTU7L3VzZXJzL29zY2FyL2Rlc2t0b3AvbXNjaS9leHRlcm5hbC9qYXZlcnQgMi4wLSBjb21wb3NpdGlvbmFsIHN5bWJvbGljIGV4ZWN1dGlvbiBmb3IgamF2YXNjcmlwdC5wZGYA2AAAAP7///8BAAAAAAAAABEAAAAEEAAAmAAAAAAAAAAFEAAAGAEAAAAAAAAQEAAASAEAAAAAAABAEAAAOAEAAAAAAAACIAAAFAIAAAAAAAAFIAAAhAEAAAAAAAAQIAAAlAEAAAAAAAARIAAAyAEAAAAAAAASIAAAqAEAAAAAAAATIAAAuAEAAAAAAAAgIAAA9AEAAAAAAAAwIAAAIAIAAAAAAAABwAAAaAEAAAAAAAARwAAAFAAAAAAAAAASwAAAeAEAAAAAAACA8AAAWAIAAAAAAAAoAgCATAIAAAAAAAAACAANABoAIwCEAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAABQw=},
	bdsk-url-1 = {https://doi.org/10.1145/3290379}}

@article{surveysymex,
	abstract = {Many security and software testing applications require checking whether certain properties of a program hold for any possible usage scenario. For instance, a tool for identifying software vulnerabilities may need to rule out the existence of any backdoor to bypass a program's authentication. One approach would be to test the program using different, possibly random inputs. As the backdoor may only be hit for very specific program workloads, automated exploration of the space of possible inputs is of the essence. Symbolic execution provides an elegant solution to the problem, by systematically exploring many possible execution paths at the same time without necessarily requiring concrete inputs. Rather than taking on fully specified input values, the technique abstractly represents them as symbols, resorting to constraint solvers to construct actual instances that would cause property violations. Symbolic execution has been incubated in dozens of tools developed over the past four decades, leading to major practical breakthroughs in a number of prominent software reliability applications. The goal of this survey is to provide an overview of the main ideas, challenges, and solutions developed in the area, distilling them for a broad audience.},
	address = {New York, NY, USA},
	articleno = {50},
	author = {Baldoni, Roberto and Coppa, Emilio and D'elia, Daniele Cono and Demetrescu, Camil and Finocchi, Irene},
	date-added = {2024-05-28 18:40:36 +0100},
	date-modified = {2024-05-28 18:40:41 +0100},
	doi = {10.1145/3182657},
	issn = {0360-0300},
	issue_date = {May 2019},
	journal = {ACM Comput. Surv.},
	keywords = {Symbolic execution, concolic execution, software testing, static analysis},
	month = {may},
	number = {3},
	numpages = {39},
	publisher = {Association for Computing Machinery},
	title = {{A Survey of Symbolic Execution Techniques}},
	url = {https://doi.org/10.1145/3182657},
	volume = {51},
	year = {2018},
	bdsk-url-1 = {https://doi.org/10.1145/3182657}}

@article{statesoundness,
	author = {Pottier, Fran\c{c}ois},
	date-added = {2024-05-28 18:40:04 +0100},
	date-modified = {2024-06-02 14:27:01 +0100},
	doi = {10.1017/S0956796812000366},
	journal = {Journal of Functional Programming},
	number = {1},
	pages = {38--144},
	read = {1},
	title = {{Syntactic soundness proof of a type-and-capability system with hidden state}},
	volume = {23},
	year = {2013},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEHAuLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvKiBTeW50YWN0aWMgc291bmRuZXNzIHByb29mIG9mIGEgdHlwZS1hbmQtY2FwYWJpbGl0eSBzeXN0ZW0gd2l0aCBoaWRkZW4gc3RhdGUucGRmTxEErGJvb2usBAAAAAAEEDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJwDAAAFAAAAAQEAAFVzZXJzAAAABQAAAAEBAABvc2NhcgAAAAcAAAABAQAARGVza3RvcAAEAAAAAQEAAG1zY2kIAAAAAQEAAGV4dGVybmFsUQAAAAEBAAAqIFN5bnRhY3RpYyBzb3VuZG5lc3MgcHJvb2Ygb2YgYSB0eXBlLWFuZC1jYXBhYmlsaXR5IHN5c3RlbSB3aXRoIGhpZGRlbiBzdGF0ZS5wZGYAAAAYAAAAAQYAAAQAAAAUAAAAJAAAADQAAABAAAAAUAAAAAgAAAAEAwAAnlgAAAAAAAAIAAAABAMAAPOaAwAAAAAACAAAAAQDAAD4mgMAAAAAAAgAAAAEAwAAF60ECAAAAAAIAAAABAMAAEIEGgkAAAAACAAAAAQDAADGZxsJAAAAABgAAAABBgAAzAAAANwAAADsAAAA/AAAAAwBAAAcAQAACAAAAAAEAABBxgCDJCYM+hgAAAABAgAAAQAAAAAAAAAPAAAAAAAAAAAAAAAAAAAACAAAAAQDAAAEAAAAAAAAAAQAAAADAwAA9QEAAAgAAAABCQAAZmlsZTovLy8MAAAAAQEAAE1hY2ludG9zaCBIRAgAAAAEAwAAAFChG3MAAAAIAAAAAAQAAEHF9QSsAAAAJAAAAAEBAABENTM1NzRDMS1BN0RCLTRGNkMtQjM1Ri0zRTIzQjIyQzEwRTgYAAAAAQIAAIEAAAABAAAA7xMAAAEAAAAAAAAAAAAAAAEAAAABAQAALwAAAAAAAAABBQAAGgAAAAEBAABOU1VSTERvY3VtZW50SWRlbnRpZmllcktleQAABAAAAAMDAAA8AwAAJgEAAAECAAAxNWNmNzk2Y2ZhN2I3NGEyOTVmNGEzMzQxN2UzZGU3ZWRjNmFiOGZhZDY2OWQ1ZTQyMjQ4YjU0MTZhZTUyNTBlOzAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwMDAwMDAwMjA7Y29tLmFwcGxlLmFwcC1zYW5kYm94LnJlYWQtd3JpdGU7MDE7MDEwMDAwMTA7MDAwMDAwMDAwOTFiNjdjNjs1NTsvdXNlcnMvb3NjYXIvZGVza3RvcC9tc2NpL2V4dGVybmFsLyogc3ludGFjdGljIHNvdW5kbmVzcyBwcm9vZiBvZiBhIHR5cGUtYW5kLWNhcGFiaWxpdHkgc3lzdGVtIHdpdGggaGlkZGVuIHN0YXRlLnBkZgAAANgAAAD+////AQAAAAAAAAARAAAABBAAAKwAAAAAAAAABRAAACwBAAAAAAAAEBAAAFwBAAAAAAAAQBAAAEwBAAAAAAAAAiAAACgCAAAAAAAABSAAAJgBAAAAAAAAECAAAKgBAAAAAAAAESAAANwBAAAAAAAAEiAAALwBAAAAAAAAEyAAAMwBAAAAAAAAICAAAAgCAAAAAAAAMCAAADQCAAAAAAAAAcAAAHwBAAAAAAAAEcAAABQAAAAAAAAAEsAAAIwBAAAAAAAAgPAAAGwCAAAAAAAAPAIAgGACAAAAAAAAAAgADQAaACMAlgAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAVG},
	bdsk-url-1 = {https://doi.org/10.1017/S0956796812000366}}

@inproceedings{abstractseplogic,
	author = {Calcagno, Cristiano and O'Hearn, Peter W. and Yang, Hongseok},
	booktitle = {{22nd Annual IEEE Symposium on Logic in Computer Science (LICS 2007)}},
	date-added = {2024-05-28 18:37:22 +0100},
	date-modified = {2024-05-28 18:38:13 +0100},
	doi = {10.1109/LICS.2007.30},
	keywords = {Concurrent computing;Logic functions;Algebra;Logic programming;Random access memory;Read-write memory;Concrete;Educational institutions;Reasoning about programs;Transformer cores},
	pages = {366-378},
	read = {1},
	title = {{Local Action and Abstract Separation Logic}},
	year = {2007},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEE8uLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvKiBMb2NhbCBBY3Rpb24gYW5kIEFic3RyYWN0IFNlcGFyYXRpb24gTG9naWMucGRmTxEEaGJvb2toBAAAAAAEEDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFgDAAAFAAAAAQEAAFVzZXJzAAAABQAAAAEBAABvc2NhcgAAAAcAAAABAQAARGVza3RvcAAEAAAAAQEAAG1zY2kIAAAAAQEAAGV4dGVybmFsMAAAAAEBAAAqIExvY2FsIEFjdGlvbiBhbmQgQWJzdHJhY3QgU2VwYXJhdGlvbiBMb2dpYy5wZGYYAAAAAQYAAAQAAAAUAAAAJAAAADQAAABAAAAAUAAAAAgAAAAEAwAAnlgAAAAAAAAIAAAABAMAAPOaAwAAAAAACAAAAAQDAAD4mgMAAAAAAAgAAAAEAwAAF60ECAAAAAAIAAAABAMAAEIEGgkAAAAACAAAAAQDAADn3xwJAAAAABgAAAABBgAAqAAAALgAAADIAAAA2AAAAOgAAAD4AAAACAAAAAAEAABBxgCajVdtnxgAAAABAgAAAQAAAAAAAAAPAAAAAAAAAAAAAAAAAAAACAAAAAQDAAAEAAAAAAAAAAQAAAADAwAA9QEAAAgAAAABCQAAZmlsZTovLy8MAAAAAQEAAE1hY2ludG9zaCBIRAgAAAAEAwAAAFChG3MAAAAIAAAAAAQAAEHF9QSsAAAAJAAAAAEBAABENTM1NzRDMS1BN0RCLTRGNkMtQjM1Ri0zRTIzQjIyQzEwRTgYAAAAAQIAAIEAAAABAAAA7xMAAAEAAAAAAAAAAAAAAAEAAAABAQAALwAAAAAAAAABBQAAGgAAAAEBAABOU1VSTERvY3VtZW50SWRlbnRpZmllcktleQAABAAAAAMDAAA9AwAABQEAAAECAAAzOTY1OGI2YjQ5YmFmM2U5MTM1OGZkM2NlZTJhOThiODNjYjE3NjdlODdkYWFhZmMzMWI1YTJkNDA1Y2FlYTBkOzAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwMDAwMDAwMjA7Y29tLmFwcGxlLmFwcC1zYW5kYm94LnJlYWQtd3JpdGU7MDE7MDEwMDAwMTA7MDAwMDAwMDAwOTFjZGZlNzs1NTsvdXNlcnMvb3NjYXIvZGVza3RvcC9tc2NpL2V4dGVybmFsLyogbG9jYWwgYWN0aW9uIGFuZCBhYnN0cmFjdCBzZXBhcmF0aW9uIGxvZ2ljLnBkZgAAAADYAAAA/v///wEAAAAAAAAAEQAAAAQQAACIAAAAAAAAAAUQAAAIAQAAAAAAABAQAAA4AQAAAAAAAEAQAAAoAQAAAAAAAAIgAAAEAgAAAAAAAAUgAAB0AQAAAAAAABAgAACEAQAAAAAAABEgAAC4AQAAAAAAABIgAACYAQAAAAAAABMgAACoAQAAAAAAACAgAADkAQAAAAAAADAgAAAQAgAAAAAAAAHAAABYAQAAAAAAABHAAAAUAAAAAAAAABLAAABoAQAAAAAAAIDwAABIAgAAAAAAABgCAIA8AgAAAAAAAAAIAA0AGgAjAHUAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAE4Q==},
	bdsk-url-1 = {https://doi.org/10.1109/LICS.2007.30}}

@article{iris,
	author = {Jung, Ralf and Krebbers, Robbert and Jourdan, Jacques-Henri and Bizjak, Ale{\v s} and Birkedal, Lars and Dreyer, Derek},
	date-added = {2024-05-28 18:36:41 +0100},
	date-modified = {2024-06-02 17:57:01 +0100},
	doi = {10.1017/S0956796818000151},
	journal = {Journal of Functional Programming},
	pages = {e20},
	read = {1},
	title = {{Iris from the ground up: A modular foundation for higher-order concurrent separation logic}},
	volume = {28},
	year = {2018},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEDwuLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvKiBJcmlzIGZyb20gdGhlIGdyb3VuZCB1cC5wZGZPEQREYm9va0QEAAAAAAQQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAMAAAUAAAABAQAAVXNlcnMAAAAFAAAAAQEAAG9zY2FyAAAABwAAAAEBAABEZXNrdG9wAAQAAAABAQAAbXNjaQgAAAABAQAAZXh0ZXJuYWwdAAAAAQEAACogSXJpcyBmcm9tIHRoZSBncm91bmQgdXAucGRmAAAAGAAAAAEGAAAEAAAAFAAAACQAAAA0AAAAQAAAAFAAAAAIAAAABAMAAJ5YAAAAAAAACAAAAAQDAADzmgMAAAAAAAgAAAAEAwAA+JoDAAAAAAAIAAAABAMAABetBAgAAAAACAAAAAQDAABCBBoJAAAAAAgAAAAEAwAArpg2CQAAAAAYAAAAAQYAAJgAAACoAAAAuAAAAMgAAADYAAAA6AAAAAgAAAAABAAAQcXxalKslcgYAAAAAQIAAAEAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAgAAAAEAwAABAAAAAAAAAAEAAAAAwMAAPUBAAAIAAAAAQkAAGZpbGU6Ly8vDAAAAAEBAABNYWNpbnRvc2ggSEQIAAAABAMAAABQoRtzAAAACAAAAAAEAABBxfUErAAAACQAAAABAQAARDUzNTc0QzEtQTdEQi00RjZDLUIzNUYtM0UyM0IyMkMxMEU4GAAAAAECAACBAAAAAQAAAO8TAAABAAAAAAAAAAAAAAABAAAAAQEAAC8AAAAAAAAAAQUAABoAAAABAQAATlNVUkxEb2N1bWVudElkZW50aWZpZXJLZXkAAAQAAAADAwAAGAMAAPIAAAABAgAAMmU5MTY1MmM3YTlkZDYwOWVjNWZlYTE2NWMzMDdiMzkyOTFhMjlkOWM5M2VhODJmOTYyZDgzNDNmYzA2YzQ3ODswMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDAwMDAwMDIwO2NvbS5hcHBsZS5hcHAtc2FuZGJveC5yZWFkLXdyaXRlOzAxOzAxMDAwMDEwOzAwMDAwMDAwMDkzNjk4YWU7NTU7L3VzZXJzL29zY2FyL2Rlc2t0b3AvbXNjaS9leHRlcm5hbC8qIGlyaXMgZnJvbSB0aGUgZ3JvdW5kIHVwLnBkZgAAANgAAAD+////AQAAAAAAAAARAAAABBAAAHgAAAAAAAAABRAAAPgAAAAAAAAAEBAAACgBAAAAAAAAQBAAABgBAAAAAAAAAiAAAPQBAAAAAAAABSAAAGQBAAAAAAAAECAAAHQBAAAAAAAAESAAAKgBAAAAAAAAEiAAAIgBAAAAAAAAEyAAAJgBAAAAAAAAICAAANQBAAAAAAAAMCAAAAACAAAAAAAAAcAAAEgBAAAAAAAAEcAAABQAAAAAAAAAEsAAAFgBAAAAAAAAgPAAADgCAAAAAAAACAIAgCwCAAAAAAAAAAgADQAaACMAYgAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAASq},
	bdsk-url-1 = {https://doi.org/10.1017/S0956796818000151}}

@article{fracpermissions,
	author = {Bornat, Richard and Calcagno, Cristiano and Hearn, Peter and Yang, Hongseok},
	date-added = {2024-05-28 18:34:58 +0100},
	date-modified = {2024-05-28 18:38:51 +0100},
	read = {1},
	title = {{Fractional and counting permissions in separation logic}},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEFwuLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvKiBGcmFjdGlvbmFsIGFuZCBjb3VudGluZyBwZXJtaXNzaW9ucyBpbiBzZXBhcmF0aW9uIGxvZ2ljLnBkZk8RBEhib29rSAQAAAAABBAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEAwAABQAAAAEBAABVc2VycwAAAAUAAAABAQAAb3NjYXIAAAAHAAAAAQEAAERlc2t0b3AABAAAAAEBAABtc2NpCAAAAAEBAABleHRlcm5hbD0AAAABAQAAKiBGcmFjdGlvbmFsIGFuZCBjb3VudGluZyBwZXJtaXNzaW9ucyBpbiBzZXBhcmF0aW9uIGxvZ2ljLnBkZgAAABgAAAABBgAABAAAABQAAAAkAAAANAAAAEAAAABQAAAACAAAAAQDAACeWAAAAAAAAAgAAAAEAwAA85oDAAAAAAAIAAAABAMAAPiaAwAAAAAACAAAAAQDAAAXrQQIAAAAAAgAAAAEAwAAQgQaCQAAAAAIAAAABAMAAJqyBQgAAAAAGAAAAAEGAAC4AAAAyAAAANgAAADoAAAA+AAAAAgBAAAIAAAAAAQAAEHF33WwjjLtGAAAAAECAAABAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAIAAAABAMAAAQAAAAAAAAABAAAAAMDAAD1AQAACAAAAAEJAABmaWxlOi8vLwwAAAABAQAATWFjaW50b3NoIEhECAAAAAQDAAAAUKEbcwAAAAgAAAAABAAAQcX1BKwAAAAkAAAAAQEAAEQ1MzU3NEMxLUE3REItNEY2Qy1CMzVGLTNFMjNCMjJDMTBFOBgAAAABAgAAgQAAAAEAAADvEwAAAQAAAAAAAAAAAAAAAQAAAAEBAAAvAAAAAAAAAAEFAAASAQAAAQIAAGJhNGMzNzMxYTEzNDMzMDkzNzY1OGFkOTQzZWNmNDJmOWQyMmE4MDYwMzY4MmJmNTBiYjlkNTNlMTUzMWVhMWM7MDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDAwMDAwMDAyMDtjb20uYXBwbGUuYXBwLXNhbmRib3gucmVhZC13cml0ZTswMTswMTAwMDAxMDswMDAwMDAwMDA4MDViMjlhOzU1Oy91c2Vycy9vc2Nhci9kZXNrdG9wL21zY2kvZXh0ZXJuYWwvKiBmcmFjdGlvbmFsIGFuZCBjb3VudGluZyBwZXJtaXNzaW9ucyBpbiBzZXBhcmF0aW9uIGxvZ2ljLnBkZgAAAMwAAAD+////AQAAAAAAAAAQAAAABBAAAJgAAAAAAAAABRAAABgBAAAAAAAAEBAAAEgBAAAAAAAAQBAAADgBAAAAAAAAAiAAABQCAAAAAAAABSAAAIQBAAAAAAAAECAAAJQBAAAAAAAAESAAAMgBAAAAAAAAEiAAAKgBAAAAAAAAEyAAALgBAAAAAAAAICAAAPQBAAAAAAAAMCAAACACAAAAAAAAAcAAAGgBAAAAAAAAEcAAABQAAAAAAAAAEsAAAHgBAAAAAAAAgPAAACgCAAAAAAAAAAgADQAaACMAggAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAATO}}

@inproceedings{sepalgebra,
	abstract = {Separation Algebras serve as models of Separation Logics; Share Accounting allows reasoning about concurrent-read/exclusive- write resources in Separation Logic. In designing a Concurrent Separation Logic and in mechanizing proofs of its soundness, we found previous axiomatizations of separation algebras and previous systems of share accounting to be useful but imperfect. We adjust the axioms of separation algebras; we demonstrate an operator calculus for constructing new separation algebras; we present a more powerful system of share accounting with a new, simple model; and we provide a reusable Coq development.},
	address = {Berlin, Heidelberg},
	author = {Dockins, Robert and Hobor, Aquinas and Appel, Andrew W.},
	booktitle = {{Programming Languages and Systems}},
	date-added = {2024-05-28 18:31:25 +0100},
	date-modified = {2024-05-28 18:38:37 +0100},
	editor = {Hu, Zhenjiang},
	isbn = {978-3-642-10672-9},
	pages = {161--177},
	publisher = {Springer Berlin Heidelberg},
	read = {1},
	title = {{A Fresh Look at Separation Algebras and Share Accounting}},
	year = {2009},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEF0uLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvKiBBIGZyZXNoIGxvb2sgYXQgc2VwYXJhdGlvbiBhbGdlYnJhcyBhbmQgc2hhcmUgYWNjb3VudGluZy5wZGZPEQSEYm9va4QEAAAAAAQQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdAMAAAUAAAABAQAAVXNlcnMAAAAFAAAAAQEAAG9zY2FyAAAABwAAAAEBAABEZXNrdG9wAAQAAAABAQAAbXNjaQgAAAABAQAAZXh0ZXJuYWw+AAAAAQEAACogQSBmcmVzaCBsb29rIGF0IHNlcGFyYXRpb24gYWxnZWJyYXMgYW5kIHNoYXJlIGFjY291bnRpbmcucGRmAAAYAAAAAQYAAAQAAAAUAAAAJAAAADQAAABAAAAAUAAAAAgAAAAEAwAAnlgAAAAAAAAIAAAABAMAAPOaAwAAAAAACAAAAAQDAAD4mgMAAAAAAAgAAAAEAwAAF60ECAAAAAAIAAAABAMAAEIEGgkAAAAACAAAAAQDAADoBhoJAAAAABgAAAABBgAAuAAAAMgAAADYAAAA6AAAAPgAAAAIAQAACAAAAAAEAABBxf/r3nD1FRgAAAABAgAAAQAAAAAAAAAPAAAAAAAAAAAAAAAAAAAACAAAAAQDAAAEAAAAAAAAAAQAAAADAwAA9QEAAAgAAAABCQAAZmlsZTovLy8MAAAAAQEAAE1hY2ludG9zaCBIRAgAAAAEAwAAAFChG3MAAAAIAAAAAAQAAEHF9QSsAAAAJAAAAAEBAABENTM1NzRDMS1BN0RCLTRGNkMtQjM1Ri0zRTIzQjIyQzEwRTgYAAAAAQIAAIEAAAABAAAA7xMAAAEAAAAAAAAAAAAAAAEAAAABAQAALwAAAAAAAAABBQAAGgAAAAEBAABOU1VSTERvY3VtZW50SWRlbnRpZmllcktleQAABAAAAAMDAAA7AwAAEwEAAAECAAAzOGM4YmEwYjhmMzE5OGVhNjIzODhjNjBkNTI5ZTJkMDI1NjkzYmViN2MwNzk3NWM0ZTczOGRkOTgyNTRkM2UwOzAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwOzAwMDAwMDAwMDAwMDAwMjA7Y29tLmFwcGxlLmFwcC1zYW5kYm94LnJlYWQtd3JpdGU7MDE7MDEwMDAwMTA7MDAwMDAwMDAwOTFhMDZlODs1NTsvdXNlcnMvb3NjYXIvZGVza3RvcC9tc2NpL2V4dGVybmFsLyogYSBmcmVzaCBsb29rIGF0IHNlcGFyYXRpb24gYWxnZWJyYXMgYW5kIHNoYXJlIGFjY291bnRpbmcucGRmAADYAAAA/v///wEAAAAAAAAAEQAAAAQQAACYAAAAAAAAAAUQAAAYAQAAAAAAABAQAABIAQAAAAAAAEAQAAA4AQAAAAAAAAIgAAAUAgAAAAAAAAUgAACEAQAAAAAAABAgAACUAQAAAAAAABEgAADIAQAAAAAAABIgAACoAQAAAAAAABMgAAC4AQAAAAAAACAgAAD0AQAAAAAAADAgAAAgAgAAAAAAAAHAAABoAQAAAAAAABHAAAAUAAAAAAAAABLAAAB4AQAAAAAAAIDwAABYAgAAAAAAACgCAIBMAgAAAAAAAAAIAA0AGgAjAIMAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAFCw==}}

@inproceedings{smartfuzzing,
	author = {Bekrar, Sofia and Bekrar, Chaouki and Groz, Roland and Mounier, Laurent},
	booktitle = {{2011 Fourth IEEE International Conference on Software Testing, Verification and Validation}},
	doi = {10.1109/ICST.2011.48},
	keywords = {Security;Testing;Software;Assembly;Instruments;Monitoring;Algorithm design and analysis;fuzzing;testing;software vulnerabilities},
	pages = {427-430},
	title = {{Finding Software Vulnerabilities by Smart Fuzzing}},
	year = {2011},
	bdsk-url-1 = {https://doi.org/10.1109/ICST.2011.48}}

@article{compositionalsymtesting,
	address = {New York, NY, USA},
	author = {Godefroid, Patrice},
	doi = {10.1145/1190215.1190226},
	issn = {0362-1340},
	issue_date = {January 2007},
	journal = {SIGPLAN Not.},
	month = {jan},
	number = {1},
	numpages = {8},
	pages = {47--54},
	publisher = {Association for Computing Machinery},
	title = {{Compositional dynamic test generation}},
	volume = {42},
	year = {2007},
	bdsk-url-1 = {https://doi.org/10.1145/1190215.1190226}}

@inproceedings{seplogic1,
	address = {Berlin, Heidelberg},
	author = {O'Hearn, Peter and Reynolds, John and Yang, Hongseok},
	booktitle = {{Computer Science Logic}},
	editor = {Fribourg, Laurent},
	isbn = {978-3-540-44802-0},
	pages = {1--19},
	publisher = {Springer Berlin Heidelberg},
	title = {{Local Reasoning about Programs that Alter Data Structures}},
	year = {2001}}

@inproceedings{seplogic2,
	author = {Reynolds, J.C.},
	booktitle = {{Proceedings 17th Annual IEEE Symposium on Logic in Computer Science}},
	date-modified = {2024-05-28 18:31:00 +0100},
	doi = {10.1109/LICS.2002.1029817},
	pages = {55-74},
	read = {1},
	title = {{Separation logic: a logic for shared mutable data structures}},
	year = {2002},
	bdsk-url-1 = {https://doi.org/10.1109/LICS.2002.1029817}}

@article{hoarelogic,
	address = {New York, NY, USA},
	author = {Hoare, C. A. R.},
	date-modified = {2024-05-28 18:29:27 +0100},
	doi = {10.1145/363235.363259},
	issn = {0001-0782},
	issue_date = {Oct. 1969},
	journal = {Commun. ACM},
	month = {oct},
	number = {10},
	numpages = {5},
	pages = {576--580},
	publisher = {Association for Computing Machinery},
	read = {0},
	title = {{An axiomatic basis for computer programming}},
	url = {https://doi.org/10.1145/363235.363259},
	volume = {12},
	year = {1969},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEDwuLi8uLi8uLi9Eb3dubG9hZHMvMTAuMTAwN185NzgtMy0zMTktNzEyMzctNl8xMC1jaXRhdGlvbi5iaWJPEQPMYm9va8wDAAAAAAQQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAIAAAUAAAABAQAAVXNlcnMAAAAFAAAAAQEAAG9zY2FyAAAACQAAAAEBAABEb3dubG9hZHMAAAApAAAAAQEAADEwLjEwMDdfOTc4LTMtMzE5LTcxMjM3LTZfMTAtY2l0YXRpb24uYmliAAAAEAAAAAEGAAAEAAAAFAAAACQAAAA4AAAACAAAAAQDAACeWAAAAAAAAAgAAAAEAwAA85oDAAAAAAAIAAAABAMAACabAwAAAAAACAAAAAQDAABnRaUKAAAAABAAAAABBgAAhAAAAJQAAACkAAAAtAAAAAgAAAAABAAAQcYzTG5M39sYAAAAAQIAAAEAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAgAAAAEAwAAAgAAAAAAAAAEAAAAAwMAAPUBAAAIAAAAAQkAAGZpbGU6Ly8vDAAAAAEBAABNYWNpbnRvc2ggSEQIAAAABAMAAABQoRtzAAAACAAAAAAEAABBxfUErAAAACQAAAABAQAARDUzNTc0QzEtQTdEQi00RjZDLUIzNUYtM0UyM0IyMkMxMEU4GAAAAAECAACBAAAAAQAAAO8TAAABAAAAAAAAAAAAAAABAAAAAQEAAC8AAAAAAAAAAQUAAPIAAAABAgAAZjQ4MDBjODIzMzVmZDQzM2RmODFmMTU5ZTMyZDEwYWE4MDA2ZjQxMmM1YWY2NzllZDYyYThmZjNjMDQ3ZTU4YjswMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDswMDAwMDAwMDAwMDAwMDIwO2NvbS5hcHBsZS5hcHAtc2FuZGJveC5yZWFkLXdyaXRlOzAxOzAxMDAwMDEwOzAwMDAwMDAwMGFhNTQ1Njc7NWM7L3VzZXJzL29zY2FyL2Rvd25sb2Fkcy8xMC4xMDA3Xzk3OC0zLTMxOS03MTIzNy02XzEwLWNpdGF0aW9uLmJpYgAAAMwAAAD+////AQAAAAAAAAAQAAAABBAAAGwAAAAAAAAABRAAAMQAAAAAAAAAEBAAAOwAAAAAAAAAQBAAANwAAAAAAAAAAiAAALgBAAAAAAAABSAAACgBAAAAAAAAECAAADgBAAAAAAAAESAAAGwBAAAAAAAAEiAAAEwBAAAAAAAAEyAAAFwBAAAAAAAAICAAAJgBAAAAAAAAMCAAAMQBAAAAAAAAAcAAAAwBAAAAAAAAEcAAABQAAAAAAAAAEsAAABwBAAAAAAAAgPAAAMwBAAAAAAAAAAgADQAaACMAYgAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAQy},
	bdsk-url-1 = {https://doi.org/10.1145/363235.363259}}

@inproceedings{isl,
	address = {Cham},
	author = {Raad, Azalea and Berdine, Josh and Dang, Hoang-Hai and Dreyer, Derek and O'Hearn, Peter and Villard, Jules},
	booktitle = {{Computer Aided Verification}},
	date-modified = {2024-05-28 18:30:29 +0100},
	editor = {Lahiri, Shuvendu K. and Wang, Chao},
	isbn = {978-3-030-53291-8},
	pages = {225--252},
	publisher = {Springer International Publishing},
	read = {1},
	title = {{Local Reasoning About the Presence of Bugs: Incorrectness Separation Logic}},
	year = {2020}}

@article{incorrectnesslogic,
	address = {New York, NY, USA},
	articleno = {10},
	author = {O'Hearn, Peter W.},
	date-modified = {2024-05-30 15:25:13 +0100},
	doi = {10.1145/3371078},
	issue_date = {January 2020},
	journal = {Proc. ACM Program. Lang.},
	month = {dec},
	number = {POPL},
	numpages = {32},
	publisher = {Association for Computing Machinery},
	read = {1},
	title = {{Incorrectness logic}},
	url = {https://doi.org/10.1145/3371078},
	volume = {4},
	year = {2019},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhYYm9va21hcmtfEDYuLi8uLi8uLi9EZXNrdG9wL21zY2kvZXh0ZXJuYWwvSW5jb3JyZWN0bmVzcyBMb2dpYy5wZGZPEQP4Ym9va/gDAAAAAAQQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9AIAAAUAAAABAQAAVXNlcnMAAAAFAAAAAQEAAG9zY2FyAAAABwAAAAEBAABEZXNrdG9wAAQAAAABAQAAbXNjaQgAAAABAQAAZXh0ZXJuYWwXAAAAAQEAAEluY29ycmVjdG5lc3MgTG9naWMucGRmABgAAAABBgAABAAAABQAAAAkAAAANAAAAEAAAABQAAAACAAAAAQDAACeWAAAAAAAAAgAAAAEAwAA85oDAAAAAAAIAAAABAMAAPiaAwAAAAAACAAAAAQDAAAXrQQIAAAAAAgAAAAEAwAAQgQaCQAAAAAIAAAABAMAAMXgJAkAAAAAGAAAAAEGAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAAAIAAAAAAQAAEHGAwfTJUucGAAAAAECAAABAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAIAAAABAMAAAQAAAAAAAAABAAAAAMDAAD1AQAACAAAAAEJAABmaWxlOi8vLwwAAAABAQAATWFjaW50b3NoIEhECAAAAAQDAAAAUKEbcwAAAAgAAAAABAAAQcX1BKwAAAAkAAAAAQEAAEQ1MzU3NEMxLUE3REItNEY2Qy1CMzVGLTNFMjNCMjJDMTBFOBgAAAABAgAAgQAAAAEAAADvEwAAAQAAAAAAAAAAAAAAAQAAAAEBAAAvAAAAAAAAAAEFAADsAAAAAQIAADgyMWJjMGQxNzM4YjVhNzE5NDI1MTdmNzQzNTQxNDMyODU3NTNkZWViZjMxYjc4MGNjODg4MmQ0NDk0M2RhNmI7MDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDA7MDAwMDAwMDAwMDAwMDAyMDtjb20uYXBwbGUuYXBwLXNhbmRib3gucmVhZC13cml0ZTswMTswMTAwMDAxMDswMDAwMDAwMDA5MjRlMGM1OzU1Oy91c2Vycy9vc2Nhci9kZXNrdG9wL21zY2kvZXh0ZXJuYWwvaW5jb3JyZWN0bmVzcyBsb2dpYy5wZGYAzAAAAP7///8BAAAAAAAAABAAAAAEEAAAcAAAAAAAAAAFEAAA8AAAAAAAAAAQEAAAIAEAAAAAAABAEAAAEAEAAAAAAAACIAAA7AEAAAAAAAAFIAAAXAEAAAAAAAAQIAAAbAEAAAAAAAARIAAAoAEAAAAAAAASIAAAgAEAAAAAAAATIAAAkAEAAAAAAAAgIAAAzAEAAAAAAAAwIAAA+AEAAAAAAAABwAAAQAEAAAAAAAARwAAAFAAAAAAAAAASwAAAUAEAAAAAAACA8AAAAAIAAAAAAAAACAANABoAIwBcAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAABFg=},
	bdsk-url-1 = {https://doi.org/10.1145/3371078}}

@comment{BibDesk Static Groups{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>group name</key>
		<string>gillian</string>
		<key>keys</key>
		<string>gillianrust,gillian0,gillian1,gillian2,javert2,javert1,cse1,sacha-phd</string>
	</dict>
	<dict>
		<key>group name</key>
		<string>semantics</string>
		<key>keys</key>
		<string>semantics123</string>
	</dict>
	<dict>
		<key>group name</key>
		<string>statemodels</string>
		<key>keys</key>
		<string>sepalgebra,fracpermissions,abstractseplogic,higherorderseplogic,fracpermissions2,statesoundness,monotonicstate,next700seplogics,iris,iris1</string>
	</dict>
	<dict>
		<key>group name</key>
		<string>tools</string>
		<key>keys</key>
		<string>verifast,surveysymex,cbmc,pulse,infer,javert2,javert1,jstar,klee,macke,spaceinvader,cosette,compcert,viper,gillian0,gillian1,gillian2,smallfoot,corestar,lowlevelbiab</string>
	</dict>
</array>
</plist>
}}
