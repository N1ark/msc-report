\chapter{Introduction}

\section{Motivation}

As software becomes increasingly central to critical infrastructure, the need to formally prove its correctness increases. A framework that enables scalable program verification is \emph{separation logic} \cite{seplogic1,seplogic2}, from which \emph{abstract} separation logic followed, allowing one to reason about properties of the memory independently of its actual representation \cite{higherorderseplogic,abstractseplogic}. An outstanding logic in this field is Iris \cite{iris}, which proved itself to be more than capable of enabling reasoning for a wide range of applications. These logics have however been limited to manual pen and paper proofs, or inaccessible mechanisations with Rocq.

In parallel, symbolic execution tools have been developed to allow for the verification of programs automatically, though with poor scalability \cite{surveysymex}. \emph{Compositional symbolic execution} (CSE) uses advances made in separation logic to allow for the verification of code by fragments, improving drastically scalability \cite{pathexplo} and allowing for adoption in Continuous Integration pipelines \cite{pulse}.

A particular CSE engine is Gillian \cite{gillian0}; it has the unique property of being \emph{parametric on the memory model}, allowing it to be re-used to verify any language, so long as the memory model is provided by the developer. In \cite{sacha-phd}, the idea of \emph{constructing} memory models was introduced, using partial commutative monoids. Gillian is a perfect match for this, as it is inherently compatible with any constructable memory model. The original definitions were however at times incomplete, or suffered from unsoundness due to their use of partial commutative monoid, the classical representation of memory in abstract separation~logic.

\section{Objectives}

Given the great potential in facilitating state model creation by construction, we plan on better developing the theory surrounding it, borrowing the notion of \emph{resource algebras} from Iris. To this end, we will also see what changes need to be done to a theoretical CSE engine, first described in \cite{cse1,cse2}, to take advantage of these resource algebras.

In particular, the main objectives of this project are: \begin{itemize}
	\item \textbf{RQ1}: what are the improvements provided by the use of resource algebras, compared to partial commutative monoids, when used for state models? What changes are needed to our state model definitions to take advantage of resource algebras?
	\item \textbf{RQ2}: how do we define state models and state model transformers to ensure they are provably sound, both when used in over-approximate and under-approximate reasoning? Can the optimisations made when implementing the state models be lifted back to the theory and proven to be sound?
	\item \textbf{RQ3}: are state model transformers a viable approach performance-wise? How do instantiations of Gillian using state model transformers perform when compared with pre-existing instantiations? Do the defined optimisations bring actual improvements to performance?
\end{itemize}

\section{Contributions}

The main contribution of this project is the adoption of resource algebras for the construction of state models that are compatible with CSE engines.

We define at the theory level seven different state models and state model transformers, as well as three optimised versions of the partial map state model transformer. All of these are proven to be sound.

We then implement these state models along with additional ones in OCaml, creating a state model library for Gillian. Using this library, we instantiate Gillian to allow for the verification of code written in WISL, JavaScript and C. These instantiations have full parity with the pre-existing instantiations of Gillian, providing the same verification results with a fraction of the code needed for the instantiation.

Finally, we measure in great detail the performance of the instantiations and optimisations described, comparing them to performance in Gillian, and showing areas for improvement.

\section{Outline}

In \autoref{chap:background} we introduce the necessary theoretical background needed for the project; we go over separation logic and its variations, with incorrectness separation logic and abstract separation logic. In particular we retrace the history of abstract separation logic and its evolution, leading to the creation of Iris. We then describe Gillian, a compositional symbolic execution engine parametric on the memory model. We list existing tools that enable symbolic execution and their differences. Finally, we briefly cover additional requirements relevant to this research area.

In \autoref{chap:theory} we motivate the transition from partial commutative monoids to resource algebras. We then go through the changes brought to our abstract CSE engine to accommodate the change, and define three different state models and four different state model transformers. We also cover optimisations at the theoretical level for the partial map transformer.

In \autoref{chap:implementation} we describe the implementation of these state models as a library, and how our theoretical constructs interface with the pre-existing definitions of Gillian. We also cover how a developer may use this library to instantiate Gillian with the desired state model.

In \autoref{chap:evaluation} we evaluate the work done so far, discussing first the usability of the theory and of the library. We then compare the performance of our instantiations with the reference Gillian instantiations. We also briefly observe the performance improvements offered by our partial map optimisations.

In \autoref{chap:conclusion} we conclude this report, retracing the work done, and outlining the key achievements, the relevant limitations, and give different directions to build upon what is defined here, for future work.
