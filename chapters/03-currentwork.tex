\chapter{Current Work}

\section{Initial Thoughts}

Two separate groups of work stemmed from Gillian \cite{gillian0, gillian1, gillian2} and are in the process of being written or published: CSE1 \cite{cse1} and CSE2, and the thesis of Sacha-Élie Ayoun \cite{sacha-phd}. The former is a formalisation of a unified compositional symbolic execution engine, parametric on the memory model, aimed at providing a sound and generalisable theory for a CSE engine. The latter is the complete theory behind the Gilllian framework, as well as that of the instantiation of Gillian to C and Rust. Both of threm are thus about a CSE parametric on the memory model.

As these two works are being developed in parallel, they have taken different approaches for several parts of their respective engine -- part of the current project is evaluating these decisions, and deciding on which is the most appropriate. We may also consider outside works that contribute to these questions.

\subsection{State models: PCMs or RAs}
\label{sec:thoughts-state-models}

Gillian represents its state model as a partially commutative monoid (PCM). As discussed previously, this comes with certain limitations -- most notably, the existence of a single $0$ element, whereas other instances of separation algebras in the litterature (such as the Resource Algebras (RAs) in Iris \cite{iris}) permit several $0$s (via the unit function), as well as the absence of a unit.

This is in particular useful for some particular state models, such as the sum, written $A \oplus B$, with $A\defeq(A,0_A,\cdot)$ and $B\defeq(B,0_B,\cdot)$ two state models. Initial attempts at defining a sum model in Sacha's thesis modelled it as \code{$A \oplus B \defeq 0_\oplus $ | L $A$ | R $B$}, with the composition defined as:

{
\newcommand{\LS}[0]{\code{L }}
\newcommand{\RS}[0]{\code{R }}
\begin{align*}
	0_\oplus \cdot \st = \st \cdot 0_\oplus &= \st \\*
	\LS\st \cdot \LS\st' &= \LS (\st\cdot\st') \\*
	\RS\st \cdot \RS\st' &= \RS (\st\cdot\st')
\end{align*}
}


In particular this poses a problem when one wants to be able to \emph{switch} from one side of the sum to the other, as the existence of the states \code{L $0_A$} and \code{R $0_B$} is not frame preserving, requiring the sum to be rewritten as \code{$0_\oplus $ | L $A \backslash \{0_A\}$ | R $B \backslash \{0_B\}$} hinting at something being wrong about the $0$s. 

Similarly, a frame-preserving switch requires that either the state switched from or switched to (in OX and UX respectively) be \emph{exclusively owned}. This can be defined as $\code{is\_exclusively\_owned} ~\st \defeq \forall \st'.~\st'\neq 0\implies \neg(\st\#\st')$, where $\#$ signifies that both states are disjoint and can be composed. While this definition works, having a core function would make it more elegant, and easier to prove for a given state; Iris defines this same predicate as $\text{exclusive}(a)\defeq\forall c.\neg\irisval(a\cdot c)$, allowing them to then prove sides of a sum can be switched from one to the other via the following rule:
\[
\inferrule[Exclusive-Update]
	{\text{exclusive}(a) \\ \irisval(b)}
	{a \rightsquigarrow b}
\]

The insight from this is that again, the requirement that a PCM must have a unique $0$ element is too strong -- it then requires one to remove this $0$ in higher state model transformations, which is both unelegant and tricky to notice.

Another argument in favour of RAs is the strength of the Iris theory, that provides flexible constructs and has been succesfully reused several times. As such, creating an engine that uses Iris' RAs for its state models allows one to benefit for free from the existing infrastructure surrounding it, and in particular its Rocq implementation.

Iris being extremely sophisticated and supporting complex ``higher-order ghost state'', their composition needs to be total, and accompanied by a validity function \irisval. Because the CSE engine developed for this project will not recquire such sophistication, we will make the choice of diverging from Iris on the totality of composition, instead keeping it partial. And because the validity function was used to rule out compositions that should not be allowed, we may also get rid of it, and instead rely on the fact an invalid composition is simply not defined. This comes with the pleasant side-effect that ``error states'' need not be defined for state models, as is the case with Iris where they must always define a fallback $\lightning$ state to be used for invalid composition, for instance as it is the case for the exclusive state model:

\begin{align*}
	\textsc{Ex}(X) &\defeq \text{ex}(x:X) \color{red} ~|~ \lightning\\
	\color{red}\irisval(a) &\color{red}\defeq a \neq \lightning\\
	|ex(x)| &\defeq \bot
\end{align*}

The above parts marked in {\color{red}red} could thus be ignored by making composition partial; instead of always being $\lightning$, it always is undefined. One can go from an Iris-like RA to this new type of partial RA with a simple equivalence: $\irisval(\st\cdot\st')$ is true in the former if and only if $\st\cdot\st'$ is defined in the latter (this can be further proven using Iris' rule \textsc{Ra-Valid-Op}, which states $\forall a,b.~ \irisval(a\cdot b)\implies \irisval(a)$).

While further work could be about attempting to port Iris' higher-order ghost states to this framework, this will be left out of scope for now, noting that the current divergence from Iris is minimal and easy to revert with the above equivalence.

It is also worth noting that Iris enforces that the \emph{global RA} (so the final RA, composed of smaller elements) must be unital, ie. that it has a unique unit element. This is equivalent to the unique $0$ element of PCMs -- as such, the global state model of the engine will remain very similar to a PCM; the outlined distinctions (multiple or no units, a core function) are relevant mostly for the construction of the global state model. Once constructed, it can be trivially turned into a unital RA by extending it with a unit.

\subsection{Well-formedness: Implicit or Explicit}
{
\newcommand{\heap}[0]{\hat h}
\newcommand{\store}[0]{\hat s}
\newcommand{\pc}[0]{\hat \pi}
\newcommand{\true}[0]{\text{true}}
Another distinction between the two works is their handling of well-formedness. The CSE1 paper \emph{explicitly} defines well-formedness \Wf, defined for a state $(\store, \heap, \pc)$ comprised of a symbolic store, symbolic heap and path condition as:
\begin{align*}
	\pc_1 \vDash \pc_2 &\defeq \forall\epsilon.~\epsilon(\pc_1)=\true \implies \epsilon(\pc_2)=\true\\
	\Wfc(\store)&\defeq \codom(\store)\subseteq \Val\\
	\Wfc(\heap)&\defeq \dom(\heap)\subseteq\Nat \land\codom(\heap)\subseteq\Val\land (\forall\hat v_i,\hat v_j\in\dom(\heap).~i\neq j \implies \hat v_i \neq \hat v_j)\\
	\Wf((\store,\heap,\pc)) &\defeq \SAT(\pc) \land(\text{sv}(\store)\cup \text{sv}(\heap)\subseteq \code{sv}(\pc)) \land \pc \vDash (\Wfc(\store)\land \Wfc(\heap))
\end{align*}

It then enforces in the axiomatic interface of \consume\ and \produce\ for well-formedness of the resulting state to be preserved. One may also note that, quoting CSE1, ``we only work with well-formed states $\hat\st$, denoted $\Wf(\hat\st)$'', making it similar to Iris' approach to validity with \irisval.

This approach is different in CSE2, where well-formedness is part of the definition of the models relation $\vDash$ itself: a concrete state $(\theta,s,h)$ models a symbolic state $(\store,\heap,\hat{\cal P},\pc)$ if there exists an interpretation of the symbolic state resulting in the concrete state. Because well-formedness is part of this relation, one remains in separation logic longer, as conversion to first order logic is done only when the SMT check is needed and not before. 

In comparison, Sacha's thesis does not explicitly enforce such well-formedness, and instead keeps it \emph{implicit}, by assuming a reached is already valid and well-formed, as enforced by the path condition -- a state that is not well-formed would have already raised an error, and would not have continued. Well-formedness is then kept throughout execution, as soundness is preserved.

One of the core distinctions between the two approaches is thus at what point throughout execution is a state encoded into a first order logic formula and sent to an SMT solver; whereas CSE chooses to stay in separation logic longer and only encode the constraints to first order logic later for the SMT check, Sacha's thesis instead keeps accumulating the constraints in $\pc$ directly, and then doesn't require further encoding into first order logic. 

Both alternatives are mostly analogous, and there both seem to be equivalent -- the difference may amount to performance, which would need to be measured. To remain aligned with the decision to remove the validity function of RAs however, the implicit alternative to well-formedness feels at present more justified.
}

\subsection{Symbolic and Logical Variables: United or Separate}

Another consideration to take into account is the distinction between \emph{symbolic variables} and \emph{logical variables}. 

Symbolic variables arise from symbolic execution: program variables are mapped to symbolic values via a symbolic store $\hat s:\text{PVar}\finmap \text{SVal}$, and a symbolic variable can be \emph{interpreted} into a set of concrete values with $\epsilon:\text{SVar}\finmap\text{Val}$ \cite{cse1}. They are the symbolic counterpart to concrete variables.

Logical variables, on the other hand, are the classic variables one would encounter when reasoning about a program; they are existentially quantified. A substitution ${\hat\theta:\text{LVar}\finmap\text{SVal}}$ maps logical variables to symbolic values, whereas a logical intepretation $\theta:\text{LVar}\finmap\text{Val}$ maps logical variables to concrete values \cite{cse1}. One can see logical variables as a syntactic construct to designate symbolic values. For instance, the in and out values of predicates are logical variables.

While they represent separate concepts, CSE2 has taken the approach of treating them as the same and having no distinction between the two, treating logical variables as symbolic variables. A key motivation for this is that it avoids having to carry a substitution $\hat\theta$ into symbolic values, making the theory less verbose.

On the other hand, one could argue that they represent separate worlds and should not be mixed. \todo{Explain Daniele's POV}

\section{Work So Far}

\subsection{State Models}
\label{sec:state-models-work}

Following the PhD thesis of Sacha-Élie Ayoun, several state models and state model transformers have been implemented for the current version of Gillian. We distinguish state models, which are atoms of the construction of a larger state model, and state model \emph{transformers}, which are functors that receive one or more state models (or other inputs), and create a new state model from these.

The full list of implemented state models is: \begin{itemize}
	\item \code{Exc}: the exclusive state model, which implements \code{load} and \code{store} actions and a single \code{points\_to} predicate. This corresponds to the ``default'' points to predicate of separation logic, but without the address, which is added later via a transformer.
	\item \code{Ag}: the agreement state model, which implements a \code{load} action and a single \code{agree} predicate. This predicate is duplicable, and can be used to model the concept of shareable \emph{knowledge}, which is immutable -- this notion. has been studied several times in the litterature \cite{higherorderseplogic, statesoundness, monotonicstate, iris}. Note that it does not have a \code{store} action, as it would not be frame-preserving.
	\item \code{Frac}: the fractional state model, which similarly to \code{Exc} implements the \code{load} and \code{store} actions, but instead adds a \code{frac} predicate which is equivalent to the points to predicate equipped with a fraction, as discussed previously and taking inspiration from \cite{fracpermissions, fracpermissions2}.
\end{itemize}

To allow extending simpler state models, several state model transformers have also been implemented. These may extend their components by implementing additional actions, modifying the parameters or return values of actions, adding in or out parameters to predicates, or extending the possible states with additional information. The implemented transformes are: \begin{itemize}
	\item \code{PMap}: a partial map transformer, that allows mapping locations to states. It extends all predicates with an extra in value, the index, and similarly with the parameters of actions. It also allows for two different modes of operation. The first is \emph{static} mode, which enables C-like behaviour, where new cells must be allocated via an \code{alloc} action, that returns a fresh location. The second is \emph{dynamic} mode, which is what one would expect to see for JavaScript: the map is initially empty, but trying to write or load from anywhere in the map will simply add the index to the map if not already allocated -- in this mode, the \code{alloc} action is thus forbidden.
	\item \code{List}: a list transformer, that maps integers between $0$ and a given length to states. It is similar to \code{PMap}, but with the added guarantee of having all indices fall in a range. It is initialised with empty elements in all cells, and as such does not require an \code{alloc} action. It does however extend all actions and predicates with an ``offset'' parameter and in value respectively.
	\item \code{Freeable}: this transformer allows one to \emph{free} a resource, that is to delete it and remember the cell was freed. It thus extends the states with a freed state $\varnothing$, and adds an action \code{free} that frees the state. The need for a $\varnothing$ state to mark a location as freed is needed for UX-soundness, and is one of the key insights of Incorectness logic\cite{incorrectnesslogic}, as simply ``forgetting'' about a resource when freeing it would not be frame preserving in a UX setting. This transformer is similar to Iris' \code{OneShot}, except the $\varnothing$ state is \emph{not duplicable}, which is also needed for UX-soundness -- it is instead exclusively owned.
	\item \code{Product}: this represents the product of two state models. It doesn't add any actions or predicates, but modifies all predicate and action names by appending a prefix to them, to then be able to distinguish to which side of the product the action or predicate is destined.
\end{itemize}

Because Gillian has significantly grown in complexity over time, the interface of state models \code{MonadicSMemory} is quite complex and contains several required functions that have an unclear definition. To ease development of the above state models and transformers, a simpler interface \code{MyMonadicSMemory} was implemented, which adds defaults to some of these functions and allows some simplications of the interface. While not extensively tested, these simplifcations do not seem to be the source of any problem, at least in OX-mode.

\subsection{Gillian Experiment: Outcomes}

One of the insights and avances made in Sacha-Élie's thesis is the addition of an \LFail{} error, to distinguish missing resource errors from logical failure due to a logical mismatch or consumer incompleteness. This means the possible outcomes for a symbolic execution branch are ${\cal O}_l^+ = \{\Ok,\Err, \Miss, \LFail\}$.

The current version of Gillian uses the \code{result} type for symbolic branches, defined as \code{('a, 'e) result = | Ok of 'a | Error of 'e}. To then distinguish between fixable \Miss{} errors and other errors, state models must then implement a \code{can\_fix} function that tells whether an error is fixeable, which is to say whether it is a \Miss. This is a significant difference between the implementation and the theory behind Gillian.

Redefining a custom state model interface wrapping Gillian's own interface allowed the author to easily experiment with core changes to the typings and interfaces, as these changes could then be converted back to a Gillian-compatible format within the wrapper, while giving access to the improvements to the state models. As such, an experiment was made to extend errors with a \Miss{} and \LFail{} outcomes, as seen in \autoref{fig:sym-outcome}. This then allowed the \code{can\_fix} function to be removed, as a simple pattern match for \Miss{} is sufficient to know if an outcome is fixable.

\begin{figure}[h]
\centering
\begin{lstlisting}
type 'a 'e 'f 'm sym_result =
| Ok of 'a
| Err of 'e
| LFail of 'f
| Miss of 'm
\end{lstlisting}
\caption{Symbolic result typoe}
\label{fig:sym-outcome}
\end{figure}

The outcome of the experiment proved quite promising -- although it sometimes made handling symbolic branches more verbose (as more outcomes needed to be checked or wrapped), we consider the gain in parity with the theory and the expressiveness of the outcomes more than enough to make up for it. This change allowed to further simplify the implementation of all state models and transformers, at no extra cost. While this experiment was limited to the scope of state models, it may be of interest in future research and the current project to more deeply use this system, in particular in the core of the engine, as it could probably allow for further simplifications.

\subsection{Sum Soundness}

An unexpected side-effect of implementing the aforementioned state model and state model transformers is that it helped uncover unsoundness in a state model transformer: the sum. As explained in \autoref{sec:thoughts-state-models}, the initial definition and implementation of the sum was both OX and UX unsound. Research was thus done to prove properties that must hold for a sum that can switch sides -- this is for instance the case of \code{Freeable}, which while implemented as a standalone state model, could be represented as $X \oplus \St_\code{Freed}$ with $X$ the input state model, and $\St_\code{Freed}$ a trivial monoid with a single \code{Freed} element and exclusive ownership.

For brievety, we will simply list the properties for a OX and UX-sound ``swap'' action that flips the sum from one side to the other. First, neither sides of the sum must allow a $0$ element. Furthermore, both the states swapped from and to must be \emph{exclusively owned}. This rules out some state models as valid elements of such sums, for instance \code{Ag}.











