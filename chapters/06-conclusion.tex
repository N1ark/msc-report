\chapter{Conclusion} \label{chap:conclusion}

\section{Achievements}

Throughout this project we adapted and developed a theory to construct state models, as well as developed a range of different state models to allow for the construction of complex state from easy to understand and modify building blocks. To this end, we firstly highlighted the difficulty with using partial commutative monoids when considering state model constructions. We then introduced the concept of \emph{partial resource algebras}, an adaptation of the resource algebras presented in Iris \cite{iris}. Following this, we adapted the notion of state models introduced in the context of an abstract parametric CSE engine \cite{cse2} to use these partial resource algebras, and re-defined the properties these state models must satisfy. We then introduced a range of different state models and state model transformers, taking inspiration from work done in \cite{iris,sacha-phd}; \emph{these state models are proven to be OX and UX sound}. These state models and state model transformers can be combined to build more complex state models, allowing real-world memory models to be recreated with ease, while being sound by construction. For instance, the JavaScript state model which is capable of verifying real world code is sound, and no additional proof is needed to show it, as it only uses the state models we defined. We have also demonstrated that two optimisations of the partial map transformer are sound, and shown exactly why a third optimisation is not.

Furthermore, we brought these state model constructions to Gillian, a CSE engine. We have adapted and simplified the state model interface it provides to suit our needs, and implemented the presented state models as an OCaml library that exposes a total of \emph{14 different modules and functors} usable for state model constructions. The implemented state models are OX and UX sound, allowing them to be used in Gillian to perform whole program symbolic testing, verification, and true bug finding of real world code. These modules are all short and independent, allowing them to be modified, verified, and optimised easily.

Finally, we used our library to create instantiations of Gillian for JavaScript, C, and WISL, which have the same capabilities as the pre-existing monolithic instantiations, but with stronger soundness guarantees, thanks to the ease of verification of the library. This has shown that the state models we defined are capable of representing real languages in their entirety, like JavaScript, but can also be used in combination with more specialised state models while still providing better performance and a simpler instantiation, with C as an example.

We have performed an extensive evaluation of the performance of our instantiations, analysing in detail what improved compared to the reference Gillian instantiations, and what areas still need further refinement. The evaluation was done for WISL and C with whole program symbolic testing (WPST), verification, and true bug finding; for JavaScript with WPST and verification. In the case of JavaScript and C, we saw a net improvement in performance in all execution modes.

Finally, we also evaluated the performance offered by the optimisations of the partial map we defined theoretically, showing mixed results.

\section{Limitations and Future Work}

The presented state models are quite simple in their construction; in particular more ambitious resource algebras such as what Iris calls ``higher-order ghost state'' \cite{iris} have not been replicated. Overall a lot of the logic used is still embedded in Gillian, rather than defined externally via state models and core predicates. More research would be needed to see how more deeply Iris-enabled reasoning can be embedded in Gillian's logic.

User-defined predicates, bi-abduction's anti-frame and function calls by specification can all be defined via state model transformers, rather than as part of a CSE engine \cite{sacha-phd}. Formalising and implementing them using our definitions could prove useful, as these functionalities could then be removed from Gillian's core engine and instead defined externally, reducing its complexity. Doing this would also facilitate the adoption of these features in new parametric CSE engines, as they could be added on top of the engine later in development, rather than being deeply embedded within it. This work paves the way to a new CSE engine that puts more emphasis on state models and modularity in general.

The partial map state model transformer, \PMap, only supports allocation in a non-concurrent setting. While not a limitation for our use case, since Gillian does not support concurrency, it is a flaw of the theory; more advanced state models could be developed to support parallel allocation while still providing guarantees of OX and UX soundness and allow distinguishing out of bounds from missing errors. This could be done, for instance, via an authoritative resource algebra \cite{iris}.

Instantiating Gillian using the developed state model library is still a convoluted process at times, requiring functor-heavy code, which is hard to write and understand. The developed interface for state models is also not ideal, requiring a significant amount of functions to be defined; ideally only the core \execac, \consume, \produce{}, and \fix{} functions should be needed, the rest being optional. The goal is here to again simplify implementation as much as possible, allowing it to be as close to the theory as possible. An idea that comes to mind is the use of OCaml's \code{ppxlib} library\footnote{See \url{https://github.com/ocaml-ppx/ppxlib}.} to do meta-programming and simplify some tedious requirements of the state model interface.

While we have obtained full parity with the Gillian instantiations via our transformers, future work could attempt to further improve performance, with more aggressive optimisations or attempting to tie in the state models with lower level code. Going further than what has been done with Gillian before, instantiating it to new languages, should also be considered.

Finally, we showed the system of abstract locations Gillian uses extensively is currently unsound; finding a sound justification to its use, for instance taking inspiration from nominal logic, would be crucial to reinforce Gillian's claims of soundness.
