\chapter{Resource Algebras for a CSE}

\section{Current State}


\subsection{CSE}

CSE and Sacha's thesis do the traditional choice of using Partial Commutative Monoids (PCMs) to model state. They are defined as the tuple $(M, (\cdot):M\times M \part M, 0)$. They are further equipped with a set of actions $\cal A$, an \execac{} function, a set of core predicates $\Delta$ and a pair of \consume{} and \produce{} functions.

These additions are necessary for the engine to be parametric on the state model, as it provides an interface for interaction with the state.

The usage of PCMs comes with issues: the requirement of a single 0 for each state model means that state models such as the sum state model $\mmdl_1 + \mmdl_2$ come with unwieldy requirements to prove soundness -- this comes into play for the \code{Freeable} state model, that could use a sum (like what is done in \cite{iris-thesis}) but can't because of this.

\subsection{Iris}

Iris \cite{iris} departs from this tradition and introduces Resource Algebras (RAs) to model state, defined as a tuple $(M, \irisval: M\rarr \bools, |-|:M\rarr M^?, (\cdot):M\times M\rarr M)$, being respectively the state elements, a validity function, a partial core function and a composition function.

This makes Iris states more powerful, in that they have more flexibility in what they can express; for instance sum state models can be easily and soundly expressed, which isn't possible with PCMs due to the requirement of a single $0$ element.

Furthermore, Iris RAs comes with plenty proofs and properties making them easy to use and adapt, whereas PCMs can prove unwieldy even for simpler state models (eg. with the Freeable state model transformer).

A similarity however is that the global RA in Iris must be unital, meaning it must have a single $\epsilon$ element, very much as it is the case with the 0 in PCMs. Any RA can be trivially extended to have a unit, which is what Iris defines as the option resource algebra \cite{iris-option}.

\section{Partial RAs}

A property of Iris RAs is that composition is \emph{total} -- to take into account invalid composition, states are usually extended with a $\lightning$ state, such that $\neg \irisval(\lightning)$ (while for states $\st\neq\lightning$, $\irisval(\st)$ holds). While this is needed in the Iris framework for higher-order ghost state and step-index, this doesn't come into play when only manipulating RAs. As such, because this is quite unwieldy, we can remove it by adding partiality instead, such that invalid ($\lightning$) states simply don't exist and the need for a $\irisval$ function vanishes. This is also inline with the core function $(-)$ being partial.

It is worth noting that \emph{partial} RAs are equivalent to regular RAs, \emph{so long as $\irisval$ always holds for valid states}\footnote{This, to our knowledge, is the case for all of the simpler RAs defined in Iris: Ex, Ag${}_0$, sum, product, etc.}. Indeed, compositions that yield $\lightning$ can be made undefined, and the validity function removed, to gain partiality, and inversely to go back to the Iris definition.

An interesting property of this is that because validity is replaced by the fact composition is defined, the validity of a composition is equivalent to the fact two states are disjoint: $\irisval(a\cdot b) \iff a \# b$.

We now define the properties of RAs taking this change into account -- see \autoref{fig:ra-def}. From now, the term RA will be used to refer to these partial RAs.
\begin{figure}
A \emph{resource algebra} (RA) is a triple $(M, |\!-\!|: M\rarr M^?, (\cdot): M\times M \part M)$

\begin{align}
	\tag{RA-Assoc} \forall a,b,c&\ldotp (a\cdot b)\cdot c = a\cdot (b\cdot c)\\
	\tag{RA-Comm} \forall a,b&\ldotp a\cdot b = b\cdot a\\
	\tag{RA-Core-ID} \forall a&\ldotp |a| \in M \Rarr |a|\cdot a = a\\
	\tag{RA-Core-Idem} \forall a&\ldotp |a|\in M\Rarr ||a|| = |a|\\
	\tag{RA-Core-Mono} \forall a,b&\ldotp |a|\in M\land a\preo b \Rarr |b| \in M \land |a| \preo |b|
\end{align}
\begin{align*}
	\text{where}\qquad
	M^? &\defeq M \uplus \{\bot\}\text{, with }a\cdot \bot \defeq \bot\cdot a\defeq a\\
	a \preo b &\defeq \exists c\ldotp b = a\cdot c\\
	a\disj b &\defeq a \cdot b \text{ is defined}
\end{align*}
A \emph{unital} resource algebra is a resource algebra $M$ with an element $\epsilon\in M$ such that:
\begin{align*}
	\forall a\in M. \epsilon\cdot a = a&&
	|\epsilon|=\epsilon
\end{align*}
\caption{Definition of Resource Algebras}
\label{fig:ra-def}
\end{figure}

\section{CSE State Models + RAs}

We now propose to redefine the notion of state models. To follow the spirit of CSE, that comes with a core engine, a compositional engine and a bi-abduction engine all built onto each other, we go through each layer, presenting what is for that part of the engine to function.

\subsection{Core Engine}

\newcommand{\vallist}[0]{\Val~\code{list}}

The core engine enables whole-program symbolic execution. For this state models must firstly define the set of states the execution will happen on; this is done via a partial resource algebra: a tuple  $(M, |\!-\!|:M\rarr M^?,(\cdot):M\times M\part M)$. They are further equipped with a set of actions $\cal A$, and an \execac{} function.
\begin{align*}
	\execac &: \pset(\code{SVar})\rarr \Sst^? \rarr {\cal A} \rarr \vallist \rarr \pset(\full\outcomes_e \times \Sst^? \times \vallist \times \Pc)
\end{align*}
The arguments of \execac{} are, in order: the set of existing symbolic variables (this allows the state model to generate fresh variables, for instance in allocation), the \emph{optional} state the action is executed on, the action, and the received arguments. It returns a set of branches, with an outcome, the new state, the returned values, and the path condition of that branch. It is pretty-printed as \ppexec{\alpha}{SV, \sst,\sins, o}{\sst', \souts, \pc}, with $SV$ omitted when not necessary.

Here, the outcome is an outcome in the set of \emph{full execution outcomes} $\full\outcomes_e=\{ \Ok,\Err \}$. In the next subsection, this set will be extended to account for misses and logical failures, but these do not exist with full semantics.

The main difference here is that the state may be $\bot$, if the action is executed on empty state. This ensures non-unital RAs are not ruled out as invalid -- indeed, many useful RAs are not unital and sometimes don't have a unit at all, as is the case for instance for \Ex, the exclusively owned cell. One could decide to internally make all RAs of state models unital, and have the state model provide an \code{empty} function that returns said unit (this is what happens in Gillian). However this introduces unsoundness to certain state model constructions (in particular the sum), as this means the state cannot be \emph{exclusively owned} -- the empty state could always be composed with it.

Whole-program symbolic execution is, by definition, non-compositional -- it thus operates on \emph{full state}, a notion introduced in \cite{sacha-phd}. As such, the only valid outcomes here are \Ok{} and \Err{}.

Because we operate in symbolic memory, an additional piece of information is the \emph{path condition}, the set of constraints accumulated throughout execution. A path condition $\pc\in\Pc$ is a \emph{list} of symbolic values, that evaluates to a boolean. We decide to define it as a list rather than a single conjunction of boolean symbolic values, as this allows us to easily check if a path condition is an extension (or a strengthening) of another, with $\pc'\supseteq\pc$.

\subsection{Compositional Engine}

The compositional engine, built on top of the core engine, allows for verification of function specifications, and handles calling functions by their specification. As such, the state model must be extended with a set of core predicates $\Delta$ and a pair of \consume{} and \produce{} functions (equivalent, respectively, to a symbolic assert and assume). Finally, to link core predicates to states, it provides a $\code{sat}_\Delta$ relation.
\begin{align*}
	\text{for }M=\{\code{OX}, \code{UX}\}\\
	\consume &: M\rarr \Sst^? \rarr \Delta \rarr \vallist \rarr \pset(\outcomes_l \times \Sst^? \times \vallist \times \Pc) \\
	\produce &: \Sst^? \rarr \Delta \rarr \vallist \rarr \vallist \rarr \pset(\Sst^? \times \Pc)\\
	\code{sat}_\Delta &:\St \rarr \Delta \rarr \vallist \rarr \pset(\vallist)
\end{align*}
Similarly to \execac, the input state can be $\bot$. While intuitively one may assume that the input state of \consume{} and the output state of \produce{} may never be $\bot$, this would limit what core predicates can do. In particular, this means an $\emp$ predicate couldn't be defined, since it's production on an empty state results in an empty state.

The arguments of \consume{} are, in order: the mode of execution to distinguish between under-approximate and over-approximate reasoning, the state, the core predicate being consumed, the ins of the predicate. It outputs a \emph{logical outcome}, the state with the matching predicate removed (which may result in an empty state $\bot$), the outs of the predicate and the associated path condition. It is pretty-printed as \ppcons{m,\sst,\delta,\sins}{o, \sst_f, \souts, \pc}, and when the consumption is valid in both OX and UX the mode is omitted.

For \produce{}, the arguments are the state, the core predicate being produced, the ins and the outs of the predicate, resulting in a set of new states and their associated path condition. As an example, producing $x \mapsto 0$ in a state $[1 \mapsto 2]$ results in a new state $[1\mapsto 2, x \mapsto 0]$ with the path condition $x \neq 1$. If the produced predicate is incompatible with the state (eg. by producing $1 \mapsto y$ in a state containing $1 \mapsto x$), the producer \emph{vanishes}. Inversely, if the assertion can be interpreted in several ways, the producer may branch. It is pretty-printed as $\ppprod{\sst,\delta,\sins,\souts}{\sst', \pc}$.

The \code{sat} relation relates a \emph{concrete} state, core predicate and in-values to a set of out-values. It is pretty-printed as $\st \models_\Delta \corepred{\delta}{\ins}{\outs}$. For instance in the linear heap state model, we have $[ 1 \mapsto 2 ] \models_\Delta \corepred{\code{points\_to}}{1}{2}$.

Here we define logical outcomes $\outcomes_l = \{\Ok, \LFail, \Miss \}$. These are outcomes that happen during reasoning; in particular, \LFail{} equates to a logical failure due to an incompatibility between the consumed predicate and the state. For instance, consuming $1 \mapsto 1$ when in state $1 \mapsto 2$ would yield a \LFail{}, while consuming it in state $5 \mapsto 3$ would yield a \Miss{}, as a state $1\mapsto x$ could be composed with it to yield a non-miss outcome.

We must also modify the signature of \execac, to include \Miss{} outcomes, via the set of execution outcomes $\outcomes_e=\{\Ok,\Err,\Miss\}$.

An addition to what CSE previously defined is thus the split of what was the \code{Abort} outcome into \LFail{} and \Miss{}, this improves the quality of error messages and allows fixing consumption errors due to missing state -- this will be described in the next subsection.

A last change compared to CSE is that we drop the path condition parameter to consume and produce -- the function instead directly returns the path condition required for the resulting branches, and the engine can filter these. For instance, in UX all consumption branches that result in \LFail{} can be dropped, as dropping branches is allowed in UX. This has the advantage of simplifying the axioms, as the path condition is strengthened by definition; the function itself has no way of weakening it. \note{Mention that this also makes checkpointing with the SAT engine trivial -- just set a checkpoint before \consume/\produce, add whatever that returns. No need to separate the old from new, avoids duplicating/deduplicating, etc.}

\subsection{Bi-abduction Engine}

To support bi-abduction in the style of Infer:Pulse \cite{pulse}, \Miss{} outcomes must be fixed. These outcomes may happen during consumption or during action execution. For this, the state model must provide a \fix{} function, that given the details of a miss error (these details being of type \Val{} and returned with the outcome) returns a list of sets of assertions that must be produced to fix the missing error.
\begin{align*}
	\fix &: \Val \rarr \pset(\text{Asrt}) ~\code{list}
\end{align*}
Note here we return a \emph{list} of different fixes, which themselves are a set of assertions -- this is because, for a given missing error, multiple fixes may be possible which causes branching. For instance, in the typical linear heap, accessing a cell that is not in the state fragment at address $a$ results in a miss that has two fixes: either the cell exists and points to some existentially quantified variable (the fix is thus $\exists x\ldotp a \mapsto x$), or the cell exists and has been freed ($a\mapsto\varnothing$).

This approach is different from how Gillian handles it. There the function \fix{} returns \emph{pure} assertions (type information, pure formulae) and arbitrary values of type \code{fix\_t}, which can then be used with the $\code{apply\_fix}:\Sigma \rarr \code{fix\_t} \rarr \Sigma$ method of the monadic state. This means fixes can be arbitrary modifications to the state that don't necessarily equate to new assertions to add to the anti-frame.

This is a source of unsoundness, as the engine may interpret these modifications as fixes despite them not reliably modifying the state. This can be seen in \cite{sacha-phd}, where not finding the binding in a PMap(X) returns a \code{MissingBinding} error. While being labelled as a miss, this error can actually not be fixed; PMap simply \emph{lifts} predicates with an additional in parameter for the index. An implementation of that version of PMap(X) could attempt to fix this state by add a binding to $X.0$ (PMaps were originally made for PCMs, which always have a 0 element), which would then eventually lead to another error once the action gets called on the empty state. On top of being under-performing (as several fixes would need to be generated for one action), this requires PMap(X) to allow empty states in the codomain, which means a PMap is never exclusively owned (as a state with a singleton map to $X.0$ can always be composed with it), which limits its usability; aside from not being modelable using RAs, since $\bot$ is not an element of X's carrier set. Finally, if the underlying state model doesn't provide any additional fixes, then the fix for \code{MissingBinding} cannot be added to the UX specification of a function: there is no assertion generatable from within PMap to represent this modification. As such, having \fix{} returns assertions without modifying any state directly ensures fixes are always soundly handled.

To finish this, we may note the solution to the above bug is to proceed executing the action on the underlying state model, giving it an empty state -- it will then raise the appropriate \Miss{}, which can be fixed, as it is aware of what core predicates are needed to create the required state. For instance, for PMap(Exc) a \code{load} action on a missing binding would be executed against $\bot$, which would return a \code{MissingValue} error. The PMap could then wrap the error with information about the index at which the error occurred, $\code{SubError}(i, \code{MissingValue})$. When getting the fix, PMap can then call Exc.\fix, which returns $\exists x\ldotp \corepred{points\_to}{}{x}$, and lift the fix by adding the index as an in-argument, resulting in the final fix $\exists x\ldotp\corepred{points\_to}{i}{x}$, which is a valid assertion and can be added to the UX specification for this execution.

\subsection{Axioms}

We may now go over the axioms that must be respected by the above defined functions for the soundness of the engine. Note we will thus focus on the axioms related to the state models in particular, and not the general semantics of the engine.

First, it is worth noting that Gillian supports both over-approximate (OX) and under-approximate (UX) reasoning -- for which \emph{frame subtraction} or \emph{frame addition} must hold, respectively. In addition to the axioms in \cite{cse1} and the upcoming paper on an Abstract CSE, we also take inspiration from \cite{sacha-phd} and include the notion of \emph{compatibility}, linking full states to compositional states, as well as concrete states to symbolic states.

Indeed there are two orthogonal concepts at play: one is \emph{compositionality}, that introduces \consume{} and \produce{}, frame addition and subtraction, and ultimately compatibility. The other is \emph{symbolicness}, that introduces soundness and the $\vDash$ relation for symbolic state modelling. To simplify the axioms, we will only consider the symbolic compositional case, as it is a superset of the other cases.

For all of the axioms we assume we have a symbolic state model $\mmdl$, made of the RA $\Sst \ni \sst$. We consider the initial state $\sst$ well-formed.%, and a satisfiable path condition $\pc$.

\subsubsection{Symbolicness Axioms \note{\footnotesize a nicer name would be good}}

\begin{equation}
\tag{Empty Symbolic Memory}\label{eq:empty-sym-mem}
\theta,s,\st\models \bot_{\Sst^?} \implies \st = \bot_{\St^?}
\end{equation}

\begin{equation}
\tag{Empty Memory}\label{eq:empty-mem}
\theta,s,\bot_{\St^?}\models \bot_{\Sst^?}
\end{equation}

Note that here we work with the \emph{option} version $\St^?$ of the states $\St$, which extends the carrier set with a $\bot_{\St^?}$ element. If the core of a state $|\st|$ is undefined, it becomes $|\st^?|=\bot_{\St^?}$. Finally, the composition of any state with $\bot_{\St^?}$ is that state.

\begin{equation}
\tag{Symbolic Memory Composition}\label{eq:symbolic-mem-comp}
\begin{array}{l}
\theta,s,\st_1\models \sst_1 \land \theta,s,\st_2\models \sst_2 \land \st_1\#\st_2 \iff \theta,s,(\st_1\cdot\st_2)\models (\sst_1\cdot\sst_2)
\end{array}
\end{equation}

\begin{equation}
\tag{Memory Model OX Soundness}\label{eq:mem-ox-soundness}
\begin{array}{l}
\theta,s,\st\models\sst \land \ppexec{\alpha}{\st,\ins}{o,\st',\outs} \implies \exists \SV, \sins,\souts,\sst',\pc,\theta'\ldotp\\
\quad \ppexec{\hat\alpha}{\SV, \sst,\sins}{o,\sst',\pc,\souts} \land \SAT(\pc) \land \theta',s,\st'\models \sst' \land\\
\qquad \expeval{\sins}_{s,\pc}=(\ins,\pc')\land\expeval{\souts}_{s,\pc'}=(\souts,\pc'')
\end{array}
\end{equation}

\begin{equation}
\tag{Memory Model UX Soundness}\label{eq:mem-ux-soundness}
\begin{array}{l}
\ppexec{\hat\alpha}{\SV,\sst,\sins}{o,\sst',\pc,\souts} \land \SAT(\pc) \land \theta,s,\st'\models\sst' \land \\
\expeval{\souts}_{\hat s,\pc}\rightsquigarrow(\outs,\pc')\land \expeval{\sins}_{\hat s,\pc'}\rightsquigarrow(\ins,\pc'')\implies\\
\quad \exists \st\ldotp \theta,s,\st\models\sst \land \ppexec{\alpha}{\st,\ins}{o,\st',\outs}
\end{array}
\end{equation}

\subsubsection{Compositionality Axioms}

\begin{equation}
\tag{Frame subtraction}\label{eq:frame-sub}
\begin{array}{l}
\ppexec{\alpha}{\sst\cdot\sst_f,\sins}{o, \sst',\souts,\pc'} \implies \\
\quad\exists \sst'', o', \souts'\ldotp \ppexec{\alpha}{\sst,\sins}{o', \sst'', \souts', \pc''} ~\land \\
\qquad(o' \neq \Miss \implies o' = o \land  \souts' = \souts \land \sst' = \sst'' \cdot \sst_f \land \pc'' = \pc')
\end{array}
\end{equation}

\begin{equation}
\tag{Frame Addition}\label{eq:frame-add}
\begin{array}{l}
\ppexec{\alpha}{\sst,\sins}{o, \sst', \souts, \pc'} \land o \neq \Miss \land \sst'\#\sst_f\implies\\
\quad\sst \# \sst_f \land \ppexec{\alpha}{\sst\cdot\sst_f, \sins}{o, \sst'\cdot\sst_f, \souts, \pc'}
\end{array}
\end{equation}

Here, we may note that the frame-preserving update $a \rightsquigarrow b$ from Iris is a form of frame subtraction: it guarantees $\forall c\ldotp \irisval(a \cdot c)\Rarr \irisval(b\cdot c)$, with $c$ a frame that can be added to the state ($\sst_f$ in the axiom). This becomes evident when noticing that disjointness of partial RAs equates to validity in Iris RAs, giving us $\forall c\ldotp a\# c\Rarr b\# c$. In fact, the Iris frame-preserving update implies frame subtraction modulo action outcomes. This makes sense, as Iris is used for OX reasoning, and frame subtraction is the property needed for OX soundness. \note{Maybe move this elsewhere.}

Given the full state model $\full{\mmdl}$ with the states $\full\Sst$ and actions $\full\actions$ and the compositional state model $\mmdl$ with the states $\Sst\supseteq\full\Sst$ and actions $\actions$, $\Sst$ is the set of fragments of $\full\Sst$ if ${\forall \sst\in\Sst\ldotp \exists\full\sst\in\full\Sst\ldotp \sst\preo\full\sst}$ (completion), and ${\forall\full\sst_1,\full\sst_2\in\full\Sst\ldotp \full\sst_1\preo\full\sst_2 \implies \full\sst_1=\full\sst_2}$ (inextensibility).  These two state models are compositional, denoted $\full\mmdl \tilde \mmdl$ if all actions of full states using compositional semantics have the same result as using the full semantics.

\begin{equation}
\tag{Compatibility}\label{eq:compatibility}
\begin{array}{l}
\ppexec{\full\alpha}{\full\sst, \sins}{o,\full\sst',\souts,\pc} \iff
\ppexec{\alpha}{\full\sst, \sins}{o,\full\sst',\souts,\pc}
\end{array}
\end{equation}

Note here that we do not consider compatibility of the semantics of the language, but rather only the compatibility of the actions of the state models -- it is assumed the compatibility of the full semantics follow from it.

\note{Does the above make sense? Sacha originally defined compatibility for concrete states, but I should be able to be lifted to symbolic states anyways... I just would want to handle compositionality/symbolicness independently, otherwise I imagine I need to then lift all compositional concrete axioms to compositional symbolic...}

\begin{equation}
\tag{Consume Soundness and Completeness}\label{eq:consume-sound-complete}
\begin{array}{l}
\ppcons{\sst,\delta,\sins}{\Ok,\sst_f,\souts,\pc_f} \implies\\
\quad\exists \sst_\delta\ldotp \sst=\sst_f\cdot\sst_\delta\land (\forall\theta,s,\st,\ins,\outs\ldotp \\
\qquad (\theta(\pc\land\pc_f)=\vtrue \land \expeval{\sins}_{\theta,s} = \ins \land \expeval{\souts}_{\theta,s}=\outs) \implies\\
\quad\qquad \theta,s,\st\models \sst_\delta \Leftrightarrow \st \models_\Delta \corepred{\delta}{\ins}{\outs})
\end{array}
\end{equation}

\begin{equation}
\tag{Consume OX: No Path Drops}\label{eq:consume-ox-no-drop}
\begin{array}{l}
(\forall o, \sst'\pc'\ldotp \ppcons{OX,\st,\delta,\sins}{o_c, \souts, \pc'}\Rarr o_c = \Ok)\land \theta, s, \st \models \sst \implies \\
\quad \exists  \sst', \pc', \st'\ldotp \ppcons{OX, \sst, \delta,\ins,\pc}{\Ok, \sst', \souts, \pc'} \land \theta,s,\st' \models \sst'
\end{array}
\end{equation}
\note{Because the outcome $o_c$ can be \LFail{} or \Miss{}, I changed the axiom from having $o_c\neq \code{Abort}$ to $o_c=\Ok$. Should be fine?}

\begin{equation}
\tag{Produce: Soundness}\label{eq:produce-sound}
\begin{array}{l}
\ppprod{\sst_f,\delta,\sins,\souts}{\sst, \pc_f} \implies\\
\exists \sst_\delta\ldotp \sst=\sst_\delta\cdot\sst_f \land (\forall\theta,s,\st_\delta\ldotp\\
\quad \theta(\pc\land\pc_f)=\vtrue \Rarr \expeval{\sins}_{\theta,s}=\ins \Rarr \expeval{\souts}_{\theta,s}=\outs \Rarr \\
\quad \theta,s,\st_\delta \models \sst_\delta \Rarr \st_\delta\models_\Delta\corepred{\delta}{\ins}{\outs})
\end{array}
\end{equation}

\begin{equation}
\tag{Produce: Completeness}\label{eq:produce-complete}
\begin{array}{l}
\expeval{\sins}_{\theta,s}=\ins \land \expeval{\souts}_{\theta,s}=\outs~\land \theta,s,\st\models\sst \land \st_\delta \models_\Delta \corepred{\delta}{\ins}{\outs} \land \st \# \st_\delta \implies\\
\quad \exists\sst_\delta,\pc_f\ldotp \ppprod{\sst,\delta,\sins,\souts}{\sst\cdot\sst_\delta,\pc_f} \land \theta(\pc_f) = \vtrue  \land \theta,s,\st_\delta\models\sst_\delta
\end{array}
\end{equation}

%\section{Full States}
%
%In Sacha-Élie Ayoun's thesis \cite{sacha-phd}, the notion of \emph{full states} is introduced, as an additional step between different abstractions of states. This is distinct from previous works, that only considered compositional (concrete) and (compositional) symbolic states; the full (concrete) state is by definition not compositional and represents how the program actually runs.
%
%This addition comes with constraints, most notably that compositional states can be completed into full states \ref{eq:state-complet}, and full states are inextensible \ref{eq:state-inext}.
%
%\begin{figure}[H]
%	Given the RA $(\St, |\!-\!|, (\cdot))$ and $\full\St\subseteq\St$, $\full\St$ is the set of full elements of $\St$ and $\St$ is the set of fragments of $\full\St$ if:
%	\begin{align}
%		\tag{State-Comp}
%		\label{eq:state-complet}
%		\forall \st\in\St\ldotp\exists\full\st\in\full\St&\ldotp a\preo \full\st\\
%		\tag{State-Inext}
%		\label{eq:state-inext}
%		\forall \full\st_1,\full\st_2\in\full\St&\ldotp \full\st_1\preo \full\st_2 \Rarr \full\st_1=\full\st_2
%	\end{align}
%	\caption{Definition of full and partial state}
%\end{figure}
%
%Furthermore, the existence of compositional state implies the \Miss{} outcome, meaning the state can be completed with another state fragment to give a non \Miss{} outcome. Compositional semantics are compatible with full semantics if evaluation on full states with compositional semantics is equivalent to evaluation with full semantics.
%
%For particular constructions such as PMaps and Lists however, this is done by adding a domain set or bound, respectively, to the compositional state -- on action execution on a cell that is not in the partial state, one can thus check whether the cell is simply not in this fragment of the state (resulting in a \Miss) or if the cell does not exist (resulting in an \Err). Without such additional information, the compositional semantics would need to resort to always evaluating to \Err{}, or to \Miss{} -- the former breaks frame subtraction and addition making the state unsound, the latter means \Miss{} outcomes leak into full semantics.
%
%A PMap over a state model $\St$ with a sort $I$ is defined as $I \finmap \St \times \pset(I)$, with $\pset(I)$ the domain set as discussed above that is exclusively owned. Similarly, a List state model over $\St$ is defined as $\nats\finmap\St\times\nats$, with the second element of the product the exclusively owned bound (or size) of the list. While both states use the notion of a mapping $I \finmap \St$, this wouldn't form a valid state model, because as explained above the semantics would not be able to distinguish \Err{} from \Miss{} outcomes. This is a source of discomfort, as it goes against the idea of being able to soundly construct complex state models from simpler blocks -- one would need to redefine mappings for every such structure. Similarly, the product both state transformers use also exists as a state model, and both domain set and bound are exclusively owned and could be modelled with Exclusive, but aren't. Furthermore, Iris already defines finite partial maps, so we know these form valid RAs, but they do not form sound state models \emph{when full states are considered}.

%While one could accept this and redefine the state models to make up for this difference, much work would need to be redone, and one would need to pass on the rich theory that already exists in Iris. We may note this difficulty comes from the unification of state models and the RAs (or PCMs, in previous works) that back them.
%
%We may introduce a split between RAs, that can be used for reasoning about the state just like in Iris, and fully fledged state models, that must also provides actions, core predicates and must be compatible with the full state. By doing so, one can enjoy the constructions pre-existing in Iris, while enhancing them with actions and predicates when needed to form state models. A valid RA must satisfy the properties described in \autoref{fig:ra-def} (such that all RAs defined in Iris work), while a valid state model must both have a valid RA and come with \consume, \produce{} and \execac{} functions that are sound with regards to the backing RA. This idea is also inline with the goal of Iris and that was mentioned in \cite{next700seplogics}, where one full separation logic can be used without needing to reinvent the wheel at each inconvenience.

\section{RAs and State Models}

We now define the state transformers defined in \cite{sacha-phd}, taking advantage of RAs. We will first define the ``leaf'' state models: the state models that are don't take any state model as input, \Ex, \Ag{} and \Frac. We will then look at 3 simple transformer state models, \Sum, \Product{} and \PProduct{}. Finally, we will discuss more complex state models, with \Freeable, \PMap{} and \List.

\subsection{Exclusive}

The exclusive state model \Ex{}(\Val) is a simple state model, that represent exclusively owned cells: the cell can can only be owned once, and cannot be composed with any other cell. It is parametric on the values it stores -- for the traditional symbolic execution cell, this would be \code{Sval}. When clear from context, the type of values is omitted. It's RA is defined as: \begin{align*}
 	\Ex(X) &\defeq	\ex{x: X}\\
 	|\ex{x}| &\defeq \bot\\
 	\ex{x_1} \cdot \ex{x_2}&~\text{is always undefined}
 \end{align*}
 Note that the above definition is identical to that in Iris \cite{iris}, showing that little to no modification is needed to adapt RAs to state models.

It defines two actions, $\actions=\{\load, \store\}$ and a predicate $\preds=\{\exP\}$  We now define the functions for the state model: \execac, \produce, \consume{} and \fix.
\begin{mathparpagebreakable}
\inferrule[ExLoadOk]{}{\ppexec{\load}{\ex{x},[]}{\Ok,\ex{x},[x],[]}}
\and\inferrule[ExLoadMiss]{}{\ppexec{\load}{\bot,[]}{\Miss, \ex{x},[], []}}
\and\inferrule[ExStoreOk]{}{\ppexec{\store}{\ex{x}, [x']}{\Ok, \ex{x'}, [], []}}
\and\inferrule[ExStoreMiss]{}{\ppexec{\store}{\bot,[x']}{\Miss,\ex{x},[],[]}}
\and\inferrule[ExConsOk]{}{\ppcons{\ex{x}, \exP, []}{\Ok, \bot, [x], []}}
\and\inferrule[ExConsMiss]{}{\ppcons{\bot,\exP, []}{\Miss, \bot, [], []}}
\and\inferrule[ExProd]{}{\ppprod{\bot,\exP, [], [x]}{\ex{x}, []}}
\and\inferrule[ExFix]{}{\fix ~[] = [\{ \exists x\ldotp \corepred{\exP}{}{x} \}]}
\end{mathparpagebreakable}

\subsection{Agreement}

The agreement state model \Ag{}(\Val) is the state model to represent an agreement algebra (sometimes referred to as \emph{knowledge} in the literature \cite{higherorderseplogic}): information that can be duplicated. \begin{align*}
	\Ag(X) &\defeq \ag{x: X}\\
	|\ag{x}| &\defeq \ag{x}\\
	\ag{x} \cdot \ag{x'} &\defeq \begin{cases}
 	\ag{x} &\If~x = x' \\
 	\text{undefined} &\Otherwise
 \end{cases}
\end{align*}
Again, this definition is identical to the one of $\Ag_0$ in Iris (the non-step-indexed version of agreement).

Because knowledge is duplicable, it cannot be modified: indeed, one would need to modify all instances of the knowledge to ensure frame preservation still holds. Its actions are thus $\actions=\{\load\}$, and it has one predicate, $\Delta=\{\agP\}$.
\begin{mathparpagebreakable}
\inferrule[AgLoadOk]{}{\ppexec{\load}{\ag{x},[]}{\Ok,\ag{x},[x],[]}}
\and\inferrule[AgLoadMiss]{}{\ppexec{\load}{\bot,[]}{\Miss,\bot,[],[]}}
\and\inferrule[AgConsOk]{}{\ppcons{\ag{x},\agP,[]}{\Ok,\ag{x},[x],[]}}
\and\inferrule[AgConsMiss]{}{\ppcons{\bot,\agP,[]}{\Miss,\bot,[][]}}
\and\inferrule[AgProdBot]{}{\ppprod{\bot,\agP,[],[x]}{\ag{x}, []}}
\and\inferrule[AgProdEq]{}{\ppprod{\ag{x},\agP,[],[x']}{\ag{x}, [x = x']}}
\and\inferrule[AgFix]{}{\fix~[] = [\{\exists x\ldotp \corepred{\agP}{}{x}\}]}
\end{mathparpagebreakable}

\subsection{Fractional}

The fractional state model \Frac(\Val) is used to handle \emph{fractional permissions} \cite{fracpermissions,fracpermissions2}. This allows a cell to be partly owned and its information shared, for instance in multithreading. This is done by pairing every value with a fraction $0<q\leq 1$, and ensuring the value can only be modified if we own the entire value (ie. $q=1$). \begin{align*}
	\Frac(X)&\defeq \fracc{x: X, q: (0;1]}\\
	|\fracc{x, q}| &\defeq \bot\\
	\fracc{x,q}\cdot\fracc{x',q'}&\defeq \begin{cases}
		\fracc{x,q+q'} & \If~ x=x' \land q+q' \leq 1\\
		\text{undefined} &\Otherwise
	\end{cases}
\end{align*}
We may note this definition is different from that in Iris, that chooses to define the fractional state model as $\textsc{Frac} \times \textsc{Ag}_0(\Val)$, where \Frac{} is the RA for strictly positive rationals. This work in their case, because they can define actions for any state model easily, so they can define \load{} for the product having knowledge of the underlying state models. However, because the state models presented here are aimed at being reused in a variety of contexts while minimising the need for defining new actions and predicates, using their approach would hurt usability, as the \load{} action would need to be redefined for this specific instantiation of the product. Furthermore, this construction would yield two predicates: \agP{} and \fracP{}, making its use unpractical.

We instead define the actions $\actions=\{\load,\store\}$ and the core predicate $\Delta=\{\fracP\}$ as follows:
\begin{mathparpagebreakable}
\inferrule[FracLoadOk]{}{\ppexec{\load}{\fracc{x,q},[]}{\Ok,\fracc{x,q},[x],[],[]}}
\and\inferrule[FracLoadMiss]{}{\ppexec{\load}{\bot,[]}{\Miss,\bot,[1],[]}}
\and\inferrule[FracStoreOk]{}{\ppexec{\store}{\fracc{x,q},[x']}{\Ok,\fracc{x',q},[],[q=1]}}
\and\inferrule[FracStorePerm]{}{\ppexec{\store}{\fracc{x,q},[x']}{\Miss,\fracc{x,q},[1-q],[q<1]}}
\and\inferrule[FracStoreMiss]{}{\ppexec{\store}{\bot,[x']}{\Miss,\bot,[1],[]}}
\and\inferrule[FracConsAll]{}{\ppcons{\fracc{x,q},\fracP,[q']}{\Ok,\bot,[x],[q=q']}}
\and\inferrule[FracConsSome]{}{\ppcons{\fracc{x,q},\fracP,[q']}{\Ok,\fracc{x,q-q'},[x],[0 < q' < q]}}
\and\inferrule[FracConsMiss]{}{\ppcons{\fracc{x,q},\fracP,[q']}{\Miss,\fracc{x,q},[q' - q],[q < q' \leq 1]}}
\and\inferrule[FracConsFail]{}{\ppcons{\fracc{x,q},\fracP,[q']}{\LFail,\fracc{x,q},[],[q' \leq 0 \lor 1 < q']}}
\and\inferrule[FracProdBot]{}{\ppprod{\bot,\fracP,[q],[x]}{\fracc{x,q},[0 < q \leq 1]}}
\and\inferrule[FracProdEq]{}{\ppprod{\fracc{x,q},\fracP,[q'],[x']}{\fracc{x,q+q'},[x=x' \land 0<q' \land q+q' \leq 1]}}
\and\inferrule[FracFix]{}{\fix~[q] = [\{ \exists x. \corepred{\fracP}{q}{x} \}]}
\end{mathparpagebreakable}

Here we note that the fraction part of the state is an in-parameter, whereas the value is an out-parameter. This allows one to explicitly specify the required fraction of the state that is consumed.

\subsection{Sum}

The sum of two state models, denoted $\mmdl_1 + \mmdl_2$, represents all states that are in either one of the two states. Sums are one of the reasons for which the $0$ of PCMs was removed, in favour of the core, as it allows both sides of the sum to have a different unit (if any). We re-use the definition of sum from Iris. \begin{align*}
	\Sum(X, Y) \defeq X+Y &\defeq l(x: X) ~|~ r(y: Y)\\
	l(x)\cdot l(x') &\defeq l(x\cdot x')\\
	r(y)\cdot r(y')&\defeq r(y\cdot y')\\
	|l(x)|&\defeq \begin{cases}
 		\bot &\If~ |x|=\bot\\
 		l(|x|) &\Otherwise
	 \end{cases}\\
	 |r(y)|&\defeq \begin{cases}
 		\bot &\If~ |y|=\bot\\
 		r(|y|) &\Otherwise
	 \end{cases}
\end{align*}

Similarly for the actions and predicates, we simply re-use the underlying function. The actions are defined as ${\actions = \{\alpha_l : \alpha \in \mmdl_1.\actions \} \uplus \{\alpha_r : \alpha \in \mmdl_2.\actions \}}$, and the core predicates ${\Delta = \{\delta_l : \delta \in \mmdl_1.\Delta \} \uplus \{\delta_r : \delta \in \mmdl_2.\Delta \}}$.
\begin{align*}
	\text{Given }
	\mathit{wrap}_l(x) = \begin{cases}
		\bot &\If~x=\bot\\
	 	l(x)&\Otherwise
	 \end{cases} \text{ and }
	 \mathit{unwrap}_l(x_l) = \begin{cases}
 		\bot &\If ~x=\bot\\
 		x_l &\If~x=l(x_l)\\
 		\text{undefined}&\Otherwise
	 \end{cases}
\end{align*}
\begin{mathparpagebreakable}
\inferrule[SumLAction]{x=\mathit{unwrap}_l(x_l) \\ \ppexec{\alpha}{x,\sins}{o,x',\souts,\pc} \\ x_l' = \mathit{wrap}_l(x') \\ o \neq \Miss}{\ppexec{\alpha_l}{x_l,\sins}{o,x_l',\souts,\pc}}
\and\inferrule[SumLActionMiss]{x=\mathit{unwrap}_l(x_l) \\ \ppexec{\alpha}{x,\sins}{o,x',\souts,\pc} \\ x_l' = \mathit{wrap}_l(x') \\ o = \Miss}{\ppexec{\alpha_l}{x_l,\sins}{o,x_l',\code{`l'::}\souts,\pc}}
\and\inferrule[SumLActionIncompat]{}{\ppexec{\alpha_l}{r(y),\sins}{\Err,r(y),[],[]}}
\and\inferrule[SumLCons]{x=\mathit{unwrap}_l(x_l) \\ \ppcons{x,\delta_l,\sins}{o,x',\souts,\pc} \\ x_l' = \mathit{wrap}_l(x') \\ o \neq \Miss}{\ppcons{x_l,\delta_l,\sins}{o,x_l',\souts,\pc}}
\and\inferrule[SumLConsMiss]{x=\mathit{unwrap}_l(x_l) \\ \ppcons{x,\delta_l,\sins}{o,x',\souts,\pc} \\ x_l' = \mathit{wrap}_l(x') \\ o = \Miss}{\ppcons{x_l,\delta_l,\sins}{o,x_l',\code{`l'::}\souts,\pc}}
\and\inferrule[SumLConsIncompat]{}{\ppcons{r(y),\delta_l,\sins}{\LFail,r(y),[],[]}}
\and\inferrule[SumLProd]{x=\mathit{unwrap}_l(x_l) \\ \ppprod{x,\delta_l,\sins,\souts}{x',\pc} \\ x_l'=\mathit{wrap}_l(x')}{\ppprod{x_l,\delta_l,\sins,\souts}{x_l',\pc}}
\and\inferrule[SumLFix]{\mmdl_1.\fix~\sins=a}{\fix~\code{`l'::}\sins=a}
\end{mathparpagebreakable}

We only describe the rules for the left side of the sum -- the equivalent rules for the right hand side are defined analogously.

For fixes to be retrieved from the correct side of the sum, \Miss{} outcomes must be extended with an indicator of what side the information comes from, so that the correct \fix{} function is then called. Some extra care also needs to be taken to handle $\bot$ states separately, since it is not an element of the underlying state models and as such $l(\bot)$ or $r(\bot)$ are not valid -- the auxiliary $\mathit{wrap}_l$ and $\mathit{unwrap}_l$ functions help do this without multiplying by four the number of rules.

The sum is one of the main reasons for the switch from PCMs to RAs, as being able to handle $\bot$ separately is an advantage: it avoids situations where the underlying state may be \emph{observably empty}, but the state of the sum is $l(\mmdl_1.0)$ (if we use PCMs). This causes unsoundness, as for instance actions and predicates belonging to the right side of the sum would then yield \Err{} and \LFail{} respectively, despite the fact that if the state of the sum was simply $\bot$ they'd succeed.

We may give an example to illustrate: let there be the state model $\Ex(\{1\}) + \Ex(\{2\})$. A valid function specification in this state model is \ESLtriple{\corepred{\exP_l}{}{1}}{\code{swap()}}{\corepred{\exP_r}{}{2}}\footnote{The signature of this \code{swap} function is analogous to that of the \code{free} action, for the \Freeable{} state model that will later be described.}, where the \code{swap} function switches the state from the left hand side to the right hand side. Now if this was constructed using PCMs, the engine would first consume the core predicate for the precondition. The consumption for $\Ex(\{1\})$ is \ppcons{\ex1,\exP_l,[]}{\Ok,0_l,[1],[]}. The consumption for the sum would thus be \ppcons{l(\ex1),\exP_l,[]}{\Ok,l(0_l),[1],[]}. Note, here, that the sum state model has \emph{no way of knowing if the state became empty}, and must thus keep it as $l(0_l)$. The engine would then produce the postcondition, which is \corepred{\exP_r}{}{2} -- this would however result in the branch vanishing, as $\exP_r$ is not a predicate that can be produced into some $l(x)$. The function call would thus vanish, which is unsound in OX (and would result in no branches in UX, which is sound but useless). \note{I have a formal proof of this unsoundness, I'll add it here eventually, or put it in the appendix, TBD.}

Of course one may decide state models must expose an \code{is\_empty} function, and use that instead -- however this would needlessly complexify state models and would reinvent the wheel; multi-core resource algebras were specifically created to solve this problem \cite{sepalgebra}, and the partial core of Iris was \emph{also} created for this reason among others \cite{iris}.

\subsection{Product}

The product $\mmdl_1 \times \mmdl_2$ of two state models is the cartesian product of both sets of states. Its RA is defined by lifting all elements pointwise: \begin{align*}
 	\Product(X,Y)&\defeq X \times Y\\
 	(x,y)\cdot(x',y') &\defeq (x\cdot x',y\cdot y')\\
 	|(x,y)|&\defeq \begin{cases}
(|x|, |y|) &\If~|x|\neq\bot \land |y|\neq\bot\\
\bot&\Otherwise
 \end{cases}
 \end{align*}

An interesting property of the product is that if one side of the product has no core, then so does the entire product; this also means that both sides of the product must be defined, or neither are defined. This creates a challenge: if an empty ($\bot$) product produces a core predicate for one of its sides, what happens to the other side of the product? Indeed, while one side becomes, defined, $x\times \bot$ is not a valid state, since $\bot \notin \mmdl_2.\Sst$.

It seems here that the consume-produce interface of our engine, which allows creating state bit by bit, can thus be unadapted for certain RAs. Instead, we define an alternative product RA that is more suited to this engine.

\subsection{Partial Product}

The \emph{partial product} state model, denoted $A \bowtie B$, is an alternative to the Iris product RA, that carries some of its useful properties while being adapted to a produce-consume interface. This product supports having only one side be empty -- this is different from the usual product RA, that must have both sides have a value.
\begin{align*}
	\PProduct(X,Y) \defeq X \bowtie Y &\defeq X^? \times Y^? \backslash \{(\bot, \bot)\}\\
	(x, y) \cdot (x', y') &\defeq (x \cdot x', y \cdot y')\\
	|(x, y)| &\defeq \begin{cases}
		\bot &\If~|x|=\bot\land |y|=\bot\\
		(|x|, |y|) &\Otherwise
 	\end{cases}	\\
\end{align*}

The advantage of this definition is twofold. Firstly, it allows expressing fragments of products, where one side may not have a defined core. For instance, given the product state $\ex{a} \times \ex{b}$, one can't express this as the composition of some $\ex{A} \times \bot$ and $\bot \times \ex{b}$, which becomes needed for some state transformers (notably, \PMap{} and \List). This is in turn possible with the partial product . The second advantage of the partial product and one of the main motivations behind it is that it \emph{carries on the exclusivity of its components}. Given $\text{exclusive}(a) \defeq \forall c\ldotp \neg(a\# c)$, the following rule holds:
\[
\inferrule[PartProductEx]
	{\text{exclusive}(a)\\\text{exclusive}(b)}
	{\text{exclusive}(lr(a, b))}
\]
This is needed to allow frame-preserving transitions from one side of a sum to another. We may note also that the state model transformer itself could be generalised to handle an arbitrary number of state models, as $(A \bowtie B) \bowtie C \iff A \bowtie (B \bowtie C)$ -- for the brevity of this presentation, we will only consider the partial product of two state models.

Similarly to the sum, its actions are ${\actions = \{\alpha_l : \alpha \in \mmdl_1.\actions \} \uplus \{\alpha_r : \alpha \in \mmdl_2.\actions \}}$, and core predicates ${\Delta = \{\delta_l : \delta \in \mmdl_1.\Delta \} \uplus \{\delta_r : \delta \in \mmdl_2.\Delta \}}$.
\begin{align*}
	\text{Given }
	\mathit{wrap}(x, y) = \begin{cases}
		\bot &\If~x=\bot \land y=\bot\\
		(x,y) &\Otherwise
	 \end{cases} \text{ and }
	 \mathit{unwrap}(s) = \begin{cases}
 		(\bot, \bot) &\If ~s=\bot\\
		(x, y) &\Otherwise
	 \end{cases}
\end{align*}
\begin{mathparpagebreakable}
\inferrule[PProductLAction]{\muted{(x,y)=\mathit{unwrap}(s)} \\ \ppexec{\alpha}{x,\sins}{o,x',\souts,\pc} \\ \muted{s' = \mathit{wrap}(x',y)} \\ o \neq \Miss}{\ppexec{\alpha_l}{s,\sins}{o,s',\souts,\pc}}
\and\inferrule[PProductLActionMiss]{\muted{(x,y)=\mathit{unwrap}(s)} \\ \ppexec{\alpha}{x,\sins}{o,x',\souts,\pc} \\ \muted{s' = \mathit{wrap}(x',y)} \\ o = \Miss}{\ppexec{\alpha_l}{s,\sins}{o,s',\code{`l'::}\souts,\pc}}
\and\inferrule[PProductLCons]{\muted{(x,y)=\mathit{unwrap}(s)} \\ \ppcons{x,\delta_l,\sins}{o,x',\souts,\pc} \\ \muted{s' = \mathit{wrap}(x',y)} \\ o \neq \Miss}{\ppcons{s,\delta_l,\sins}{o,s',\souts,\pc}}
\and\inferrule[PProductLConsMiss]{\muted{(x,y)=\mathit{unwrap}(s)} \\ \ppcons{x,\delta_l,\sins}{o,x',\souts,\pc} \\ \muted{s' = \mathit{wrap}(x',y)} \\ o = \Miss}{\ppcons{s,\delta_l,\sins}{o,s',\code{`l'::}\souts,\pc}}
\and\inferrule[PProductLProd]{\muted{(x,y)=\mathit{unwrap}(s)} \\ \ppprod{x,\delta_l,\sins,\souts}{x',\pc} \\ \muted{s'=\mathit{wrap}(x',y)}}{\ppprod{s,\delta_l,\sins,\souts}{s',\pc}}
\and\inferrule[PProductLFix]{\mmdl_1.\fix~\sins=a}{\fix~\code{`l'::}\sins=a}
\end{mathparpagebreakable}

\subsection{Freeable}

The \Freeable(\mmdl) state model transformer allows extending a state model with a \free{} action, that allows freeing a part of memory. The freed memory can then not be used, and attempting to access it raises a \code{UserAfterFree} error. This is similar to the \textsc{OneShot} RA of Iris, with the key difference that the \freedP{} predicate used to mark a resource as freed is \emph{not duplicable} -- whereas Iris defines \textsc{OneShot(X) $\defeq$ Frac + Ag(X)}, this definition is not UX-sound. \note{Maybe a small proof of this? Or is it evident?} This is not a problem for Iris, that is only concerned with OX soundness, but justifies this modification for this engine.

To ensure only full states are freed, the underlying state model must provide a function ${\code{is\_exclusively\_owned}:\Sst\rarr\code{LVal}}$, which equates to the property `exclusive' presented before. Note here this returns a \emph{symbolic value}, that can be appended to the path condition (it must thus be a boolean). This allows symbolic ownership, for instance having the fraction of \Frac{} be a symbolic number.

While not needed for the core and compositional engines, the bi-abductive engine requires that  misses may be fixed; \Freeable(\mmdl) however cannot access directly the core predicates of \mmdl{} to provide fixes when freeing an empty state. As such, the state model must also provide a ${\code{fix\_owned}:\St^?\rarr\pset(\text{Asrt})~\code{list}}$ function that returns possible fixes to make the given state exclusively owned. This also implies that full states of \mmdl{} are exclusively owned -- this is not the case, for instance, for \Ag. As such, constructions such as \Freeable(\Ag) are not sound.

Its RA is defined as a construction: $\Freeable(\mmdl) \defeq \mmdl + \Ex(\{\freed\})$, which allows all associated rules to be kept. For clarity, we rename the core predicate $\exP_r$ (defined by~$\Ex(\{\freed\})$) as $\freedP$. We also extend its actions with the $\free$ action.

Because \Freeable{} is constructed via other state model transformers, we only need to describe the rules for \free{} -- the rest of the construction is already sound. This is an example of how simpler state models can be extended while alleviating the user from the burden of proving the soundness of the base construction.

\begin{mathparpagebreakable}
\inferrule[FreeableActionFree]{}{\ppexec{\free}{l(x),[]}{\Ok,r(\ex\freed),[],[\mmdl.\code{is\_exclusively\_owned}~x]}}
\and\inferrule[FreeableActionFreeErr]{}{\ppexec{\free}{l(x),[]}{\Miss,l(x),\mmdl.\code{fix\_owned}~x,[\neg\mmdl.\code{is\_exclusively\_owned}~x]}}
\and\inferrule[FreeableActionFreeMiss]{}{\ppexec{\free}{\bot,[]}{\Miss,\bot,\mmdl.\code{fix\_owned}~\bot,[]}}
\and\inferrule[FreeableActionDoubleFree]{}{\ppexec{\free}{r(\ex\freed),[]}{\Err,r(\ex\freed),[],[]}}
\end{mathparpagebreakable}

We may note that use-after-free errors are already handled by the sum construction, thanks to the \textsc{SumLActionIncompat} rule.

\subsection{PMap}

The partial map transformer, $\PMap(I,\mmdl)$, allows modelling partial finite maps. It receives a domain $I$, and the codomain state model $\mmdl$.
\begin{align*}
	\PMap(I,\mmdl) &\defeq I \finmap \mmdl.\Sigma \times \pset(I)^?\\
	(h,d)\cdot (h',d') &\defeq (h'', d'') \\
	\text{where } h''&\defeq \lambda i.\begin{cases}
		h(i)\cdot h'(i)&\If~i\in \dom(h)\cap\dom(h')\\
		h(i) &\If~i\in \dom(h) \backslash \dom(h')\\
		h'(i) &\If~i\in \dom(h') \backslash \dom(h)\\
		\text{undefined}&\Otherwise
	\end{cases}\\
	\text{and }d''&\defeq\begin{cases}
		d&\If~d'=\bot\\
		d'&\If~d=\bot\\
		\text{undefined}&\Otherwise
	\end{cases}\\
	\text{and }& d'' = \bot \lor \dom(h'')\subseteq d''\\
	|(h, d)| &\defeq \begin{cases}
		\bot &\If~\dom(h')=\emptyset\\
		(h', \bot) &\Otherwise
	\end{cases}\\
	\text{where }h'&\defeq \lambda i.\begin{cases}
		|h(i)| &\If~ i\in\dom(h) \land |h(i)| \neq \bot\\
		\text{undefined} &\Otherwise
	\end{cases}
\end{align*}

The state is thus the bindings from index to substate, as well as a possibly unset \emph{domain set}. This domain set allows distinguishing, when an index is not found in the map, if the outcome is an \Err{} or \LFail{} (because the binding cannot exist), or if the state at that index is actually $\bot$ (in which case the \execac, \consume{} or \produce{} call is done with $\bot$ as an input). More than improving automation, this is a requirement, for compatibility with the full state model (\ref{eq:compatibility}) and to preserve \ref{eq:frame-sub} and \ref{eq:frame-add}.

\PMap{} has a well-formedness condition, to ensure the domain of the bindings is a subset of the domain set -- for instance, the state $(\{ 2 \mapsto x \}, \{ 1 \})$ is not valid, as $\{2\} \not\subseteq \{1\}$. If the domainset is missing, then there is no restrictions on the bindings.

$\PMap(I,\mmdl)$ defines one action, \alloc, and one predicate, \domainset. Furthermore, it lifts all predicates of the wrapped state model, by adding the index of the cell as an in-parameter. Furthermore, to allow allocation, $\mmdl$ must provide an ${\code{instantiate}: \vallist \rarr \St}$ function, to instantiate a new state from a list of arguments. This is needed because \PMap{} has no awareness of how $\mmdl$ works, or or what it should be initialised to. \note{Maybe specify that CSE/Sacha don't mention this: PMap allocation requires an interface for allocation.}

For the rules below, we define $h[i \leftarrow s]$ as setting the binding at index $i$ of $h$ to $s$, and $h[i \not\leftarrow]$ as removing the binding at $i$ from $h$.

We first define a helper methods \code{get} and \code{set}, that allows modifying a symbolic map with branching. After a look up, it returns the value at the location (which may be $\bot$ if it's not found), and the path condition corresponding to the branch. This allows simplifying shared rules for \execac, \produce{} and \consume{} for \PMap{}.
\begin{align*}
	\code{get}&: ((I \finmap X) \times \pset(I)^?) \rarr I \rarr \pset(I \times X \times \Pc) \\
	\code{set}&: ((I \finmap X) \times \pset(I)^?) \rarr I \rarr X \rarr (I \finmap X \times \pset(I)^?)
\end{align*}
We pretty-print \code{get} and \code{set} as \ppget{s,i}{i',x,\pc} and \ppset{s,i,x}{s'}.
\begin{align*}
	\text{Given }
	\mathit{wrap}(h, d) &\defeq \begin{cases}
		\bot &\If~\dom(h)=\emptyset \land d=\bot\\
		(h,d)&\Otherwise
	\end{cases}\\
	\mathit{unwrap}(s) & \defeq \begin{cases}
		([], \bot) &\If~s=\bot\\
		(h, d) &\If~s=(h,d)
	\end{cases}\\
\end{align*}
\begin{mathparpagebreakable}
\inferrule[PMapGetMatch]{(h,d)=\mathit{unwrap}(s) \\ i'\in\dom(h) \\ s_{i'}=h(i')}{\ppget{s, i}{i', s_{i'}, [i=i']}}
\and\inferrule[PMapGetAdd]{(h,d)=\mathit{unwrap}(s) \\ i\notin\dom(h) \\ d\neq\bot}{\ppget{s, i}{i,\bot, [i\notin\dom(h) \land i\in d]}}
\and\inferrule[PMapGetBotDomain]{(h,d)=\mathit{unwrap}(s) \\ i\notin \dom(h) \\ d=\bot}{\ppget{s,i}{i,\bot,[i\notin\dom(h)]}}
\and\inferrule[PMapSetSome]{(h,d)=\mathit{unwrap}(s) \\ s_i\neq\bot \\ h'=h[i\leftarrow s_i] \\ s'=\mathit{wrap}(h', d)}{\ppset{s,i,s_i}{s'}}
\and\inferrule[PMapSetNone]{(h,d)=\mathit{unwrap}(s) \\ s_i=\bot \\ h'=h[i\not\leftarrow] \\ s'=\mathit{wrap}(h', d)}{\ppset{s,i,s_i}{s'}}
\end{mathparpagebreakable}

An interesting thing to outline here is that we may branch in three different ways when retrieving a binding: \begin{compactitem}
\item \textsc{PMapGetMatch}: the index is equal to some index in the map, and we execute the action for that location -- note here the resulting path condition has $i=i'$, such that branches where the index isn't equal will be cut. This allows taking into account symbolic values.
\item \textsc{PMapGetAdd}: the index is not already in the map, but is part of the domain set; this means the state is $\bot$.
\item \textsc{PMapGetBotDomain}: the index is not already in the map, and the domain set is not owned; the given index may thus be valid, and we again return $\bot$.
 \end{compactitem}
 There is no branching when setting the binding, as the index is already known.

We now define the rules for \PMap(I,\mmdl):

\begin{align*}
	\text{Given }
	\mathit{lift\_if\_miss}(o, i, \sins) &\defeq \begin{cases}
		i :: \sins &\If~o=\Miss\\
		\sins &\Otherwise
	\end{cases}
\end{align*}
\begin{mathparpagebreakable}
\inferrule[PMapAction]{\ppget{s,i}{i',s_{i'},\pc} \\ \ppexec{\alpha}{s_{i'},\sins}{o,s'_{i'},\souts,\pc'} \\ \ppset{s,i',s'_{i'}}{s'}}{\ppexec{\alpha}{s,i::\sins}{o,s',i'::\souts, \pc :: \pc'}}
\and\inferrule[PMapActionOutOfBounds]{d\neq\bot}{\ppexec{\alpha}{(h,d),i::\sins}{\Err, (h,d), [], [i\notin d]}}
\and\inferrule[PMapAlloc]{d\neq \bot \\ i \notin \SV \\ i \notin \dom(h) \\ i \notin d \\ s_i=\code{instantiate}(\sins) \\ h' = h[i\leftarrow s_i] \\ d' = d\uplus i}{\ppexec{\alloc}{\SV, (h,d), \sins}{\Ok, (h',d'), [i], [i=i]}}
\and\inferrule[PMapAllocMiss]{\muted{(h,d)=\mathit{unwrap}(s)} \\ d=\bot}{\ppexec{\alloc}{\SV,s,\sins}{\Miss,s,[\code{`domainset'}],[]}}
\and\inferrule[PMapCons]{\ppget{s,i}{i',s_{i'},\pc} \\ \ppcons{s_{i'},\delta,\sins}{o,s'_{i'},\souts,\pc'} \\ \ppset{s,i',s'_{i'}}{s'} \\ \souts'=\mathit{lift\_if\_miss}(o,i',\souts)}{\ppcons{s,\delta,i::\sins}{o,s',\souts', \pc::\pc'}}
\and\inferrule[PMapConsIncompat]{d\neq\bot}{\ppcons{(h,d),\delta,i::\sins}{\LFail, (h,d), [], [i\notin d]}}
\and\inferrule[PMapConsDomainSet]{d\neq \bot}{\ppcons{(h,d),\domainset,[]}{\Ok,(h,\bot), [d],[]}}
\and\inferrule[PMapConsDomainSetMiss]{\muted{(h,d)=\mathit{unwrap}(s)} \\ d=\bot}{\ppcons{s,\domainset,[]}{\Miss,s, [\code{`domainset'}], []}}
\and\inferrule[PMapProd]{\ppget{s,i}{i',s_{i'},\pc} \\ \ppprod{s_{i'},\delta,\sins,\souts}{s'_{i'},\pc} \\ \ppset{s,i',s'_{i'}}{s'}}{\ppprod{s,\delta,i::\sins,\souts}{s', (i = i')::\pc}}
\and\inferrule[PMapProdDomainSet]{(h,\bot)=\mathit{unwrap}(s)}{\ppprod{s,\domainset,[],[d]}{(h,d),[\dom(h)\subseteq d]}}
\and\inferrule[PMapFix]{\mmdl.\fix~\sins = a \\ a'=\mathit{lift}(a,i)}{\fix~i::\sins = a'}
\and\inferrule[PMapFixDomainSet]{}{\fix~[\code{`domainset'}] = \exists d\ldotp \corepred{\domainset}{}{d}}
\end{mathparpagebreakable}

This simple construction is thus enough to recreate the standard ``points to'' predicate of standard separation logic \cite{seplogic1, seplogic2}: with $\PMap(\nats, \Ex(\Val))$, one can formulate the core predicates \corepred{\exP}{i}{x}, which is equivalent to $i \mapsto x$.

Note here we must unwrap and re-wrap the state model after every action, to properly handle the case where there are no bindings and no domain set as $\bot$. For the \fix{} function we must also lift all core predicates, by recursing through the assertions and adding the index to the in-values of all assertions of type $\corepred{\delta}{\sins}{\souts}$.

We note here that action execution and predicate consumption and production may branch. For instance, if the state is $(\{ 1\mapsto y \}, \{ 1,2\})$ and a \load{} action is executed with an unconstrained symbolic index $\hat x$, then three branches are created: one where $\hat x = 1$ and the action is executed on the cell $y$, one where $\hat x = 2$ and the action is executed on $\bot$, and finally one where $\hat x\notin \{1,2\}$, and an \Err{} is raised for out of bounds access. A fourth branch also gets created, with $\hat x\notin \{ 1,2\} \land \hat x\in \{1,2\}$ -- it however gets cut because of course this path condition is false. This outlines a key difficulty of \PMap{}, that will be discussed more in depth later: implementation-wise, it is a complex and expensive transformer that has the potential to create many branches -- this makes it an important target for optimisation.

Using RAs rather than PCMs makes well-formedness easier to uphold, as a binding to $\bot$ is not valid, since $\bot \notin \mmdl.\Sigma$. To exemplify why this is helpful, consider the state model $\PMap(\nats, \Ex(\{1\}))$ and the function \code{move}, that relocates a memory cell:
\begin{align*}
\ESLtriple{\corepred{\exP}{1}{1} \star \corepred{\domainset}{}{\{1\}}}{\code{move()}}{\corepred{\exP}{2}{1} \star \corepred{\domainset}{}{\{2\}}}
\end{align*}
Let the initial state be $(\{ 1\mapsto \ex1\}, \{ 1\} )$: a heap with one cell, at address $1$ -- this matches exactly the precondition of \code{move}.

If we are using PCMs, $\Ex({1})$ is defined as $\ex{1}~|~0$, with $0$ the unit of the PCM. Note here that executing actions, consuming and producing doesn't return an element of $\St^?$, but of $\St$ directly, since the $0$ is already in its carrier set; one has no reason to extend it with $\bot$. The engine first consumes the \exP{} predicate, at address $1$ -- this means the pointed-to state becomes $0$ (or empty), and the bigger (or outer) state becomes $(\{ 1\mapsto 0\}, \{ 1\})$. The \domainset{} predicate is then successfully consumed too, leaving $(\{ 1\mapsto 0\},\bot)$. Now, the post-condition is produced onto the state, as calling the function modified the state of our program. First, the engine thus produces \corepred{\exP}{2}{1}, which adds a binding to \PMap{} and creates the cell: our bigger state is now $(\{ 1\mapsto 0, 2\mapsto \ex1\},\bot)$. Finally, \corepred{\domainset}{}{\{2\}} is produced onto the state, however this \emph{doesn't succeed}. Indeed, the bindings of the heap are $\{1,2\}$, which are not a subset of the produced domainset $\{2\}$. This is because the engine cannot tell apart empty ($0$) states from non-empty states. Of course one could handle this by checking for $0$, or by explicitly excluding units from the codomain of \PMap{}. This however makes rules and definitions more complex and prone to error, as it is easy to forget to check for units.

If this examples is now reproduced with RAs, the consumption of \corepred{\exP}{1}{1} makes the cell return $\bot$, which cannot be added into the heap -- the \PMap{} must thus removes the binding, and the postcondition can be produced properly, as the bindings of the heap is only $\{2\}$. RAs are a solution to the above problem, as they facilitate the sound construction of state models and state model transformers, by allowing unitless state models.

\subsection{List}

The \List{} state model transformer is similar to \PMap, but instead of receiving an domain $I$ as a parameter it only operates on positive integers. It allows representing a list of cells, up to a bounded size -- it can be used, for instance, to represent a block of memory, with the index serving as the offset of the base address of the block. Similarly to \PMap{}, it represents state as a finite partial map from integers to state, as well as a \emph{bound}: a strictly positive integer specifying the size of the list, and allowing one to distinguish out of bounds from $\bot$ elements.

\begin{align*}
	\List(\mmdl) &\defeq \nats \finmap \mmdl.\Sigma \times \nats^?\\
	(b,n)\cdot (b',n') &\defeq (b'', n'')\\
	\text{where } b''&\defeq \lambda i.\begin{cases}
		b(i)\cdot b'(i)&\If~i\in \dom(b)\cap\dom(b')\\
		b(i) &\If~i\in \dom(b) \backslash \dom(b')\\
		b'(i) &\If~i\in \dom(b') \backslash \dom(b)\\
		\text{undefined}&\Otherwise
	\end{cases}\\
	\text{and }n''&\defeq\begin{cases}
		n&\If~n'=\bot\\
		n'&\If~n=\bot\\
		\text{undefined}&\Otherwise
	\end{cases}\\
	\text{and }& \forall i\in\dom(b'')\ldotp 0\leq i \land (n'' = \bot \lor i < n'')\\
	|(b, n)| &\defeq \begin{cases}
		\bot &\If~\dom(b')=\emptyset\\
		(b',\bot) &\Otherwise
	\end{cases}\\
	\text{where }b'&\defeq\lambda i.\begin{cases}
		|b(i)| &\If~ i\in\dom(b) \land |b(i)| \neq \bot\\
		\text{undefined} &\Otherwise
	\end{cases}
\end{align*}

Just like in \PMap{}, all core predicates are lifted, and a \bound{} core predicate is added for the bound. It does not include an \alloc{} action -- instead, all cells are created when the list is instantiated (or taken from the specification of the executed function).

For brevity, its rules will not be outlined -- they are analogous to those of \PMap{}, with the main difference being that checks for the membership of an index in the domain set are replaced with checks for the index in the range $[0,n)$ with the bound $n$.

\subsection{General Map}

In \cite{sacha-phd}, the \PMap{} and \List{} transformers are presented as two different transformers, however they can both be merged into a single transformer quite succinctly, to prove the modularity of transformers.

We thus introduce the \emph{general map} transformer, $\GMap(I,\mmdl,\mmdl_D)$. It is built from a domain set $I$, a codomain state model $\mmdl$ and a \emph{discriminator} state model $\mmdl_D$. This last state model serves as a way to tell apart invalid accesses from $\bot$ elements -- modelling it as a state model allows us to make it more flexible on what predicates and state are used to represent it.

The discriminator state model $\mmdl_D$ must also provide a $\code{is\_within}:\mmdl_D.\St\rarr I\rarr \code{LVal}$ function. $\code{is\_within}$ returns a symbolic boolean, that evaluates to true if and only if a state fragment containing a singleton partial map with the given index could be validly composed into the state while upholding the desired GMap's invariant. A consequence of this is that when the state is a\emph{full} state, $\code{is\_within}$ is only used for out of bounds accesses (as otherwise the key is already in the map, since we're dealing with full states), and as such always returns false. If we write $\dom \st$ the domain of a GMap's map, given a set of states $\St$ with the subset of full states $\full\St\subseteq\St$, we have that $i\not\in \dom\st \land \st \in \full\St \Rarr \SAT(\neg\code{is\_within}~\st~i)$.

To replicate the usual PMap, one would have $\mmdl_D=\Ex(\pset(I))$, with $\code{is\_within}$ true if the value is in the set: $\code{is\_within}_\PMap~\st_D~i=i\in\st_D$. For List, one has $\mmdl_D=\Ex(\nats)$ with $\code{is\_within}_\List~\st_D~i=0 \leq i < \st_D$. Note here that state transformer may automatically assume the cell can exist if the key is not found in the map and the discriminator state is $\bot$ in the state tuple. Note for both of the above examples the \load{} and \store{} actions of \Ex{} should be removed, as modifying the domain set or bound directly is not sound -- the discriminator is used for the compositional state to distinguish outcomes, and \emph{does not exist in full states}, so actions to modify the discriminator directly cannot exist in the full state either. Allowing them to exist in the compositional state model would break compatibility.

\begin{align*}
	\GMap(I, \mmdl, \mmdl_D) &\defeq I \finmap \mmdl.\Sigma \times \mmdl_D.\Sigma^?\\
	(h,d)\cdot (h',d') &\defeq (h'', d'')\\
	\text{where } h''&\defeq \lambda i.\begin{cases}
		h(i)\cdot h'(i)&\If~i\in \dom(h)\cap\dom(h')\\
		h(i) &\If~i\in \dom(h) \backslash \dom(h')\\
		h'(i) &\If~i\in \dom(h') \backslash \dom(h)\\
		\text{undefined}&\Otherwise
	\end{cases}\\
	\text{and }d''&\defeq d\cdot d'\\
	\text{and }& d'' = \bot \lor (\forall i\in\dom(h'')\ldotp \code{is\_within}~d''~i)\\
	|(h, d)| &\defeq \begin{cases}
		\bot &\If~ \dom(h')=\emptyset \land d'=\bot\\
		(h',d') &\Otherwise
	\end{cases} \\
	\text{where } h' &\defeq\lambda i.\begin{cases}
		|h(i)| &\If~ i\in\dom(h) \land |h(i)| \neq \bot\\
		\text{undefined} &\Otherwise
	\end{cases} \\
	\text{and }d' &\defeq |d|
\end{align*}

We now define the rules for $\GMap(I,\mmdl,\mmdl_D)$. Its actions are only that of $\mmdl$ (not that of the discriminator state model), as explained previously; it does however inherit predicates from both. As such, $\actions = \mmdl.\actions$, and ${\Delta =\mmdl.\Delta \uplus \{\delta_D : \delta \in \mmdl_D.\Delta \}}$.

We also redefine the \code{get} and \code{set} helper functions, with \code{get} branching again. This requires lifting \code{get} to do checks using \code{is\_within} (the rest of the rule is unaffected).


We first define a helper methods \code{get} and \code{set}, that allows modifying a symbolic map with branching. After a look up, it returns the value at the location (which may be $\bot$ if it's not found), and the path condition corresponding to the branch. This allows simplifying shared rules for \execac, \produce{} and \consume{} for \PMap{}.
\begin{align*}
	\code{get}&: ((I \finmap X) \times \mmdl_D.\Sigma^?) \rarr I \rarr \pset(I \times X \times \Pc) \\
	\code{set}&: ((I \finmap X) \times \mmdl_D.\Sigma^?) \rarr I \rarr X \rarr (I \finmap X \times \mmdl_D.\Sigma^?)
\end{align*}
\begin{align*}
	\text{Given }
	\mathit{wrap}(h, d) &\defeq \begin{cases}
		\bot &\If~\dom(h)=\emptyset \land d=\bot\\
		(h,d)&\Otherwise
	\end{cases}\\
	\mathit{unwrap}(s) & \defeq \begin{cases}
		([], \bot) &\If~s=\bot\\
		(h, d) &\If~s=(h,d)
	\end{cases}\\
	\mathit{lift\_if\_miss}(o, i, \sins) &\defeq \begin{cases}
		i :: \sins &\If~o=\Miss\\
		\sins &\Otherwise
	\end{cases}
\end{align*}
\begin{mathparpagebreakable}
\inferrule[GMapGetMatch]{(h,d)=\mathit{unwrap}(s) \\ i'\in\dom(h) \\ s_{i'}=h(i')}{\ppget{s, i}{i', s_{i'}, [i=i']}}
\and\inferrule[GMapGetAdd]{(h,d)=\mathit{unwrap}(s) \\ i\notin\dom(h) \\ d\neq\bot}{\ppget{s, i}{i,\bot, [i\notin\dom(h) \land \highlight{\code{is\_within}~d~i}]}}
\and\inferrule[GMapGetBotDomain]{(h,d)=\mathit{unwrap}(s) \\ i\notin \dom(h) \\ d=\bot}{\ppget{s,i}{i,\bot,[i\notin\dom(h)]}}
\and\inferrule[GMapSetSome]{(h,d)=\mathit{unwrap}(s) \\ s_i\neq\bot \\ h'=h[i\leftarrow s_i] \\ s'=\mathit{wrap}(h', d)}{\ppset{s,i,s_i}{s'}}
\and\inferrule[GMapSetNone]{(h,d)=\mathit{unwrap}(s) \\ s_i=\bot \\ h'=h[i\not\leftarrow] \\ s'=\mathit{wrap}(h', d)}{\ppset{s,i,s_i}{s'}}
\and\inferrule[GMapAction]{\ppget{s,i}{i',s_{i'},\pc} \\ \ppexec{\alpha}{s_{i'},\sins}{o,s'_{i'},\souts,\pc'} \\ \ppset{s,i',s'_{i'}}{s'}}{\ppexec{\alpha}{s,i::\sins}{o,s',i'::\souts, \pc::\pc'}}
\and\inferrule[GMapActionOutOfBounds]{d\neq\bot}{\ppexec{\alpha}{(h,d),\sins}{\Err, s, [], [\highlight{\neg \code{is\_within}~d~i}]}}
\and\inferrule[GMapCons]{\ppget{s,i}{i',s_{i'},\pc} \\ \ppcons{s_{i'},\delta,\sins}{o,s'_{i'},\souts,\pc'} \\ \souts'=\mathit{lift\_if\_miss}(o,i',\souts) \\ \ppset{s,i',s'_{i'}}{s'}}{\ppcons{s,\delta,i::\sins}{o,s',\souts', \pc::\pc'}}
\and\inferrule[GMapConsIncompat]{d\neq\bot}{\ppcons{(h,d),\delta,i::\sins}{\LFail, (h,d), [], [\highlight{\neg \code{is\_within}~d~i}]}}
\and\inferrule[GMapConsDiscr]{\muted{(h,d)=\mathit{unwrap}(s)} \\ \ppcons{d,\delta_d,\sins}{o,d',\souts,\pc} \\ o\neq\Miss \\ \muted{s'=\mathit{wrap}(h,d')}}{\ppcons{s,\delta_D,\sins}{\Ok,s',\souts,\pc}}
\and\inferrule[GMapConsDiscrMiss]{\muted{(h,d)=\mathit{unwrap}(s)} \\ \ppcons{d,\delta_d,\sins}{o,d',\souts,\pc} \\ o=\Miss \\ \muted{s'=\mathit{wrap}(h,d')}}{\ppcons{s,\delta_D,\sins}{\Ok,s',\code{`D'}::\souts,\pc}}
\and\inferrule[GMapProd]{\ppget{s,i}{i',s_{i'},\pc} \\ \ppprod{s_{i'},\delta,\sins,\souts}{s'_{i'},\pc'} \\ \ppset{s,i',s'_{i'}}{s'}}{\ppprod{s,\delta,i::\sins,\souts}{s', \pc::\pc'}}
\and\inferrule[GMapProdDiscr]{(h,d)=\mathit{unwrap}(s) \\ \ppprod{d,\delta_D,\sins,\souts}{d',\pc}}{\ppprod{s,\delta_D,\sins,\souts}{s',\highlight{[\forall i\in\dom(h)\ldotp \code{is\_within}~d~i]} :: \pc}}
\and\inferrule[GMapFix]{\mmdl.\fix~\sins = a \\ a'=\mathit{lift}(a,i)}{\fix~i::\sins = a'}
\and\inferrule[GMapFixDiscr]{\mmdl_D.\fix~\sins = a}{\fix~\code{`D'} :: \sins = a}
\end{mathparpagebreakable}

These rules are very similar to those of \PMap, or the rules \List{} would have, only with the discriminator check instead, as well as more generic \consume, \produce{} and \fix{} rules for the discriminator. We also do not provide an \alloc{} action with \GMap, as the discriminator may need to be modified with a new index; it is up to the user to define any additional actions over it.

An example instantiation of \GMap{} is with the empty state model \textsc{Emp}, a state model that provides no actions or predicates, and that can only be $\bot$. \code{is\_within} may then always return \vtrue. This allows emulating the traditional separation logic linear heap, where one can always do allocation (this is not the case in \PMap{}, where one must own the domain set to allocate). We note that this instantiation does not uphold \ref{eq:compatibility}: any out of bounds access will result in a \Miss{}, rather that properly separating misses from errors.
