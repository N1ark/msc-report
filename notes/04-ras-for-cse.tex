\chapter{Resource Algebras for a CSE}

\section{Current State}


\subsection{CSE}

CSE and Sacha's thesis do the traditional choice of using Partial Commutative Monoids (PCMs) to model state. They are defined as the tuple $(M, (\cdot):M\times M \part M, 0)$. They are further equipped with a set of actions $\cal A$, an \execac{} function, a set of core predicates $\Delta$ and a pair of \consume{} and \produce{} functions.

These additions are necessary for the engine to be parametric on the state model, as it provides an interface for interaction with the state.

The usage of PCMs comes with issues: the requirement of a single 0 for each state model means that state models such as the sum state model $\mmdl_1 + \mmdl_2$ come with unwieldy requirements to prove soundness -- this comes into play for the \code{Freeable} memory model, that could use a sum (like what is done in \cite{iris-thesis}) but can't because of this.

\subsection{Iris}

Iris \cite{iris} departs from this tradition and introduces Resource Algebras (RAs) to model state, defined as a tuple $(M, \irisval: M\rarr \bools, |-|:M\rarr M^?, (\cdot):M\times M\rarr M)$, being respectively the state elements, a validity function, a partial core function and a composition function.

This makes Iris states more powerful, in that they have more flexibility in what they can express; for instance sum state models can be easily and soundly expressed, which isn't possible with PCMs due to the requirement of a single $0$ element.

Furthermore, Iris RAs comes with plenty proofs and properties making them easy to use and adapt, whereas PCMs can prove unwieldy even for simpler state models (eg. with the Freeable state model transformer).

A similarity however is that the global RA in Iris must be unital, meaning it must have a single $\epsilon$ element, very much as it is the case with the 0 in PCMs. Any RA can be trivially extended to have a unit, which is what Iris defines as the option resource algebra \cite{iris-option}.

\section{Partial RAs}

A property of Iris RAs is that composition is \emph{total} -- to take into account invalid composition, states are usually extended with a $\lightning$ state, such that $\neg \irisval(\lightning)$ (while for states $\st\neq\lightning$, $\irisval(\st)$ holds). While this is needed in the Iris framework for higher-order ghost state and step-index, this doesn't come into play when only manipulating RAs. As such, because this is quite unwieldy, we can remove it by adding partiality instead, such that invalid ($\lightning$) states simply don't exist and the need for a $\irisval$ function vanishes. This is also inline with the core function $(-)$ being partial.

It is worth noting that \emph{partial} RAs are equivalent to regular RAs, \emph{so long as $\irisval$ always holds for valid states}\footnote{This, to our knowledge, is the case for all of the simpler RAs defined in Iris: Ex, Ag${}_0$, sum, product, etc.}. Indeed, compositions that yield $\lightning$ can be made undefined, and the validity function removed, to gain partiality, and inversely to go back to the Iris definition.

An interesting property of this is that because validity is replaced by the fact composition is defined, the validity of a composition is equivalent to the fact two states are disjoint: $\irisval(a\cdot b) \iff a \# b$.

We now define the properties of RAs taking this change into account -- see \autoref{fig:ra-def}. From now, the term RA will be used to refer to these partial RAs.
\begin{figure}
A \emph{resource algebra} (RA) is a triple $(M, |\!-\!|: M\rarr M^?, (\cdot): M\times M \part M)$

\begin{align}
	\tag{RA-Assoc} \forall a,b,c&\ldotp (a\cdot b)\cdot c = a\cdot (b\cdot c)\\
	\tag{RA-Comm} \forall a,b&\ldotp a\cdot b = b\cdot a\\
	\tag{RA-Core-ID} \forall a&\ldotp |a| \in M \Rarr |a|\cdot a = a\\
	\tag{RA-Core-Idem} \forall a&\ldotp |a|\in M\Rarr ||a|| = |a|\\
	\tag{RA-Core-Mono} \forall a,b&\ldotp |a|\in M\land a\preo b \Rarr |b| \in M \land |a| \preo |b|
\end{align}
\begin{align*}
	\text{where}\qquad
	M^? &\defeq M \uplus \{\bot\}\text{, with }a\cdot \bot \defeq \bot\cdot a\defeq \bot\\
	a \preo b &\defeq \exists c\ldotp b = a\cdot c\\
	a\disj b &\defeq a \cdot b \text{ is defined}
\end{align*}
A \emph{unital} resource algebra is a resource algebra $M$ with an element $\epsilon\in M$ such that:
\begin{align*}
	\forall a\in M. \epsilon\cdot a = a&&
	|\epsilon|=\epsilon
\end{align*}
\caption{Definition of Resource Algebras}
\label{fig:ra-def}
\end{figure}

\section{CSE State Models + RAs}

We now propose to redefine the notion of state models. To follow the spirit of CSE, that comes with a core engine, a compositional engine and a bi-abduction engine all built onto each other, we go through each layer, presenting what is for that part of the engine to function.

\subsection{Core Engine}

\newcommand{\vallist}[0]{\Val~\code{list}}

The core engine enables whole-program symbolic execution. For this state models must firstly define the set of states the execution will happen on; this is done via a partial resource algebra: a tuple  $(M, |\!-\!|:M\rarr M^?,(\cdot):M\times M\part M)$. They are further equipped with a set of actions $\cal A$, and an \execac{} function.
\begin{align*}
	\execac &: \pset(\code{SVar})\rarr \Sst^? \rarr {\cal A} \rarr \vallist \rarr \pset(\full\outcomes_e \times \Sst^? \times \vallist \times \Pc)
\end{align*}
The arguments of \execac{} are, in order: the set of existing symbolic variables (this allows the state model to generate fresh variables, for instance in allocation), the \emph{optional} state the action is executed on, the action, and the received arguments. It returns a set of branches, with an outcome, the new state, the returned values, and the path condition of that branch. It is pretty-printed as \ppexec{\alpha}{SV, \sst,\sins, o}{\sst', \souts, \pc}, with $SV$ omitted when not necessary.

Here, the outcome is an outcome in the set of \emph{full execution outcomes} $\full\outcomes_e=\{ \Ok,\Err \}$. In the next subsection, this set will be extended to account for misses and logical failures, but these do not exist with full semantics.

The main difference here is that the state may be $\bot$, if the action is executed on empty state. This ensures non-unital RAs are not ruled out as invalid -- indeed, many useful RAs are not unital and sometimes don't have a unit at all, as is the case for instance for \Ex, the exclusively owned cell. One could decide to internally make all RAs of state models unital, and have the state model provide an \code{empty} function that returns said unit (this is what happens in Gillian). However this introduces unsoundness to certain state model constructions (in particular the sum), as this means the state cannot be \emph{exclusively owned} -- the empty state could always be composed with it.

Whole-program symbolic execution is, by definition, non-compositional -- it thus operates on \emph{full state}, a notion introduced in \cite{sacha-phd}. As such, the only valid outcomes here are \Ok{} and \Err{}.

Because we operate in symbolic memory, an additional piece of information is the \emph{path condition}, the set of constraints accumulated throughout execution. A path condition $\pc\in\Pc$ is a \emph{list} of symbolic values, that evalutes to a boolean. We decide to define it as a list rather than a single conjunction of boolean symbolic values, as this allows us to easily check if a path condition is an extension (or a strengthening) of another, with $\pc'\supseteq\pc$.

\subsection{Compositional Engine}

The compositional engine, built on top of the core engine, allows for verification of function specifications, and handles calling functions by their specification. As such, the state model must be extended with a set of core predicates $\Delta$ and a pair of \consume{} and \produce{} functions (equivalent, respectively, to a symbolic assert and assume). Finally, to link core predicates to states, it provides a $\code{sat}_\Delta$ relation.
\begin{align*}
	\text{for }M=\{\code{OX}, \code{UX}\}\\
	\consume &: M\rarr \Sst^? \rarr \Delta \rarr \vallist \rarr \pset(\outcomes_l \times \Sst^? \times \vallist \times \Pc) \\
	\produce &: \Sst^? \rarr \Delta \rarr \vallist \rarr \vallist \rarr \pset(\Sst^? \times \Pc)\\
	\code{sat}_\Delta &:\St \rarr \Delta \rarr \vallist \rarr \pset(\vallist)
\end{align*}
Similarly to \execac, the input state can be $\bot$. While intuitively one may assume that the input state of \consume{} and the output state of \produce{} may never be $\bot$, this would limit what core predicates can do. In particular, this means an $\emp$ predicate couldn't be defined, since it's production on an empty state results in an empty state.

The arguments of \consume{} are, in order: the mode of execution to distinguish between under-approximate and over-approximate reasoning, the state, the core predicate being consumed, the ins of the predicate. It outputs a \emph{logical outcome}, the state with the matching predicate removed (which may result in an empty state $\bot$), the outs of the predicate and the associated path condition. It is pretty-printed as \ppcons{m,\sst,\delta,\sins}{o, \sst_f, \souts, \pc}, and when the consumption is valid in both OX and UX the mode is omitted.

For \produce{}, the arguments are the state, the core predicate being produced, the ins and the outs of the predicate, resulting in a set of new states and their associated path condition. As an example, producing $x \mapsto 0$ in a state $[1 \mapsto 2]$ results in a new state $[1\mapsto 2, x \mapsto 0]$ with the path condition $x \neq 1$. If the produced predicate is incompatible with the state (eg. by producing $1 \mapsto y$ in a state containing $1 \mapsto x$), the producer \emph{vanishes}. Inversely, if the assertion can be interpreted in several ways, the producer may branch. It is pretty-printed as $\ppprod{\sst,\delta,\sins,\souts}{\sst', \pc}$.

The \code{sat} relation relates a \emph{concrete} state, core predicate and in-values to a set of out-values. It is pretty-printed as $\st \models_\Delta \corepred{\delta}{\ins}{\outs}$. For instance in the linear heap state model, we have $[ 1 \mapsto 2 ] \models_\Delta \corepred{\code{points\_to}}{1}{2}$.

Here we define logical outcomes $\outcomes_l = \{\Ok, \LFail, \Miss \}$. These are outcomes that happen during reasoning; in particular, \LFail{} equates to a logical failure due to an incompatibility between the consumed predicate and the state. For instance, consuming $1 \mapsto 1$ when in state $1 \mapsto 2$ would yield a \LFail{}, while consuming it in state $5 \mapsto 3$ would yield a \Miss{}, as a state $1\mapsto x$ could be composed with it to yield a non-miss outcome.

We must also modify the signature of \execac, to include \Miss{} outcomes, via the set of execution outcomes $\outcomes_e=\{\Ok,\Err,\Miss\}$.

An addition to what CSE previously defined is thus the split of what was the \code{Abort} outcome into \LFail{} and \Miss{}, this improves the quality of error messages and allows fixing consumption errors due to missing state -- this will be described in the next subsection.

A last change compared to CSE is that we drop the path condition parameter to consume and produce -- the function instead directly returns the path condition required for the resulting branches, and the engine can filter these. For instance, in UX all consumption branches that result in \LFail{} can be dropped, as dropping branches is allowed in UX. This has the advantage of simplifying the axioms, as the path condition is strengthened by definition; the function itself has no way of weakening it.

\subsection{Bi-abduction Engine}

To support bi-abduction in the style of Infer:Pulse \cite{pulse}, \Miss{} outcomes must be fixed. These outcomes may happen during consumption or during action execution. For this, the state model must provide a \fix{} function, that given the details of a miss error (these details being of type \Val{} and returned with the outcome) returns a list of sets of assertions that must be produced to fix the missing error.
\begin{align*}
	\fix &: \Val \rarr \pset(\text{Asrt}) ~\code{list}
\end{align*}
Note here we return a \emph{list} of different fixes, which themselves are a set of assertions -- this is because, for a given missing error, multiple fixes may be possible which causes branching. For instance, in the typical linear heap, accessing a cell that is not in the state fragment at address $a$ results in a miss that has two fixes: either the cell exists and points to some existentially quantified variable (the fix is thus $\exists x\ldotp a \mapsto x$), or the cell exists and has been freed ($a\mapsto\varnothing$).

This approach is different from how Gillian handles it. There the function \fix{} returns \emph{pure} assertions (type information, pure formulae) and arbitrary values of type \code{fix\_t}, which can then be used with the $\code{apply\_fix}:\Sigma \rarr \code{fix\_t} \rarr \Sigma$ method of the monadic state. This means fixes can be arbitrary modifications to the state that don't necessarily equate to new assertions to add to the anti-frame.

This is a source of unsoundness, as the engine may interpret these modifications as fixes despite them not reliably modifying the state. This can be seen in \cite{sacha-phd}, where not finding the binding in a PMap(X) returns a \code{MissingBinding} error. While being labelled as a miss, this error can actually not be fixed; PMap simply \emph{lifts} predicates with an additional in parameter for the index. An implementation of that version of PMap(X) could attempt to fix this state by add a binding to $X.0$ (PMaps were originally made for PCMs, which always have a 0 element), which would then eventually lead to another error once the action gets called on the empty state. On top of being under-performing (as several fixes would need to be generated for one action), this requires PMap(X) to allow empty states in the codomain, which means a PMap is never exclusively owned (as a state with a singleton map to $X.0$ can always be composed with it), which limits its usability; aside from not being modelable using RAs, since $\bot$ is not an element of X's carrier set. Finally, if the underlying state model doesn't provide any additional fixes, then the fix for \code{MissingBinding} cannot be added to the UX specification of a function: there is no assertion generatable from within PMap to represent this modification. As such, having \fix{} returns assertions without modifying any state directly ensures fixes are always soundly handled.

To finish this, we may note the solution to the above bug is to proceed executing the action on the underlying state model, giving it an empty state -- it will then raise the appropriate \Miss{}, which can be fixed, as it is aware of what core predicates are needed to create the required state. For instance, for PMap(Exc) a \code{load} action on a missing binding would be executed against $\bot$, which would return a \code{MissingValue} error. The PMap could then wrap the error with information about the index at which the error occurred, $\code{SubError}(i, \code{MissingValue})$. When getting the fix, PMap can then call Exc.\fix, which returns $\exists x\ldotp \corepred{points\_to}{}{x}$, and lift the fix by adding the index as an in-argument, resulting in the final fix $\exists x\ldotp\corepred{points\_to}{i}{x}$, which is a valid assertion and can be added to the UX specification for this execution.

\subsection{Axioms}

We may now go over the axioms that must be respected by the above defined functions for the soundness of the engine. Note we will thus focus on the axioms related to the state models in particular, and not the general semantics of the engine.

First, it is worth noting that Gillian supports both over-approximate (OX) and under-approximate (UX) reasoning -- for which \emph{frame subtraction} or \emph{frame addition} must hold, respectively. In addition to the axioms in \cite{cse1} and the upcoming paper on an Abstract CSE, we also take inspiration from \cite{sacha-phd} and include the notion of \emph{compatibility}, linking full states to compositional states, as well as concrete states to symbolic states.

Indeed there are two orthogonal concepts at play: one is \emph{compositionality}, that introduces \consume{} and \produce{}, frame addition and subtraction, and ultimately compatibility. The other is \emph{symbolicness}, that introduces soundness and the $\vDash$ relation for symbolic state modelling. To simplify the axioms, we will only consider the symbolic compositional case, as it is a superset of the other cases.

For all of the axioms we assume we have a symbolic state model $\mmdl$, made of the RA $\Sst \ni \sst$. We consider the initial state $\sst$ well-formed.%, and a satisfiable path condition $\pc$.

\subsubsection{Symbolicness Axioms \note{\footnotesize a nicer name would be good}}

\begin{equation}
\tag{Empty Symbolic Memory}\label{eq:empty-sym-mem}
\theta,s,\st\models \bot_{\Sst^?} \implies \st = \bot_{\St^?}
\end{equation}

\begin{equation}
\tag{Empty Memory}\label{eq:empty-mem}
\theta,s,\bot_{\St^?}\models \bot_{\Sst^?}
\end{equation}

Note that here we work with the \emph{option} version $\St^?$ of the states $\St$, which extends the carrier set with a $\bot_{\St^?}$ element. If the core of a state $|\st|$ is undefined, it becomes $|\st^?|=\bot_{\St^?}$. Finally, the composition of any state with $\bot_{\St^?}$ is that state.

\begin{equation}
\tag{Symbolic Memory Composition}\label{eq:symbolic-mem-comp}
\begin{array}{l}
\theta,s,\st_1\models \sst_1 \land \theta,s,\st_2\models \sst_2 \land \st_1\#\st_2 \iff \theta,s,(\st_1\cdot\st_2)\models (\sst_1\cdot\sst_2)
\end{array}
\end{equation}

\begin{equation}
\tag{Memory Model OX Soundness}\label{eq:mem-ox-soundness}
\begin{array}{l}
\theta,s,\st\models\sst \land \ppexec{\alpha}{\st,\ins}{o,\st',\outs} \implies \exists \SV, \sins,\souts,\sst',\pc,\theta'\ldotp\\
\quad \ppexec{\hat\alpha}{\SV, \sst,\sins}{o,\sst',\pc,\souts} \land \SAT(\pc) \land \theta',s,\st'\models \sst' \land\\
\qquad \expeval{\sins}_{s,\pc}=(\ins,\pc')\land\expeval{\souts}_{s,\pc'}=(\souts,\pc'')
\end{array}
\end{equation}

\begin{equation}
\tag{Memory Model UX Soundness}\label{eq:mem-ux-soundness}
\begin{array}{l}
\ppexec{\hat\alpha}{\SV,\sst,\sins}{o,\sst',\pc,\souts} \land \SAT(\pc) \land \theta,s,\st'\models\sst' \land \\
\expeval{\souts}_{\hat s,\pc}\rightsquigarrow(\outs,\pc')\land \expeval{\sins}_{\hat s,\pc'}\rightsquigarrow(\ins,\pc'')\implies\\
\quad \exists \st\ldotp \theta,s,\st\models\sst \land \ppexec{\alpha}{\st,\ins}{o,\st',\outs}
\end{array}
\end{equation}

\subsubsection{Compositionality Axioms}

\begin{equation}
\tag{Frame subtraction}\label{eq:frame-sub}
\begin{array}{l}
\ppexec{\alpha}{\sst\cdot\sst_f,\sins}{o, \sst',\souts,\pc'} \implies \\
\quad\exists \sst'', o', \souts'\ldotp \ppexec{\alpha}{\sst,\sins}{o', \sst'', \souts', \pc''} ~\land \\
\qquad(o' \neq \Miss \implies o' = o \land  \souts' = \souts \land \sst' = \sst'' \cdot \sst_f \land \pc'' = \pc')
\end{array}
\end{equation}

\begin{equation}
\tag{Frame Addition}\label{eq:frame-add}
\begin{array}{l}
\ppexec{\alpha}{\sst,\sins}{o, \sst', \souts, \pc'} \land o \neq \Miss \land \sst'\#\sst_f\implies\\
\quad\sst \# \sst_f \land \ppexec{\alpha}{\sst\cdot\sst_f, \sins}{o, \sst'\cdot\sst_f, \souts, \pc'}
\end{array}
\end{equation}

Here, we may note that the frame-preserving update $a \rightsquigarrow b$ from Iris is a form of frame subtraction: it guarantees $\forall c\ldotp \irisval(a \cdot c)\Rarr \irisval(b\cdot c)$, with $c$ a frame that can be added to the state ($\sst_f$ in the axiom). This becomes evident when noticing that disjointness of partial RAs equates to validity in Iris RAs, giving us $\forall c\ldotp a\# c\Rarr b\# c$. In fact, the Iris frame-preserving update implies frame subtraction modulo action outcomes. This makes sense, as Iris is used for OX reasoning, and frame subtraction is the property needed for OX soundness. \note{Maybe move this elsewhere.}

Given the full state model $\full{\mmdl}$ with the states $\full\Sst$ and actions $\full\actions$ and the compositional state model $\mmdl$ with the states $\Sst\supseteq\full\Sst$ and actions $\actions$, $\Sst$ is the set of fragments of $\full\Sst$ if ${\forall \sst\in\Sst\ldotp \exists\full\sst\in\full\Sst\ldotp \sst\preo\full\sst}$ (completion), and ${\forall\full\sst_1,\full\sst_2\in\full\Sst\ldotp \full\sst_1\preo\full\sst_2 \implies \full\sst_1=\full\sst_2}$ (inextensibility).  These two state models are compositional, denoted $\full\mmdl \tilde \mmdl$ if all actions of full states using compositional semantics have the same result as using the full semantics.

\begin{equation}
\tag{Compatibility}\label{eq:compatibility}
\begin{array}{l}
\ppexec{\full\alpha}{\full\sst, \sins}{o,\full\sst',\souts,\pc} \iff
\ppexec{\alpha}{\full\sst, \sins}{o,\full\sst',\souts,\pc}
\end{array}
\end{equation}

Note here that we do not consider compatibility of the semantics of the language, but rather only the compatibility of the actions of the state models -- it is assumed the compatibility of the full semantics follow from it.

\note{Does the above make sense? Sacha originally defined compatibility for concrete states, but I should be able to be lifted to symbolic states anyways... I just would want to handle compositionality/symbolicness independently, otherwise I imagine I need to then lift all compositional concrete axioms to compositional symbolic...}

\begin{equation}
\tag{Consume Soundness and Completeness}\label{eq:consume-sound-complete}
\begin{array}{l}
\ppcons{\sst,\delta,\sins}{\Ok,\sst_f,\souts,\pc_f} \implies\\
\quad\exists \sst_\delta\ldotp \sst=\sst_f\cdot\sst_\delta\land (\forall\theta,s,\st,\ins,\outs\ldotp \\
\qquad (\theta(\pc\land\pc_f)=\vtrue \land \expeval{\sins}_{\theta,s} = \ins \land \expeval{\souts}_{\theta,s}=\outs) \implies\\
\quad\qquad \theta,s,\st\models \sst_\delta \Leftrightarrow \st \models_\Delta \corepred{\delta}{\ins}{\outs})
\end{array}
\end{equation}

\begin{equation}
\tag{Consume OX: No Path Drops}\label{eq:consume-ox-no-drop}
\begin{array}{l}
(\forall o, \sst'\pc'\ldotp \ppcons{OX,\st,\delta,\sins}{o_c, \souts, \pc'}\Rarr o_c = \Ok)\land \theta, s, \st \models \sst \implies \\
\quad \exists  \sst', \pc', \st'\ldotp \ppcons{OX, \sst, \delta,\ins,\pc}{\Ok, \sst', \souts, \pc'} \land \theta,s,\st' \models \sst'
\end{array}
\end{equation}
\note{Because the outcome $o_c$ can be \LFail{} or \Miss{}, I changed the axiom from having $o_c\neq \code{Abort}$ to $o_c=\Ok$. Should be fine?}

\begin{equation}
\tag{Produce: Soundness}\label{eq:produce-sound}
\begin{array}{l}
\ppprod{\sst_f,\delta,\sins,\souts}{\sst, \pc_f} \implies\\
\exists \sst_\delta\ldotp \sst=\sst_\delta\cdot\sst_f \land (\forall\theta,s,\st_\delta\ldotp\\
\quad \theta(\pc\land\pc_f)=\vtrue \Rarr \expeval{\sins}_{\theta,s}=\ins \Rarr \expeval{\souts}_{\theta,s}=\outs \Rarr \\
\quad \theta,s,\st_\delta \models \sst_\delta \Rarr \st_\delta\models_\Delta\corepred{\delta}{\ins}{\outs})
\end{array}
\end{equation}

\begin{equation}
\tag{Produce: Completeness}\label{eq:produce-complete}
\begin{array}{l}
\expeval{\sins}_{\theta,s}=\ins \land \expeval{\souts}_{\theta,s}=\outs~\land \theta,s,\st\models\sst \land \st_\delta \models_\Delta \corepred{\delta}{\ins}{\outs} \land \st \# \st_\delta \implies\\
\quad \exists\sst_\delta,\pc_f\ldotp \ppprod{\sst,\delta,\sins,\souts}{\sst\cdot\sst_\delta,\pc_f} \land \theta(\pc_f) = \vtrue  \land \theta,s,\st_\delta\models\sst_\delta
\end{array}
\end{equation}

%\section{Full States}
%
%In Sacha-Ã‰lie Ayoun's thesis \cite{sacha-phd}, the notion of \emph{full states} is introduced, as an additional step between different abstractions of states. This is distinct from previous works, that only considered compositional (concrete) and (compositional) symbolic states; the full (concrete) state is by definition not compositional and represents how the program actually runs.
%
%This addition comes with constraints, most notably that compositional states can be completed into full states \ref{eq:state-complet}, and full states are inextensible \ref{eq:state-inext}.
%
%\begin{figure}[H]
%	Given the RA $(\St, |\!-\!|, (\cdot))$ and $\full\St\subseteq\St$, $\full\St$ is the set of full elements of $\St$ and $\St$ is the set of fragments of $\full\St$ if:
%	\begin{align}
%		\tag{State-Comp}
%		\label{eq:state-complet}
%		\forall \st\in\St\ldotp\exists\full\st\in\full\St&\ldotp a\preo \full\st\\
%		\tag{State-Inext}
%		\label{eq:state-inext}
%		\forall \full\st_1,\full\st_2\in\full\St&\ldotp \full\st_1\preo \full\st_2 \Rarr \full\st_1=\full\st_2
%	\end{align}
%	\caption{Definition of full and partial state}
%\end{figure}
%
%Furthermore, the existance of compositional state implies the \Miss{} outcome, meaning the state can be completed with another state fragment to give a non \Miss{} outcome. Compositional semantics are compatible with full semantics if evaluation on full states with compositional semantics is equivalent to evaluation with full semantics.
%
%For particular constructions such as PMaps and Lists however, this is done by adding a domain set or bound, respectively, to the compositional state -- on action execution on a cell that is not in the partial state, one can thus check whether the cell is simply not in this fragment of the state (resulting in a \Miss) or if the cell does not exist (resulting in an \Err). Without such additional information, the compositional semantics would need to resort to always evaluating to \Err{}, or to \Miss{} -- the former breaks frame subtraction and addition making the state unsound, the latter means \Miss{} outcomes leak into full semantics.
%
%A PMap over a state model $\St$ with a sort $I$ is defined as $I \finmap \St \times \pset(I)$, with $\pset(I)$ the domain set as discussed above that is exclusively owned. Similarly, a List state model over $\St$ is defined as $\nats\finmap\St\times\nats$, with the second element of the product the exclusively owned bound (or size) of the list. While both states use the notion of a mapping $I \finmap \St$, this wouldn't form a valid state model, because as explained above the semantics would not be able to distinguish \Err{} from \Miss{} outcomes. This is a source of discomfort, as it goes against the idea of being able to soundly construct complex state models from simpler blocks -- one would need to redefine mappings for every such structure. Similarly, the product both state transformers use also exists as a state model, and both domain set and bound are exclusively owned and could be modelled with Exclusive, but aren't. Furthermore, Iris already defines finite partial maps, so we know these form valid RAs, but they do not form sound state models \emph{when full states are considered}.

%While one could accept this and redefine the state models to make up for this difference, much work would need to be redone, and one would need to pass on the rich theory that already exists in Iris. We may note this difficulty comes from the unification of state models and the RAs (or PCMs, in previous works) that back them.
%
%We may introduce a split between RAs, that can be used for reasoning about the state just like in Iris, and fully fledged state models, that must also provides actions, core predicates and must be compatibile with the full state. By doing so, one can enjoy the constructions pre-existing in Iris, while enhancing them with actions and predicates when needed to form state models. A valid RA must satisfy the properties described in \autoref{fig:ra-def} (such that all RAs defined in Iris work), while a valid state model must both have a valid RA and come with \consume, \produce{} and \execac{} functions that are sound with regards to the backing RA. This idea is also inline with the goal of Iris and that was mentionned in \cite{next700seplogics}, where one full separation logic can be used without needing to reinvent the wheel at each inconvenience.

\section{RAs and State Models}

We now define the state transformers defined in \cite{sacha-phd}, taking advantage of RAs. We will first define the ``leaf'' state models: the state models that are don't take any state model as input, \Ex, \Ag{} and \Frac. We will then look at 3 simple transformer state models, \Sum, \Product{} and \PProduct{}. Finally, we will discuss more complex state models, with \Freeable, \PMap{} and \List.

\subsection{Exclusive}

The exclusive state model \Ex{}(\Val) is a simple state model, that represent exclusively owned cells: the cell can can only be owned once, and cannot be composed with any other cell. It is parametric on the values it stores -- for the traditional symbolic execution cell, this would be \code{Sval}. When clear from context, the type of values is omitted. It's RA is defined as: \begin{align*}
 	\Ex(X) &\defeq	\ex{x: X}\\
 	|\ex{x}| &\defeq \bot\\
 	\ex{x_1} \cdot \ex{x_2}&~\text{is always undefined}
 \end{align*}
 Note that the above definition is identical to that in Iris \cite{iris}, showing that little to no modification is needed to adapt RAs to state models.

It defines two actions, $\actions=\{\load, \store\}$ and a predicate $\preds=\{\exP\}$  We now define the functions for the state model: \execac, \produce, \consume{} and \fix.
\begin{mathpar}
\inferrule[ExLoadOk]{}{\ppexec{\load}{\ex{x},[]}{\Ok,\ex{x},[x],[]}}
\and\inferrule[ExLoadMiss]{}{\ppexec{\load}{\bot,[]}{\Miss, \ex{x},[], []}}
\and\inferrule[ExStoreOk]{}{\ppexec{\store}{\ex{x}, [x']}{\Ok, \ex{x'}, [], []}}
\and\inferrule[ExStoreMiss]{}{\ppexec{\store}{\bot,[x']}{\Miss,\ex{x},[],[]}}
\and\inferrule[ExConsOk]{}{\ppcons{\ex{x}, \exP, []}{\Ok, \bot, [x], []}}
\and\inferrule[ExConsMiss]{}{\ppcons{\bot,\exP, []}{\Miss, \bot, [], []}}
\and\inferrule[ExProd]{}{\ppprod{\bot,\exP, [], [x]}{\ex{x}, []}}
\and\inferrule[ExFix]{}{\fix ~[] = [\{ \exists x\ldotp \corepred{\exP}{}{x} \}]}
\end{mathpar}

\subsection{Agreement}

The agreement state model \Ag{}(\Val) is the state model to represent an agreement algebra (sometimes referred to as \emph{knowledge} in the literature \cite{higherorderseplogic}): information that can be duplicated. \begin{align*}
	\Ag(X) &\defeq \ag{x: X}\\
	|\ag{x}| &\defeq \ag{x}\\
	\ag{x} \cdot \ag{x'} &\defeq \begin{cases}
 	\ag{x} &\If~x = x' \\
 	\text{undefined} &\Otherwise
 \end{cases}
\end{align*}
Again, this definition is identical to the one of $\Ag_0$ in Iris (the non-step-indexed version of agreement).

Because knowledge is duplicable, it cannot be modified: indeed, one would need to modify all instances of the knowledge to ensure frame preservation still holds. Its actions are thus $\actions=\{\load\}$, and it has one predicate, $\Delta=\{\agP\}$.
\begin{mathpar}
\inferrule[AgLoadOk]{}{\ppexec{\load}{\ag{x},[]}{\Ok,\ag{x},[x],[]}}
\and\inferrule[AgLoadMiss]{}{\ppexec{\load}{\bot,[]}{\Miss,\bot,[],[]}}
\and\inferrule[AgConsOk]{}{\ppcons{\ag{x},\agP,[]}{\Ok,\ag{x},[x],[]}}
\and\inferrule[AgConsMiss]{}{\ppcons{\bot,\agP,[]}{\Miss,\bot,[][]}}
\and\inferrule[AgProdBot]{}{\ppprod{\bot,\agP,[],[x]}{\ag{x}, []}}
\and\inferrule[AgProdEq]{}{\ppprod{\ag{x},\agP,[],[x']}{\ag{x}, [x = x']}}
\and\inferrule[AgFix]{}{\fix~[] = [\{\exists x\ldotp \corepred{\agP}{}{x}\}]}
\end{mathpar}

\subsection{Fractional}

The fractional state model \Frac(\Val) is used to handle \emph{fractional permissions} \cite{fracpermissions,fracpermissions2}. This allows a cell to be partly owned and its information shared, for instance in multithreading. This is done by pairing every value with a fraction $0<q\leq 1$, and ensuring the value can only be modified if we own the entire value (ie. $q=1$). \begin{align*}
	\Frac(X)&\defeq \fracc{x: X, q: (0;1]}\\
	|\fracc{x, q}| &\defeq \bot\\
	\fracc{x,q}\cdot\fracc{x',q'}&\defeq \begin{cases}
		\fracc{x,q+q'} & \If~ x=x' \land q+q' \leq 1\\
		\text{undefined} &\Otherwise
	\end{cases}
\end{align*}
We may note this definition is different from that in Iris, that chooses to define the fractional state model as $\textsc{Frac} \times \textsc{Ag}_0(\Val)$, where \Frac{} is the RA for strictly positive rationals. This work in their case, because they can define actions for any state model easily, so they can define \load{} for the product having knowledge of the underlying state models. However, because the state models presented here are aimed at being reused in a variety of contexts while minimising the need for defining new actions and predicates, using their approach would hurt usability, as the \load{} action would need to be redefined for this specific instantiation of the product. Furthermore, this construction would yield two predicates: \agP{} and \fracP{}, making its use unpractical.

We instead define the actions $\actions=\{\load,\store\}$ and the core predicate $\Delta=\{\fracP\}$ as follows:
\begin{mathpar}
\inferrule[FracLoadOk]{}{\ppexec{\load}{\fracc{x,q},[]}{\Ok,\fracc{x,q},[x],[],[]}}
\and\inferrule[FracLoadMiss]{}{\ppexec{\load}{\bot,[]}{\Miss,\bot,[1],[]}}
\and\inferrule[FracStoreOk]{}{\ppexec{\store}{\fracc{x,q},[x']}{\Ok,\fracc{x',q},[],[q=1]}}
\and\inferrule[FracStorePerm]{}{\ppexec{\store}{\fracc{x,q},[x']}{\Miss,\fracc{x,q},[1-q],[q<1]}}
\and\inferrule[FracStoreMiss]{}{\ppexec{\store}{\bot,[x']}{\Miss,\bot,[1],[]}}
\and\inferrule[FracConsAll]{}{\ppcons{\fracc{x,q},\fracP,[q']}{\Ok,\bot,[x],[q=q']}}
\and\inferrule[FracConsSome]{}{\ppcons{\fracc{x,q},\fracP,[q']}{\Ok,\fracc{x,q-q'},[x],[0 < q' < q]}}
\and\inferrule[FracConsMiss]{}{\ppcons{\fracc{x,q},\fracP,[q']}{\Miss,\fracc{x,q},[q' - q],[q < q' \leq 1]}}
\and\inferrule[FracConsFail]{}{\ppcons{\fracc{x,q},\fracP,[q']}{\LFail,\fracc{x,q},[],[q' \leq 0 \lor 1 < q']}}
\and\inferrule[FracProdBot]{}{\ppprod{\bot,\fracP,[q],[x]}{\fracc{x,q},[0 < q \leq 1]}}
\and\inferrule[FracProdEq]{}{\ppprod{\fracc{x,q},\fracP,[q'],[x']}{\fracc{x,q+q'},[x=x' \land 0<q' \land q+q' \leq 1]}}
\and\inferrule[FracFix]{}{\fix~[q] = [\{ \exists x. \corepred{\fracP}{q}{x} \}]}
\end{mathpar}

Here we note that the fraction part of the state is an in-parameter, whereas the value is an out-parameter. This allows one to explicitly specify the required fraction of the state that is consumed.

\subsection{Sum}

The sum of two state models, denoted $\mmdl_1 + \mmdl_2$, represents all states that are in either one of the two states. Sums are one of the reasons for which the $0$ of PCMs was removed, in favour of the core, as it allows both sides of the sum to have a different unit (if any). We re-use the definition of sum from Iris. \begin{align*}
	\Sum(X, Y) \defeq X+Y &\defeq l(x: X) ~|~ r(y: Y)\\
	l(x)\cdot l(x') &\defeq l(x\cdot x')\\
	r(y)\cdot r(y')&\defeq r(y\cdot y')\\
	|l(x)|&\defeq \begin{cases}
 		\bot &\If~ |x|=\bot\\
 		l(|x|) &\Otherwise
	 \end{cases}\\
	 |r(y)|&\defeq \begin{cases}
 		\bot &\If~ |y|=\bot\\
 		r(|y|) &\Otherwise
	 \end{cases}
\end{align*}

Similarly for the actions and predicates, we simply re-use the underlying function. The actions are defined as ${\actions = \{\alpha_l : \alpha \in \mmdl_1.\actions \} \uplus \{\alpha_r : \alpha \in \mmdl_2.\actions \}}$, and the core predicates ${\Delta = \{\delta_l : \delta \in \mmdl_1.\Delta \} \uplus \{\delta_r : \delta \in \mmdl_2.\Delta \}}$.
\begin{align*}
	\text{Given }
	\mathit{wrap}_l(x) = \begin{cases}
		\bot &\If~x=\bot\\
	 	l(x)&\Otherwise
	 \end{cases} \text{ and }
	 \mathit{unwrap}_l(x_l) = \begin{cases}
 		\bot &\If ~x=\bot\\
 		x_l &\If~x=l(x_l)\\
 		\text{undefined}&\Otherwise
	 \end{cases}
\end{align*}
\begin{mathparpagebreakable}
\inferrule[SumLAction]{x=\mathit{unwrap}_l(x_l) \\ \ppexec{\alpha}{x,\sins}{o,x',\souts,\pc} \\ x_l' = \mathit{wrap}_l(x') \\ o \neq \Miss}{\ppexec{\alpha_l}{x_l,\sins}{o,x_l',\souts,\pc}}
\and\inferrule[SumLActionMiss]{x=\mathit{unwrap}_l(x_l) \\ \ppexec{\alpha}{x,\sins}{o,x',\souts,\pc} \\ x_l' = \mathit{wrap}_l(x') \\ o = \Miss}{\ppexec{\alpha_l}{x_l,\sins}{o,x_l',\code{`l'::}\souts,\pc}}
\and\inferrule[SumLActionIncompat]{}{\ppexec{\alpha_l}{r(y),\sins}{\Err,r(y),[],[]}}
\and\inferrule[SumLCons]{x=\mathit{unwrap}_l(x_l) \\ \ppcons{x,\delta_l,\sins}{o,x',\souts,\pc} \\ x_l' = \mathit{wrap}_l(x') \\ o \neq \Miss}{\ppcons{x_l,\delta_l,\sins}{o,x_l',\souts,\pc}}
\and\inferrule[SumLConsMiss]{x=\mathit{unwrap}_l(x_l) \\ \ppcons{x,\delta_l,\sins}{o,x',\souts,\pc} \\ x_l' = \mathit{wrap}_l(x') \\ o = \Miss}{\ppcons{x_l,\delta_l,\sins}{o,x_l',\code{`l'::}\souts,\pc}}
\and\inferrule[SumLConsIncompat]{}{\ppcons{r(y),\delta_l,\sins}{\LFail,r(y),[],[]}}
\and\inferrule[SumLProd]{x=\mathit{unwrap}_l(x_l) \\ \ppprod{x,\delta_l,\sins}{x',\pc} \\ x_l'=\mathit{wrap}_l(x')}{\ppprod{x_l,\delta_l,\sins}{x_l',\pc}}
\and\inferrule[SumLProdIncompat]{}{\ppcons{r(y),\delta_l,\sins}{r(y),[\vfalse]}}
\and\inferrule[SumLFix]{\mmdl_1.\fix~\sins=a}{\fix~\code{`l'::}\sins=a}
\end{mathparpagebreakable}

We only describe the rules for the left side of the sum -- the equivalent rules for the right hand side are defined analogously.

For fixes to be retrieved from the correct side of the sum, \Miss{} outcomes must be extended with an indicator of what side the information comes from, so that the correct \fix{} function is then called. Some extra care also needs to be taken to handle $\bot$ states separately, since it is not an element of the underlying state models and as such $l(\bot)$ or $r(\bot)$ are not valid -- the auxiliary $\mathit{wrap}_l$ and $\mathit{unwrap}_l$ functions help do this without multiplying by four the number of rules.

The sum is one of the main reasons for the switch from PCMs to RAs, as being able to handle $\bot$ separately is an advantage: it avoids situations where the underlying state may be \emph{observably empty}, but the state of the sum is $l(\mmdl_1.0)$ (if we use PCMs). This causes unsoundness, as for instance actions and predicates belonging to the right side of the sum would then yield \Err{} and \LFail{} respectively, despite the fact that if the state of the sum was simply $\bot$ they'd succeed.

We may give an example to illustrate: let there be the state model $\Ex(\{1\}) + \Ex(\{2\})$. A valid function specification in this state model is \ESLtriple{\corepred{\exP_l}{}{1}}{\code{swap()}}{\corepred{\exP_r}{}{2}}\footnote{The signature of this \code{swap} function is exactly that of the \code{free} action, for the \Freeable{} state model that will later be described.}, where the \code{swap} function switches the state from the left hand side to the right hand side. Now if this was constructed using PCMs, the engine would first consume the core predicate for the precondition. The consumption for $\Ex(\{1\})$ is \ppcons{\ex1,\exP_l,[]}{\Ok,0_l,[1],[]}. The consumption for the sum would thus be \ppcons{l(\ex1),\exP_l,[]}{\Ok,l(0_l),[1],[]}. Note, here, that the sum state model has \emph{no way of knowing if the state became empty}, and must thus keep it as $l(0_l)$. The engine would then produce the postcondition, which is \corepred{\exP_r}{}{2} -- this would however result in the branch vanishing, as $\exP_r$ is not a predicate that can be produced into some $l(x)$. The function call would thus vanish, which is unsound in OX (and would result in no branches in UX, which is sound but useless). \note{I have a formal proof of this unsoundness, I'll add it here eventually, or put it in the appendix, TBD.}

Of course one may decide state models must expose an \code{is\_empty} function, and use that instead -- however this would needlessly complexify state models and would reinvent the wheel; multi-core resource algebras were specifically created to solve this problem \cite{sepalgebra}, and the partial core of Iris was \emph{also} created for this reason among others \cite{iris}.

\subsection{Product}

The product $\mmdl_1 \times \mmdl_2$ of two state models is the cartesian product of both sets of states. Its RA is defined by lifting all elements pointwise: \begin{align*}
 	\Product(X,Y)&\defeq X \times Y\\
 	(x,y)\cdot(x',y') &\defeq (x\cdot x',y\cdot y')\\
 	|(x,y)|&\defeq \begin{cases}
(|x|, |y|) &\If~|x|\neq\bot \land |y|\neq\bot\\
\bot&\Otherwise
 \end{cases}
 \end{align*}

An interesting property of the product is that if one side of the product has no core, then so does the entire product; this also means that both sides of the product must be defined, or neither are defined. This creates a challenge: if an empty ($\bot$) product produces a core predicate for one of its sides, what happens to the other side of the product? Indeed, while one side becomes, defined, $x\times \bot$ is not a valid state, since $\bot \notin \mmdl_2.\Sst$.

It seems here that the consume-produce interface of our engine, which allows creating state bit by bit, can thus be unadapted for certain RAs. Instead, we define an alternative product RA that is more suited to this engine.

\subsection{Partial Product}

The \emph{partial product} state model, denoted $A \bowtie B$, is an alternative to the Iris product RA, that carries some of its useful properties while being adapted to a produce-consume interface. This product supports having only one side be empty -- this is different from the usual product RA, that must have both sides have a value.
\begin{align*}
	\PProduct(X,Y) \defeq X \bowtie Y &\defeq X^? \times Y^? \backslash \{(\bot, \bot)\}\\
	(x, y) \cdot (x', y') &\defeq (x \cdot x', y \cdot y')\\
	|(x, y)| &\defeq \begin{cases}
		\bot &\If~|x|=\bot\land |y|=\bot\\
		(|x|, |y|) &\Otherwise
 	\end{cases}	\\
\end{align*}

The advantage of this definition is twofold. Firstly, it allows expressing fragments of products, where one side may not have a defined core. For instance, given the product state $\ex{a} \times \ex{b}$, one can't express this as the composition of some $\ex{A} \times \bot$ and $\bot \times \ex{b}$, which becomes needed for some state transformers (notably, \PMap{} and \List). This is in turn possible with the partial product . The second advantage of the partial product and one of the main motivations behind it is that it \emph{carries on the exclusivity of its components}. Given $\text{exclusive}(a) \defeq \forall c\ldotp \neg(a\# c)$, the following rule holds:
\[
\inferrule[PartProductEx]
	{\text{exclusive}(a)\\\text{exclusive}(b)}
	{\text{exclusive}(lr(a, b))}
\]
This is needed to allow frame-preserving transitions from one side of a sum to another. We may note also that the state model transformer itself could be generalised to handle an arbitrary number of state models, as $(A \bowtie B) \bowtie C \iff A \bowtie (B \bowtie C)$ -- for the brevity of this presentation, we will only consider the partial product of two state models.

Similarly to the sum, its actions are ${\actions = \{\alpha_l : \alpha \in \mmdl_1.\actions \} \uplus \{\alpha_r : \alpha \in \mmdl_2.\actions \}}$, and core predicates ${\Delta = \{\delta_l : \delta \in \mmdl_1.\Delta \} \uplus \{\delta_r : \delta \in \mmdl_2.\Delta \}}$.
\begin{align*}
	\text{Given }
	\mathit{wrap}(x, y) = \begin{cases}
		\bot &\If~x=\bot \land y=\bot\\
		(x,y) &\Otherwise
	 \end{cases} \text{ and }
	 \mathit{unwrap}(s) = \begin{cases}
 		(\bot, \bot) &\If ~s=\bot\\
		(x, y) &\Otherwise
	 \end{cases}
\end{align*}
\begin{mathparpagebreakable}
\inferrule[PProductLAction]{(x,y)=\mathit{unwrap}(s) \\ \ppexec{\alpha}{x,\sins}{o,x',\souts,\pc} \\ s' = \mathit{wrap}(x',y) \\ o \neq \Miss}{\ppexec{\alpha_l}{s,\sins}{o,s',\souts,\pc}}
\and\inferrule[PProductLActionMiss]{(x,y)=\mathit{unwrap}(s) \\ \ppexec{\alpha}{x,\sins}{o,x',\souts,\pc} \\ s' = \mathit{wrap}(x',y) \\ o = \Miss}{\ppexec{\alpha_l}{s,\sins}{o,s',\code{`l'::}\souts,\pc}}
\and\inferrule[PProductLCons]{(x,y)=\mathit{unwrap}(s) \\ \ppcons{x,\delta_l,\sins}{o,x',\souts,\pc} \\ s' = \mathit{wrap}(x',y) \\ o \neq \Miss}{\ppcons{s,\delta_l,\sins}{o,s',\souts,\pc}}
\and\inferrule[PProductLConsMiss]{(x,y)=\mathit{unwrap}(s) \\ \ppcons{x,\delta_l,\sins}{o,x',\souts,\pc} \\ s' = \mathit{wrap}(x',y) \\ o = \Miss}{\ppcons{s,\delta_l,\sins}{o,s',\code{`l'::}\souts,\pc}}
\and\inferrule[PProductLProd]{(x,y)=\mathit{unwrap}(s) \\ \ppprod{x,\delta_l,\sins}{x',\pc} \\ s'=\mathit{wrap}(x',y)}{\ppprod{s,\delta_l,\sins}{s',\pc}}
\and\inferrule[PProductLFix]{\mmdl_1.\fix~\sins=a}{\fix~\code{`l'::}\sins=a}
\end{mathparpagebreakable}

\subsection{Freeable}

The \Freeable{}(X) state model transformer allows extending a state model with a \free{} action, that allows freeing a part of memory. The freed memory can then not be used, and attempting to access it raises a \code{UserAfterFree} error. This is similar to the \textsc{OneShot} RA of Iris, with the key difference that the \freedP{} predicate used to mark a resource as freed is \emph{not duplicable} -- whereas Iris defines \textsc{OneShot(X) $\defeq$ Frac + Ag(X)}, this definition is not UX-sound. \note{Maybe a small proof of this? Or is it evident?} This is not a problem for Iris, that is only concerned with OX soundness, but justifies this modification for this engine.

Furthermore, to ensure only full states are freed, the underlying state model must expose a $\code{is\_exclusively\_owned}:\Sst\rarr\code{LVal}$, which equates to the property \textsc{PartProductEx} presented before. Note here this returns a \emph{symbolic value}, that can be appended to the path condition (it must thus be a boolean). This allows symbolic ownership, for instance having the fraction of \Frac{} be a symbolic number. To also ensure all misses can be completed, the \Freeable{} state model transformer requires to underlying state model to be exclusively ownable (this is not the case, for instance, of \Ag).

Its RA is as follows: \begin{align*}
	\Freeable(X) &\defeq v(x: X) ~|~ \freed \\
	v(x)\cdot v(x') &\defeq v(x\cdot x') \qquad\text{other compositions are invalid}\\
	|v(x)| &\defeq \begin{cases}
		\bot & \If ~ |x| = \bot\\
		v(|x|)&\Otherwise
	\end{cases}\\
	|\freed| &\defeq \bot
\end{align*}

While one could define \Freeable(X) as a type of \Sum{} (in particular, $X + \Ex(\{ \freedP \})$), this makes adding the \free{} action and \freedP predicate unwieldy; it is thus easier here to redefine a state model transformer from 0. It's actions are thus $\actions=\{\free\} \uplus \mmdl_1.\actions$, and core predicates $\Delta=\{\freedP\}\uplus\mmdl_1.\Delta$.
\begin{align*}
	\text{Given }
	\mathit{wrap}(x) = \begin{cases}
		\bot &\If~x=\bot\\
	 	v(x)&\Otherwise
	 \end{cases} \text{ and }
	 \mathit{unwrap}(x_v) = \begin{cases}
 		\bot &\If ~x=\bot\\
 		x_v &\If~x=v(x_v)\\
 		\text{undefined}&\Otherwise
	 \end{cases}
\end{align*}
\begin{mathparpagebreakable}
\inferrule[FreeableAction]{x=\mathit{unwrap}(x_v) \\ \ppexec{\alpha}{x,\sins}{o,x',\souts,\pc} \\ x_v' = \mathit{wrap}(x')}{\ppexec{\alpha}{x_v,\sins}{o,x_v',\souts,\pc}}
\and\inferrule[FreeableActionUseAfterFree]{}{\ppexec{\alpha}{\freed,\sins}{\Err,x_v,[],[]}}
\and\inferrule[FreeableActionFree]{}{\ppexec{\free}{v(x),[]}{\Ok,\freed,[],[\mmdl.\code{is\_exclusively\_owned}~x]}}
\and\inferrule[FreeableActionFreeErr]{}{\ppexec{\free}{v(x),[]}{\Miss,v(x),\mmdl.\code{fix\_owned}~x,[\neg\mmdl.\code{is\_exclusively\_owned}~x]}}
\and\inferrule[FreeableActionFreeMiss]{}{\ppexec{\free}{\bot,[]}{\Miss,\bot,\mmdl.\code{fix\_owned}~\bot,[]}}
\and\inferrule[FreeableActionDoubleFree]{}{\ppexec{\free}{\freed,[]}{\Err,\freed,[],[]}}
\and\inferrule[FreeableCons]{x=\mathit{unwrap}(x_v) \\ \ppcons{x,\delta,\sins}{o,x',\souts,\pc} \\ x_v'=\mathit{wrap}(x)}{\ppcons{x_v,\delta,\sins}{o,x_v',\souts,\pc}}
\end{mathparpagebreakable}

While not needed for the core and compositional engines, the bi-abductive engine requires misses to provides fixes; \Freeable{} however cannot access directly the core predicates of the underlying state model to provide fix when freeing an empty state. As such, the state model must also provide a $\code{fix\_owned}:\St^?\rarr\pset(\text{Asrt})~\code{list}$ function that returns possible fixes to make the given state exclusively owned.

\subsection{General Map}

\todobox{Write down the RA and the proper rules using the below description.}

Reusing the above examples, we may unify the PMap and List transformers, with the \emph{global map} transformer, shortened GMap. It is parametric on an indexing sort $I\subseteq \Val$, a codomain state model $\St$ and a \emph{discriminator} state model $\St_D$ that must expose a function $\code{is\_within}:\St_D\rarr I\rarr\bools$. It's states are then of the form $I\finmap \St$ for the full state model, and $I\finmap \St\bowtie \St_D$ for the compositional and symbolic state models.

For soundness, the $\code{is\_within}$ function must be true if and only if a singleton partial map with the given index could be validly composed into the state while upholding the desired GMap's invariant. It is used when an index not present in the map is accessed, to tell apart misses from errors (out of bounds accesses). A consequence of this is that when the state is \emph{full}, $\code{is\_within}$ is only used for out of bounds accesses (as otherwise the key is already in the map, since we're dealing with full states), and as such it must always be false -- this explains why the full version of GMap can be $I\finmap \St$ without the discriminator. If we write $\dom \st$ the domain of a GMap's map, given a set of states $\St$ with the subset of full states $\full\St\subseteq\St$, we have that $i\not\in \dom\st \land \st \in \full\St \Rarr \neg(\code{is\_within}~\st~i)$.

To replicate the usual PMap, one would have $\St_D=\text{Ex}(\pset(I))$, with $\code{is\_within}$ true if the value is in the set: $\code{is\_within}_\text{PMap}~\st_D~i=i\in\st_D$. For List, one has $\St_D=\text{Ex}(\nats)$ with $\code{is\_within}_\text{List}~\st_D~i=0 \leq i < \st_D$. Note here that state transformer may automatically assume the outcome is a \Miss{} if the key is not found in the map and the discriminator state isn't set (ie. the state is $l(x)$ for some $x$), as indeed a state fragment containing only the discriminator can always be composed with it to complete the \Miss{}.

Another interesting point is that the discriminator is a state model; this allows it to define its own predicates to control its state. While here both examples use a Ex state model, one could imagine more complex discriminators where information is split across several predicates, which GMap would support too. However, one may note that the discriminator shouldn't define any: because it doesn't exist for the full version of GMap, allowing actions to only exist in the compositional state model would break compatibility.

