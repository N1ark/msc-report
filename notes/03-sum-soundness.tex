\chapter{Sum Soundness}

\section{Current State}

There exists a source of unsoundness in the current definition of the sum state model, related to the representation of empty states and the flipping between both sides of the sum, as there may exist multiple different observably empty states, leading to composition rules being unsound if not accounted for.

To demonstrate this, we may consider the Freeable state. It's full and compositional states are defined as:

\newcommand{\val}[0]{\textit{Val}~}

\begin{align*}
	\text{\underline{Freeable}}(X) &\defeq \varnothing ~|~\val X\\
	\text{Freeable}(X) &\defeq \bot ~|~ \varnothing ~|~ \val X
\end{align*}

With composition:
\begin{align*}
	f \cdot \bot &= f\\
	\bot \cdot f &= f\\
	\val f_1 \cdot \val f_2 &= \val (f_1\cdot f_2)\\
\end{align*}

This forms a valid partially commutative monoid (PCM). We may note that this definition makes Freeable($X$) a type of Sum state, with X the left hand side and the unique state model ``Freed'' on the right hand side. 

Additionally, Freeable($X$) defines a predicate, \code{Freed}, and a single action, \code{free}, that, when the state is \textit{fully owned} (part of the complete states $\underline{X}$), sets the state to $\varnothing$, effectively freeing that bit of memory. Similarly to other state models, predicates and actions that arent \code{Freed} and \code{free} respectively are passed to the contained state model. We define the implementation of \code{consume}, \code{free} and that of the auxiliary \code{is\_fully\_owned} function as:

\begin{lstlisting}
let consume $\st$, $\delta$, $\ins$ =
	match $\delta$, $\st$ with
	| Freed, $\val\st$ -> lfail (MismatchedState, $\st$)
	| Freed, $\varnothing$ -> ok (() $\bot$)
	| $\delta$, $\val\st$ ->
		let* (v', $\st'$) = $X$.consume $\st$ $\delta$ $\ins$ in
		(v', $\val\st'$)
	| $\delta$, $\val\st$ -> lfail (MismatchedState, $\st$)
	| _, $\bot$ -> miss (MissingResource, $\st$)

let free $\st$ =
	match $\st$ with
	| $\val \st$ when is_fully_owned $\st$ -> ok ((), $\varnothing$)
	| $\varnothing$ -> error (DoubleFree, $\st$)
	| _ -> miss (MissingResource, $\st$)
\end{lstlisting}

\begin{align*}
	\code{is\_fully\_owned}~\st \defeq \st \in \underline\St
\end{align*}

We may now look at an example of using this state model that proves to be unsound. Assume the state model Freeable(Exc), in an initial state $\val a$. We want to execute the specification of a simple function that simply executes \code{free}. It thus has a precondition $\corepred{PointsTo}{}{a}$ and a postcondition $\corepred{Freed}{}{}$. To execute it we thus first consume the precondition, and the produce then postcondition.

\begin{table}[h]\centering
\begin{tabular}{l|l}
 State & Operation applied \\ \hline 
 $\val a$ & Initial State \\
 $\val \bot$ & Consume precondition \corepred{PointsTo}{}{a} \\
 undefined! & Produce postcondition \corepred{Freed}{}{}
\end{tabular}
\end{table}

This is, of course, unsound, as the state at the end should indeed be $\varnothing$. This is because $\val \bot$, which is observably empty, is different from the Freeable empty state, $\bot$, rendering the composition $\val \bot \cdot \varnothing$ undefined. 

This error can also be shown to exist in the implementation itself, by writing a specification with \code{False} as the postcondition.

\begin{lstlisting}
spec free_cell()
  [[ <points_to>(;#anything) ]]
  [[ (ret == null) * <freed>(;) ]]
  normal
proc free_cell() {
  n := [free]();
  ret := null;
  return
};

spec test_unsoundness()
  [[ <points_to>(;#anything) ]]
  [[ False ]]
  normal
proc test_unsoundness() {
  n := "free_cell"(x);
  ret := null;
  return
};
\end{lstlisting}

This GIL code is then succesfuly verified, with the following output.

\begin{lstlisting}
Parsing and compiling...
Preprocessing...
Obtaining specs to verify...
Obtaining lemmas to verify...
Obtained 2 symbolic tests in total
Running symbolic tests: 0.002729
Verifying one spec of procedure free_cell... s Success
Verifying one spec of procedure test_unsoundness... Success
All specs succeeded: 0.004729	
\end{lstlisting}



\section{Proof of Unsoundness}

\newcommand{\sone}[0]{\code{S1}~}
\newcommand{\stwo}[0]{\code{S2}~}

The sum state model transformer, $\mmdl_1 \oplus \mmdl_2$ with $\mmdl_1 = (\St_1, 0_1, \cdot)$ and $\mmdl_2 = (\St_2, 0_2, \cdot)$ two valid state models, is currently unsound. In particular, any action that allows flipping the sum from one side to the other is unsound, as it doesn't satisfy frame substraction. This is, for instance, the case with the \code{free} action of the Freeable state model, which is just a type of sum. It is $\mmdl_1 \oplus \mmdl_2 \defeq \code{| }\bot \code{ | S1 } \St_1 \code{ | S2 } \St_2$, and composition is defined as:

\begin{align*}
	\st \cdot \bot &= \st\\
	\bot \cdot \st &= \st\\
	(\sone\st) \cdot (\sone\st') &= \sone(\st\cdot\st')\\
	(\stwo\st) \cdot (\stwo\st') &= \stwo(\st\cdot\st')\\
	\text{undefined}&\text{ otherwise}
\end{align*}

We also remind the frame substraction property, defined as:

\begin{align*}
	&\evalsto{\st\cdot\st_f,e}{o}{\st',v}\implies\\
	&\quad(\exists o',v',\st''.~\evalsto{\st,e}{o'}{\st'',v'}~\land\\
	&\qquad(o'\neq \Miss \implies \st'=\st''\cdot\st_f\land o=o'\land v=v'))
\end{align*}

\newcommand{\swap}[0]{\code{swap}}
\newcommand{\execswap}[3]{\ppexec{\swap}{#1}{#2,#3}}

\begin{proof}

\pfprop{Sum actions that swap sides are not frame preserving}

Assuming 
\begin{hypvlist}
\hypvitem{pcm} $\mmdl_1$ is a well formed PCM, $\mmdl_1 \defeq (\St_1, 0_1, \cdot)$
\hypvitem{pcm2} $\mmdl_2$ is a well formed PCM, $\mmdl_2 \defeq (\St_2, 0_2, \cdot)$
\hypvitem{swap} There is an action \swap{} that may flip the side of a sum from one side to the other, ie.
	\begin{align*}
		\exists \st_1,\st_2',v.~ \execswap{\sone\st_1}{\Ok}{\stwo\st_2',v}
	\end{align*}

\end{hypvlist}
	
We want to prove frame substraction does not hold with action \swap.

\begin{hypvlist}
	\hypvitem{eval} From \hyp{swap} we have $\exists \st_1,\st_2',v.~ \execswap{\sone\st_1}\Ok{\stwo\st_2',v}$
	\hypvitem{comp-eq} From the definition of composition, $\sone\st_1\cdot\sone0_1=\sone\st_1$
	\hypvitem{equiv-s1} From \hyp{comp-eq} and \hyp{eval}, $\execswap{(\sone\st_1\cdot\sone0_1)}\Ok{\stwo\st_2',v}$
\end{hypvlist}
	
To satisfy frame substraction, as the outcome in \hyp{eval} is \Ok, we would need $\stwo\st_2 = \stwo\st_2 \cdot \sone0_1$, which is not the case, as per the definition of composition, $\stwo\st_2 \cdot \sone0_1$ is undefined.

Frame substraction thus does not hold for \swap.
\end{proof}

Note the same can be proven analogously for actions that flip from the right-hand side to the left-hand side.

\section{Sound Sum}

To define a sound version of sum that supports flipping the side, we thus need to remove the $0$ element of both sides from the allowed states, resulting in $\mmdl_1 \oplus \mmdl_2 \defeq \code{| }\bot \code{ | S1 } (\St_1 \backslash \{ 0_1\}) \code{ | S2 } (\St_2 \backslash \{0_2\})$. This ensure the states $\sone0_1$ and $\stwo0_2$ aren't allowed, avoiding the problem seen in frame substraction. 

Additionally, to allow for a frame-preserving \swap{} action, a stronger requirement than a complete state must be met: the state must be \textit{exclusively owned} -- no other non-empty state can be composed with it. This thus requires for a \code{is\_exclusively\_owned} function to be provided, defined as:

\newcommand{\isexowned}[0]{\code{is\_exclusively\_owned}~}
\begin{align*}
	\isexowned\st \defeq \forall\st'.~\st'\neq0\implies\neg(\st\#\st')
\end{align*}


\begin{proof}
\pfprop{\\If a valid frame-preserving sum actions swaps sides, then that sum cannot permit empty elements on either sides and the swapped states must be exclusively owned}

Assuming 
\begin{hypvlist}
\hypvitem{pcm1} $\mmdl_1$ is a well formed PCM, $\mmdl_1 \defeq (\St_1, 0_1, \cdot)$
\hypvitem{cancellative1} $\mmdl_1$ is cancellative, $\st_A \cdot \st_B = \st_A \cdot \st_C \implies \st_B = \st_C$
\hypvitem{pcm2} $\mmdl_2$ is a well formed PCM, $\mmdl_2 \defeq (\St_2, 0_2, \cdot)$
\hypvitem{cancellative2} $\mmdl_2$ is cancellative, $\st_A \cdot \st_B = \st_A \cdot \st_C \implies \st_B = \st_C$
\hypvitem{sumdef} A sum state model is defined as $\mmdl_1\oplus\mmdl_2 \defeq \bot ~|~ \varnothing ~|~ \sone \St_1' ~|~ \stwo \St_2'$ with $\St_1'\subseteq \St_1$ and $\St_2'\subseteq \St_2$.
\hypvitem{comp} Composition of the sum state model is defined as:
	\begin{align*}
		\st \cdot \bot &= \st\\
		\bot \cdot \st &= \st\\
		(\sone\st) \cdot (\sone\st') &= \sone(\st\cdot\st')\\
		(\stwo\st) \cdot (\stwo\st') &= \stwo(\st\cdot\st')\\
		\text{undefined}&\text{ otherwise}
	\end{align*}

\hypvitem{swapexists} There is an action \swap{} that may flip the side of a sum from the left to then right-hand side.
	\begin{align*}
		\exists\st_1,\st_2',v.~\execswap{\sone\st_1}\Ok{\stwo\st_2',v}
	\end{align*}
	
\end{hypvlist}

This \swap{} action is both valid and frame preserving, thus satisfying the following:
\begin{hypvlist}
	\hypvitem{framesub} Frame substraction:
	\begin{align*}
		&\execswap{\st\cdot\st_f}{o}{\st',v}\implies\\
		&\quad(\exists o',v',\st''.~\execswap\st{o'}{\st'',v'}~\land\\
		&\qquad(o'\neq \Miss \implies \st'=\st''\cdot\st_f\land o=o'\land v=v'))
	\end{align*}
	\hypvitem{frameadd} Frame addition:
	\begin{align*}
		&\execswap\st{o}{\st',v}\land \st'\#\st_f\land o\neq\Miss\\
		&\quad\implies \execswap{\st\cdot\st_f}{o}{\st'\cdot\st_f,v}
	\end{align*}
	\hypvitem{misscomp} \Miss{} executions may be completed:
	\begin{align*}
		&\execswap\st\Miss{\st',v}\\
		&\quad\implies(\exists\st_f.~\forall o,\st'',v'.~\execswap{\st\cdot\st_f}o{\st'',v'}\implies o\neq\Miss)
	\end{align*}

\end{hypvlist}
	
We aim to prove:
\begin{goalvlist}
    \goalvitem{zeronotallowedl} The zero elements of the left side of the sum is not permitted: $0_1\notin \St_1'$ 
    \goalvitem{zeronotallowedr} The zero elements of the right side of the sum is not permitted: $0_2\notin \St_2'$ 
    \goalvitem{exownedl} If \swap{} flips the side of the sum, any \swap{} of ``smaller'' states will result in a \Miss:
    \begin{align*}
    	&\execswap{\sone\st_1}\Ok{\stwo\st_2',v}\land \sone\st_1 = \sone\st_A\cdot\sone\st_B \land \execswap{\sone\st_A}{o}{\st'',v'} \\
    	&\quad\implies o = \Miss
    \end{align*}
    \goalvitem{exownedr} If \swap{} flips the side of the sum, the new state must be exclusively owned:
    \begin{align*}
    	\execswap{\sone\st_1}\Ok{\stwo\st_2',v} \implies \isexowned\st_2'  
    \end{align*}
    
\end{goalvlist}


% ------ Proof 0 not in left

We first prove \goal{zeronotallowedl}.

\begin{hypvlist}
	\hypvitem{zeroallowedl} Assume $0_1\in \St_1'$.
	\hypvitem{0framedswapl} From \hyp{comp}, \hyp{zeroallowedl} and \hyp{swapexists}, $\execswap{(\sone\st_1\cdot\sone0_1)}\Ok{\stwo\st_2',v}$ 
\end{hypvlist}

From \hyp{framesub} and \hyp{0framedswapl},
\begin{hypvlist}
	\hypvitem{unframedeval} $\exists p',v',\st''.~\execswap{\sone\st_1}{o'}{\st'',v}$
	\hypvitem{ifnmiss} $o'\neq\Miss\implies \stwo\st_2'=\st''\cdot\sone0_1 \land \Ok=o' \land v=v'$
	\hypvitem{substunfr} From \hyp{swapexists} and \hyp{unframedeval}, $o'=\Ok \land \st''=\stwo\st_2' \land v'=v$
\end{hypvlist}

However, from \hyp{comp}, $\stwo\st_2'\cdot\sone0_1$ is undefined, thus despite $o'=\Ok$ \hyp{substunfr}, $\stwo\st_2'\neq\stwo\st_2'\cdot\sone0_1$ -- our hypothesis~\hyp{zeroallowedl} is thus wrong, giving us our goal $0_1\notin \St_1'$ \goal{zeronotallowedl}.

% -------- Proof 0 not in right

We now prove \goal{zeronotallowedr}.

\begin{hypvlist}
	\hypvitem{zeroallowedr} Assume $0_2\in \St_2'$.
	\hypvitem{frameaddpre} Per \hyp{zeroallowedr} and \hyp{comp}, $\stwo\st_2'~\#~\stwo0_2$, and $\stwo\st_2'\cdot\stwo0_2=\stwo\st_2'$
\end{hypvlist}

Thus per \hyp{swapexists}, \hyp{frameaddpre} and \hyp{frameadd}, we would have $\execswap{(\sone\st_1\cdot\stwo0_2)}\Ok{\stwo\st_2'\cdot\stwo0_2,v}$. This is however not the case, as per \hyp{comp}, $\sone\st_1\cdot\stwo0_2$ is undefined. Our hypothesis~\hyp{zeroallowedr} is thus wrong, giving us our goal~$0_2\notin\St_2'$~\goal{zeronotallowedr}.


% --------- Proof ex owned L

We may now prove our third goal \goal{exownedl}.

\begin{hypvlist}
	\hypvitem{exownedlstrt} Let $\execswap{\sone\st_1}\Ok{\stwo\st_2',v} \land \sone\st_1=\sone\st_A\cdot\sone\st_b \land \execswap{\sone\st_A}{o}{\st'',v'}$.
	\hypvitem{hypnotexownedl} Assume $o\neq\Miss$.
	\hypvitem{framesubbed} From \hyp{framesub}, \hyp{exownedlstrt} and \hyp{hypnotexownedl}, we have $\stwo\st_2'=\st''\cdot\sone\st_B$, and $o=\Ok$. From \hyp{comp} this is however not possible, as no composition from $\sone\!$ yields $\stwo\!$. Our supposition \hyp{hypnotexownedl} is thus false, thus $o=\Miss$.
\end{hypvlist}


% --------- Proof ex owned R

We may finally prove our fourth and last goal \goal{exownedr}.

\begin{hypvlist}
	\hypvitem{exownedrstrt} Let $\execswap{\sone\st_1}{\Ok}{\stwo\st_2',v}$.
	\hypvitem{hypnotexownedr} Assume $\neg\isexowned\st_2'$.
	\hypvitem{frameexistsr} From \hyp{hypnotexownedr}, $\exists \st'.~\st'\neq0 \land \st_2\#\st'$, thus $\st_2\cdot\st'$ is defined and from \hyp{comp} must be expressed as $\st'=\stwo\st_2''$.
	\hypvitem{frameadded} From \hyp{frameadd}, we must have $\execswap{(\sone\st_1\cdot\stwo\st_2'')}\Ok{\stwo\st_2'\cdot\stwo\st_2'',v}$. This is however not possible, as per \hyp{comp}, $\sone\st_1\cdot\stwo\st_2''$ is undefined. Thus our hypothesis \hyp{hypnotexownedr} is false, giving us our goal $\isexowned\st_2'$ \goal{exownedr}.
	
\end{hypvlist}

The same can of course be analogously proven for a \swap that goes from the right-hand side to the left.

\end{proof}

Because Freeable(X) is a type of sum, with X on the left-hand side and a single-state ``Freed'' state on the right, we may now present an implementation of \code{consume} and the \code{free} action of Freeable, that satisfy the above requirements relating to its validity and soundness, and that can be proven to be sound. We assume the input state model X provides an \isexowned function.

\begin{lstlisting}
let consume $\st$, $\delta$, $\ins$ =
	match $\delta$, $\st$ with
	| Freed, $\val\st$ -> lfail (MismatchedState, $\st$)
	| Freed, $\varnothing$ -> ok (() $\bot$)
	| _, $\bot$ -> miss (MissingResource, $\st$)
	| $\delta$, $\val\st$ ->
		let* (v', $\st'$) = $X$.consume $\st$ $\delta$ $\ins$ in
		if $\st'$ = $X.0$ then $\bot$ else (v', $\val\st'$)
	| $\delta$, $\val\st$ -> lfail (MismatchedState, $\st$)
	| $\delta$, $\bot$ -> 
		let* (v', $\st'$) = $X$.consume $X.0$ $\delta$ $\ins$ in
		if $\st'$ = $X.0$ then $\bot$ else (v', $\val\st'$)

let free $\st$ =
	match $\st$ with
	| $\val\st$ when is_exclusively_owned $\st$ -> ok  ((), $\varnothing$)
	| $\varnothing$ -> error (DoubleFree, $\st$)
	| _ -> miss (MissingResource, $\st$)
\end{lstlisting}

The main differences with the previous unsound version are the use of \isexowned over \code{is\_fully\_owned}, which better describes the requirement for no non-0 frame to exist, and the handling of \code{consume}, which verifies if the new state is $\val0$, and if so sets it to $\bot$. We may note also that consuming a predicate $\delta$ while in $\bot$ doesn't automatically result in a \Miss anymore, as it may be the case that X satisfies $\delta$ -- this would be the case, for instance, if it were to expose an ``emp'' predicate, as is seen in linear separation logic.

\section{Sound Emptiness}

A fix to this is to define a ``global'' emptiness, that replaces the different ``local'' empty states each state model may define. Consuming a predicate, or executing an actiyeson, may result in a new state {\it or} a global $\bot$. This forces state model transformers to handle such empty states, and ensures a state becoming empty deep within a now-observably-empty construction will naturally unwrap into a shallow empty. We also lift the composition operation defined by state models to handle $\bot$: $a \cdot \bot = \bot \cdot a = a$.

A side-effect of this is that a non-$\bot$ state is never considered observably-empty, as otherwise it would be $\bot$ -- this allows us to remove the \code{is\_empty} function that was used for some optimisations, as it is sufficient to compare a given state with $\bot$.

An advantage of this approach is that lifting a full state model to a complete state model doesn't require anything (aside from handling $\bot$ in \code{produce} and \code{consume}), as the empty compositional state is already added!

We now redefine some of the constructs used in the engine according to this new definition.
{
\newcommand{\vallist}[0]{\textit{Val}~\code{list}}


\begin{gather*}
	\St^? \defeq \St \uplus \bot\\
	\code{consume}:\St \rarr \Delta \rarr \vallist \rarr (\mathcal O^+_l \times \vallist \times \St^?) \\
	\code{produce}:\St^? \rarr \Delta \rarr \vallist \rarr \vallist \rarr \St~\code{set}\\
	\code{eval\_action}: {\cal A} \rarr \St^? \rarr \vallist \rarr (\mathcal O^+_l \times \vallist \times \St^?)
\end{gather*}}

A consideration with this is that \code{consume} only works on non-$\bot$ elements, as no predicate is satisfied by the empty state (not sure about this). For produce however, a predicate can be produced from the absence of state.

We may now redefine some of the state models with this new idea.

\subsection{State Sum}

A state sum $\mathbb S_1 \oplus \mathbb S_2$ is now defined as \code{type $\St$ = S1 of $\mathbb S_1.\St$ | S2 of $\mathbb S_2.\St$}. We define composition and \code{produce} as follows:

\begin{align*}
	(\code{S1 }\st)\cdot(\code{S1 }\st') &= \code{S1 }(\st\cdot\st')\\
	(\code{S2 }\st)\cdot(\code{S2 }\st') &= \code{S2 }(\st\cdot\st')\\
	\text{undefined}&\text{ otherwise}
\end{align*}

\begin{lstlisting}
produce $\st^?$ $\delta$ $\ins$ $\outs$ =
	match $\st^?$, $\delta$ with
	| S1 $\st_1$, P1 $\delta_1$ -> 
		let* $\delta_1'$ = produce $\st_1$ $\delta_1$ $\ins$ $\outs$ in
		S1 $\delta_1'$
	| $\bot$, P1 $\delta_1$ ->
		let* $\delta_1'$ = produce $\mmdl_1.0$ $\delta_1$ $\ins$ $\outs$ in
		S1 $\delta_1'$
	| S2 $\st_2$, P2 $\delta_2$ -> 
		let* $\delta_2'$ = produce $\st_2$ $\delta_2$ $\ins$ $\outs$ in
		S2 $\delta_2'$
	| $\bot$, P2 $\delta_2$ -> 
		let* $\delta_2'$ = produce $\mmdl_2.0$ $\delta_2$ $\ins$ $\outs$ in
		S2 $\delta_2'$
	| _, _ -> vanish
\end{lstlisting}

